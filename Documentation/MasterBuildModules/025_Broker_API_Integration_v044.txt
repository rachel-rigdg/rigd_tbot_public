================================================================================
Document: 025_Broker_API_Integration
Version: v044
Date: UTC:2025-06-17
================================================================================
Overview:
Defines broker API integration specifications for Alpaca, IBKR, and Tradier within TradeBot {CURRENT_VERSION}. Enforces unified interface, error handling, compliance, auditability, and now symbol universe caching and efficient screener support per latest requirements.

Core Principles:
- Single active broker per bot instance.
- API credentials loaded securely from encrypted secrets at bootstrap.
- No hardcoded credentials or fallback keys.
- All API communication uses secure HTTPS connections.
- All broker events logged with UTC timestamps and strategy context.
- Retry logic capped by `API_RETRY_LIMIT` in `.env_bot`.
- Self-check ensures connectivity and credential validity.
- **Screener logic operates from a pre-filtered, pre-cached symbol universe, NOT the full broker or market list at runtime.**
- **Symbol universe is prepared overnight, filtered by exchange, market cap, price, and exclusions (see "Symbol Universe & Screener" section below).**

Broker-Specific Details:

Alpaca:
- Supports REST and WebSocket.
- Enables long equity and inverse ETFs.
- Fractional shares supported if enabled in `.env_bot`.
- Supports order types: market, limit, stop.
- Rate-limited per Alpaca API policy; backoff used on 429 errors.
- **All screener operations use a cached symbol universe, never full API queries.**

IBKR:
- Supports TWS/Gateway client with async fallback.
- Supports long equity, inverse ETFs, long puts.
- Requires client ID and port configured securely.
- Implements order management, fills, and position sync.
- Supports delayed market data, real-time updates.
- Rate limits respected; errors logged and notified.
- **All screener operations use a cached symbol universe, never full API queries.**

Tradier:
- REST-only broker integration.
- Supports long equity and inverse ETFs.
- Order lifecycle fully managed via REST API calls.
- No websocket support.
- Position sync via polling.
- Suitable for test or smaller deployments.
- **All screener operations use a cached symbol universe, never full API queries.**

Common Interface Requirements:
- All brokers must implement:
  - connect()
  - submit_order()
  - cancel_order()
  - get_positions()
  - get_account_info()
  - self_check()

- Broker adapters reside in `tbot_bot/broker/brokers/`.
- Broker selection and toggles in `.env_bot`: e.g., `ALPACA_ENABLED=true`.
- Fallback and failover handled via `FAILOVER_ENABLED` and `FAILOVER_LOG_TAG`.

Error Handling & Logging:
- All broker exceptions caught, logged with detailed context.
- Fatal connection failures trigger `kill_switch.py`.
- Partial failures retried per `API_RETRY_LIMIT`.
- Order rejects recorded in `unresolved_orders.log`.

Audit & Compliance:
- All broker API requests and responses logged in structured format.
- Sensitive info redacted in logs.
- Compliance with broker TOS enforced.

================================================================================  
Section: Symbol Universe & Screener Caching  
================================================================================

**Symbol Universe Caching Specification:**

- Every night (off-hours), the bot fetches the complete list of supported equities for the target exchanges (NYSE/NASDAQ) using the broker’s API.
- For each symbol:
  - Fetch symbol metadata (ticker, exchange, price, market cap).
  - Apply filters:
    - Exchange: Only NYSE or NASDAQ.
    - Market Cap: $2B ≤ market cap ≤ $10B.
    - Last close price: $5 ≤ price ≤ $100.
  - Exclude delisted, illiquid, blocklisted, or otherwise ineligible symbols.
- The filtered/cached symbol universe is stored as `output/cache/symbol_universe.json` and refreshed nightly.
- **At screener runtime (open/mid/close strategies), only fetch quotes for these pre-filtered symbols.**
- The same cached universe is used by all screeners (Alpaca, IBKR, Tradier, etc.).
- Never make full market API calls during active trading hours; only pull quotes for known eligible symbols.
- **API quotas are preserved; risk of stale or missing price data is minimized.**

**Rationale:**
- Ensures efficient, API-quota-respecting screening.
- Greatly reduces latency and rate limit risk.
- Enables consistent cross-broker symbol handling.
- No wasted API quota on irrelevant symbols.

================================================================================  
Section: Broker Credential Variable Standardization  
================================================================================

**Unified Broker Credential Variables**  
To ensure maintainability and avoid code drift, all broker integrations must consume credentials and endpoint settings from a standardized, broker-agnostic variable set. This applies to both the decrypted `.env_bot` and encrypted `broker_credentials.json.enc` files.

**Mandatory Broker Credential Fields:**  
BROKER_CODE=              # Internal identifier ("ALPACA", "IBKR", "TRADIER", etc.)
BROKER_HOST=              # Broker API host address (if applicable)
BROKER_USERNAME=          # Username or login credential (for brokers requiring authentication)
BROKER_PASSWORD=          # Password or API passphrase (never stored in plaintext)
BROKER_ACCOUNT_NUMBER=    # Account number or ID (if required by the broker)
BROKER_API_KEY=           # Primary API key or token
BROKER_SECRET_KEY=        # Secret key or secondary token (if required)
BROKER_URL=               # Full API base URL (e.g., https://paper-api.alpaca.markets)

**Broker Integration Requirements:**  
- All broker adapters (e.g., `broker_alpaca.py`, `broker_ibkr.py`) must load only these variables from the config/environment, regardless of broker.
- No broker-specific variable names (e.g., `ALPACA_API_KEY`, `IBKR_API_HOST`) are permitted in the config, adapters, or runtime logic.
- Broker adapters are responsible for mapping these generic variables to the exact fields and authentication flows required by their respective APIs.
- All secret fields must be sourced via secure decryption (never from plaintext `.env` in production).

**Example Usage in Broker Adapter:**
```python
# Example (Alpaca)
self.api_key    = env.get("BROKER_API_KEY")
self.secret_key = env.get("BROKER_SECRET_KEY")
self.base_url   = env.get("BROKER_URL")
# ...etc.

# Example (IBKR)
self.host       = env.get("BROKER_HOST")
self.username   = env.get("BROKER_USERNAME")
self.password   = env.get("BROKER_PASSWORD")
self.account    = env.get("BROKER_ACCOUNT_NUMBER")
# ...etc.


Enforcement:

All new broker integrations, migrations, and maintenance updates must use the agnostic variable standard.

The configuration bootstrap and web UI must write these variables into all new bot configs and encrypted secrets files.

Build and test checks should verify that no deprecated broker-specific variables are referenced in any part of the codebase or configuration.

Rationale:

Enables easy switching between brokers and multi-broker expansion.

Avoids codebase drift, brittle logic, and credential sprawl.

Aligns with the overall system architecture and security design.

End of Document