================================================================================
Document: 040
Screener_Symbol_Universe
Version: v049
Date: UTC:2025-07-09 00:00:00
================================================================================

Title: Screener Symbol Universe — Universe Caching, Filtering, Staged Blocklist, Free-First Architecture, and Modular Indexed Source Credential Management

Overview:
--------------------------------------------------------------------------------
This document defines the unified, staged, and *fully free/low-cost data source* approach for building, caching, filtering, and consuming the symbol universe for all trading screeners in the RIGD TradeBot system. Incorporates:  
- Crash resilience  
- Real-time auditability  
- Robust disk-first design using unfiltered and filtered JSON universes  
- Staged API and blocklist workflow  
- "Free-first" data polling  
- Blocklist recovery/maintenance  
- Long-term stability, and fully modular data source integration with generic indexed credential storage.

All screener modules must source their eligible symbol list exclusively from the pre-filtered, pre-built universe file (`symbol_universe.json`). No screener may fetch global lists or build real-time universes.

--------------------------------------------------------------------------------
Section 1: Core Principles
--------------------------------------------------------------------------------

1. **Single canonical symbol universe file** (`symbol_universe.json`) is generated per trading day and must be the *only* source for all screeners.
2. **Universe is built overnight** (after market close, before market open) using NYSE/NASDAQ/NYSE Arca (excluding OTC/pink sheets), with filters applied.
3. **API quota minimization and staged calls:** 
   - *Only* minimal API calls, using free/cheap sources for initial symbol/pricing checks and expensive APIs only for eligible symbols.
   - *Blocklist is managed first* to avoid repeat queries to ineligible symbols.
4. **Staged blocklist and eligibility workflow**:
   - Blocklist is auto-built/updated using price-only queries from free/delayed APIs (e.g. Yahoo, Polygon, Tradier, IEX).
   - Any symbol below `MIN_PRICE` (typically $1.00) is blocklisted and written to disk immediately (with UTC timestamp and source).
   - Blocklist is re-polled on weekends/periodically; any symbol recovering above threshold is removed from the blocklist.
5. **All strategies and brokers share the same universe per trading day.**
6. **Standardized file paths:**
   - `tbot_bot/output/screeners/symbol_universe.unfiltered.json` — Raw, unfiltered, deduplicated symbols (with all available metadata).
   - `tbot_bot/output/screeners/symbol_universe.partial.json` — Inline-filtered, partial progress file.
   - `tbot_bot/output/screeners/symbol_universe.json` — Final, validated, production universe.
   - `tbot_bot/output/screeners/screener_blocklist.txt` — Master blocklist (auto-managed, UTC-stamped, with source and reason).
7. **Universe build is disk-first, crash-resilient:** All symbols and blocklist writes are atomic and resumable. Universe build can resume from either file after crash or quota hit.
8. **Manual 'Force Rebuild', 'Re-filter', and 'Update Blocklist' always available in the Web UI.**
9. **UI displays build status, blocklist status, all table counts, and supports live search/comparison of universes and blocklist.**
10. **No runtime fetching of global symbol lists; universe is fixed for each session and only updated by automated/manual triggers.**
11. **First boot may accept a placeholder, but a full rebuild is required before trading.**
12. **Long-term data stability:** Architecture must run for years with only minimal maintenance, never relying on any one API or data provider for critical filtering (see Section 2).

--------------------------------------------------------------------------------
Section 2: Universe Construction & Blocklist Workflow (Staged, Free-First)
--------------------------------------------------------------------------------

**Nightly Build (Multi-Pass Staged Process):**

1. **Source all possible equity symbols from public/free sources:**  
   - e.g., `nasdaqlisted.txt`, `otherlisted.txt` (NASDAQ FTP), Tradier, Yahoo Finance, IEX (free tier), or any delayed/CSV list.  
   - Write all candidates (symbol, exchange, name) to a temp candidate list.

2. **For each candidate symbol (Pass 1):**  
   a. **If on blocklist:** skip.  
   b. **If not blocklisted:** Query *price only* from a free/delayed API (Yahoo, Polygon, Tradier, IEX, or any custom parser).  
   c. **If price < MIN_PRICE:** Add symbol to blocklist with UTC timestamp, data source, and "below price floor" reason.  
   d. **If price >= MIN_PRICE:** mark as eligible for metadata pass.

3. **Write blocklist after every batch** to ensure durability.

4. **For eligible, non-blocklisted, price >= MIN_PRICE symbols (Pass 2):**  
   a. Query *full metadata* using the highest-quality API available (Finnhub, IBKR, or Polygon for paid, free source otherwise).  
   b. Collect lastClose, marketCap, sector/industry, exchange, fractional eligibility (if available).  
   c. Write each symbol with metadata to `symbol_universe.unfiltered.json` (dedupe as you go).

5. **Apply core filters to each symbol as fetched (Pass 3):**  
   - Exchange must be "NYSE", "NASDAQ", or "ARCA".
   - Price: `MIN_PRICE` ≤ lastClose ≤ `MAX_PRICE`, with broker fractional eligibility enforced for high-priced symbols.
   - Market Cap: `MIN_MARKET_CAP` ≤ marketCap ≤ `MAX_MARKET_CAP`.
   - Must have valid, nonzero, non-null fields (no placeholders).
   - All pass/fail events and filter rejects must be logged (with reasons).

6. **If a symbol passes filter, write immediately to both `symbol_universe.partial.json` and `symbol_universe.json`.**

7. **At end-of-build:**  
   - Compare/merge `partial.json` and `json` to remove duplicates/missing entries, ensuring integrity.
   - Write build audit/log entry (all steps, batch sizes, errors, durations).

**Blocklist Maintenance (Recovery Passes):**  
- Blocklist is automatically rebuilt/refreshed nightly as part of the universe build.
- On weekends or as scheduled, **re-poll blocklisted tickers** (using free price source) to see if any have recovered above the min price threshold.
  - If so, *un-blocklist* immediately and queue for metadata polling in the next build.
- Blocklist may be manually updated by user in UI, but all manual changes are audit-logged and flagged in the file.

--------------------------------------------------------------------------------
Section 3: File/Script Layout & Responsibilities
--------------------------------------------------------------------------------

- `symbol_universe.unfiltered.json`: All raw, deduped, fetched symbols with full metadata (no placeholders).
- `symbol_universe.partial.json`: Inline-filtered, progress-tracking, filtered symbols.
- `symbol_universe.json`: Final, validated, production-ready universe (only fully eligible symbols).
- `screener_blocklist.txt`: Blocklisted tickers with timestamp, data source, and reason (auto-managed and audit logged).
- `universe_ops.log`: Progress log for all universe/blocklist build/rebuild events.
- `tbot_bot/screeners/symbol_universe_refresh.py`: Orchestrates staged fetch, blocklist management, filtering, and all file writes. Implements multi-pass, multi-source staged workflow and recovery.
- `tbot_bot/screeners/screener_utils.py`: Loads/validates universes and blocklist, provides filtering/merge, and all utility functions.
- `tbot_bot/screeners/blocklist_manager.py`: Encapsulates all blocklist load/save, update, audit-log, and recovery polling logic.
- `tbot_web/py/universe_web.py`: Web UI endpoints for display, rebuild, blocklist management, export, status, and manual un/blocklisting.
- `tbot_bot/screeners/universe_logger.py`: Dedicated logging utility for all staged universe/build/blocklist events.

--------------------------------------------------------------------------------
Section 4: Web UI and User Actions
--------------------------------------------------------------------------------

1. **Web UI `/universe` displays:**
   - Counts and status for all universes and blocklist.
   - Four side-by-side, infinitely scrollable tables (unfiltered, partial, final, blocklist).
   - Search/filter box applies across all tables.
   - At-a-glance counts for each file for checksum.
   - “Force Rebuild”, “Re-filter”, and “Update Blocklist” buttons.
   - Progress/heartbeat log in real time.
   - Table export (CSV/JSON) for all files.

2. **Manual 'Re-filter' triggers re-filtering from unfiltered, writing partial/final and merging.**
3. **Manual 'Update Blocklist' triggers blocklist recovery pass (re-poll and unblock eligible symbols).**
4. **Manual un/blocklisting in UI writes audit log entry (with user, timestamp, and reason).**
5. **Export (CSV/JSON) available for all universes and blocklist.**

--------------------------------------------------------------------------------
Section 5: Validation & Maintenance
--------------------------------------------------------------------------------

1. **Validation for every file:**
   - Every entry must have symbol, exchange, lastClose, marketCap.
   - Deduplication required.
   - All files must be valid UTF-8 JSON (no placeholder/null).
   - Blocklist must be consistent and audit-logged.
   - Log all errors and events with UTC timestamps and detailed context.

2. **Test/QA utility script** validates all files and filter logic; reports missing/invalid data, or out-of-spec universe/blocklist.
3. **No universe file or blocklist is deleted or overwritten on failure—atomic save only on successful build.**
4. **Universe and blocklist are only updated after market close or on-demand; runtime never changes them.**

--------------------------------------------------------------------------------
Section 6: API, Quota, and Performance Considerations
--------------------------------------------------------------------------------

1. **API keys sourced securely (never hardcoded).**
2. **All blocklist and initial screening is done using only free, delayed, or anonymous APIs whenever possible.**
3. **Paid/limited API (e.g., Finnhub, IBKR, Polygon) is used only for eligible, non-blocklisted, price-passing symbols.**
4. **All API usage is staged: free-first, batch, throttle all calls (`UNIVERSE_SLEEP_TIME`, per-provider).**
5. **Resume/continue supported via atomic writes to `unfiltered.json` and `blocklist.txt` at every batch.**
6. **Blocklist polling/maintenance must not consume quota from paid sources.**
7. **All errors, quota events, and recoveries are logged with batch/ticker context.**
8. **Data source order/priority is fully modular and updatable (user config or UI-driven).**
9. **If all free sources fail, fallback to last good build or pause build.**

--------------------------------------------------------------------------------
Section 7: Error Handling, Logging, and Recovery
--------------------------------------------------------------------------------

1. **All failures, API errors, and build anomalies logged to `universe_ops.log` (UTC, JSONL or structured text).**
2. **Failed/unexpected build never overwrites previous universe or blocklist.**
3. **Manual review or audit of all log files supported in Web UI.**
4. **On failure, alerting/notification may be triggered (future enhancement).**
5. **All critical actions (build, blocklist update, manual un/blocklist) are audit logged.**
6. **All Web UI operations that write to blocklist or universes must be atomic and log user/action context.**

--------------------------------------------------------------------------------
Section 8: Extensibility and Future-Proofing
--------------------------------------------------------------------------------

1. **Architecture supports:**
   - Multiple brokers, universes, and blocklists.
   - User-supplied symbol lists and alternate sources.
   - Plug-and-play symbol feed adapters (free, paid, delayed, CSV, broker-native, etc.).
   - Dynamic integration with broker APIs for tradability/fractional eligibility.
   - Full audit history and log export.
   - Additional exchanges/regions (modular code and config).
   - Versioned, upgrade-safe universe and blocklist schema (with migration tools).
   - Fully modular and updatable data source configuration (user config or UI-driven).
   - Seamless future integration with AI, advanced filters, or alternate asset classes.

2. **Deployment:**
   - Universe and blocklist files may be pre-built, snapshotted, or exported for new entity onboarding or fast deploy.
   - On entity or jurisdiction change, a single build suffices to bring new bot into full operation with no loss of data integrity.
   - All files are human- and machine-readable for easy audit/recovery/CI.

3. **Long-Term Stability:**
   - Staged, free-first architecture is intended to run for years without vendor lock, pricing changes, or API failures impacting core eligibility and filtering.

--------------------------------------------------------------------------------
Section 9: Dedicated Screener Source Credential Management
--------------------------------------------------------------------------------

**Purpose:**  
Centralize all API keys, tokens, usernames, and passwords for universe/screener symbol sources (Finnhub, IBKR, Polygon, Yahoo, etc.) in a *dedicated, auditable, secure UI and secrets file.*

**Requirements:**

1. **All screener/universe modules must load credentials from a single, dedicated secrets file:**  
   - Path: `tbot_bot/storage/secrets/screener_api.json.enc`
   - All API keys/tokens for each supported source, with provider labels.

2. **Dedicated credential config web UI:**  
   - New page: `/screener_credentials`
   - Add, edit, rotate, and remove all screener/universe source credentials in a unified view.
   - Field validation (min length, format, label required).
   - All changes logged (user, timestamp, action, field changed).
   - No sensitive info ever logged in plaintext—only audit events.

3. **Backend API routes:**  
   - `GET /api/screener_credentials`: return decrypted credentials (only for authorized admin users)
   - `POST /api/screener_credentials`: create/update credential for a given provider
   - `DELETE /api/screener_credentials/<provider>`: remove a provider’s credentials
   - All endpoints require authentication/authorization.

4. **Atomic, encrypted file writes:**  
   - Changes are atomically written to `screener_api.json.enc` using strong encryption.
   - Old credentials rotated to backup file with UTC timestamp.
   - File never stored or transmitted unencrypted.

5. **UI/UX:**  
   - Sidebar or nav integration for "Screener Credentials" (admin only)
   - Modal for adding/editing credentials, including provider, API key, secret, user/pass, etc.
   - Display masked values (show/hide toggle)
   - Warn on missing/expired credentials

6. **Frontend files:**  
   - `tbot_web/templates/screener_credentials.html`: credential management UI
   - `tbot_web/static/js/screener_credentials.js`: UI logic (add, edit, remove, save, rotate, mask/unmask)
   - CSS file: `/static/css/pages/screener_credentials.css`

7. **Backend files/routes:**  
   - `tbot_web/py/screener_credentials_web.py`: Flask blueprint for the UI and API
   - Integration with encryption/decryption (existing secrets framework)
   - Access control: only admin users can view or edit

8. **Credential usage in universe build:**  
   - All loaders/source adapters (finnhub, ibkr, polygon, etc.) must use only the central credential loader and never fetch from main bot config.
   - All credential errors must fail fast and log a sanitized event.
   - Test/QA utility for credential completeness (flags missing/expired/incomplete config).

9. **Audit and logging:**  
   - Every change (add/edit/delete/rotate) is audit-logged with timestamp, user, provider, action (never the secret itself).
   - Log path: `tbot_bot/output/logs/screener_credentials_audit.log`

10. **Deployment/migration:**  
    - Entity onboarding and live deploy must always include this encrypted secrets file; never store in source control.
    - Example: `/storage/secrets/screener_api.json.enc.example` included for schema.

--------------------------------------------------------------------------------
Section 10: New/Updated File List for Screener Credential Management
--------------------------------------------------------------------------------

**Backend:**
- `tbot_web/py/screener_credentials_web.py`       # Flask blueprint: UI/API for screener source credentials (GET/POST/DELETE, UI routes)
- `tbot_bot/support/secrets_manager.py`           # Extend if needed: credential encryption/decryption utilities
- `tbot_bot/storage/secrets/screener_api.json.enc`   # The encrypted credential file (production)
- `tbot_bot/storage/secrets/screener_api.json.enc.example`  # Example/schema only (never real keys)

**Frontend/UI:**
- `tbot_web/templates/screener_credentials.html`  # UI: Credential config page
- `tbot_web/static/js/screener_credentials.js`    # JS: Credential form logic, API calls, masking
- `tbot_web/static/css/pages/screener_credentials.css`  # CSS: Style for the credential page

**Audit/Logging:**
- `tbot_bot/output/logs/screener_credentials_audit.log`   # All admin/user changes to credentials (never secrets, only metadata)

**Integration/Usage:**
- All screener modules, symbol_source_loader, and universe build process must ONLY call a central credential loader:  
  - Example: `from tbot_bot.support.secrets_manager import get_screener_credentials`
  - Never fetch secrets from the main bot config or .env.

**Migration/QA:**
- On migration or backup/restore, credentials must be re-encrypted and not left in plaintext.
- Universe validation utility must check for missing/broken credentials before any build.

================================================================================
