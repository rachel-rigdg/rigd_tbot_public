================================================================================
Document: 040
Screener_Symbol_Universe
Version: v047
Date: UTC:2025-07-09 00:00:00
================================================================================
Overview:
--------------------------------------------------------------------------------
This document defines the unified, staged, and *fully free/low-cost data source* approach for building, caching, filtering, and consuming the symbol universe for all trading screeners in the RIGD TradeBot system. Incorporates:  
- Crash resilience  
- Real-time auditability  
- Robust disk-first design using unfiltered and filtered JSON universes  
- Staged API and blocklist workflow  
- "Free-first" data polling  
- Blocklist recovery/maintenance  
- Long-term stability  
- Fully modular data source integration with generic indexed credential storage, enabling multiple simultaneous providers with dedicated API keys and settings per provider.

All screener modules must source their eligible symbol list exclusively from the pre-filtered, pre-built universe file (`symbol_universe.json`). No screener may fetch global lists or build real-time universes at runtime.

--------------------------------------------------------------------------------
Section 1: Core Principles
--------------------------------------------------------------------------------

1. **Single canonical symbol universe file** (`symbol_universe.json`) is generated per trading day and must be the *only* source for all screeners.
2. **Universe is built overnight** (after market close, before market open) using NYSE/NASDAQ/NYSE Arca (excluding OTC/pink sheets), with filters applied.
3. **API quota minimization and staged calls:**  
   - *Only* minimal API calls, using free/cheap sources for initial symbol/pricing checks and expensive APIs only for eligible symbols.  
   - *Blocklist is managed first* to avoid repeat queries to ineligible symbols.  
   - API keys and credentials for all data providers are centrally managed in a *dedicated, encrypted, indexed secrets file*, enabling easy rotation, audit logging, and per-provider modular use.
4. **Staged blocklist and eligibility workflow:**  
   - Blocklist is auto-built/updated using price-only queries from free/delayed APIs (e.g. Yahoo, Polygon, Tradier, IEX).  
   - Any symbol below `MIN_PRICE` (typically $1.00) is blocklisted and written to disk immediately (with UTC timestamp, data source, and reason).  
   - Blocklist is re-polled on weekends/periodically; any symbol recovering above threshold is removed from the blocklist.  
5. **All strategies and brokers share the same universe per trading day.**  
6. **Standardized file paths:**  
   - `tbot_bot/output/screeners/symbol_universe.unfiltered.json` — Raw, unfiltered, deduplicated symbols (with all available metadata).  
   - `tbot_bot/output/screeners/symbol_universe.partial.json` — Inline-filtered, partial progress file.  
   - `tbot_bot/output/screeners/symbol_universe.json` — Final, validated, production universe.  
   - `tbot_bot/output/screeners/screener_blocklist.txt` — Master blocklist (auto-managed, UTC-stamped, with source and reason).  
7. **Universe build is disk-first, crash-resilient:** All symbols and blocklist writes are atomic and resumable. Universe build can resume from either file after crash or quota hit.  
8. **Manual 'Force Rebuild', 'Re-filter', and 'Update Blocklist' always available in the Web UI.**  
9. **UI displays build status, blocklist status, all table counts, and supports live search/comparison of universes and blocklist.**  
10. **No runtime fetching of global symbol lists; universe is fixed for each session and only updated by automated/manual triggers.**  
11. **First boot may accept a placeholder, but a full rebuild is required before trading.**  
12. **Long-term data stability:** Architecture must run for years with only minimal maintenance, never relying on any one API or data provider for critical filtering (see Section 2).  
13. **Data source credentials are centrally stored and managed:** All data source adapters (Finnhub, IBKR, Polygon, Yahoo, Tradier, Alpaca, etc.) exclusively retrieve API keys and auth data from a single secure secrets file with generic indexed providers, ensuring modularity, security, and auditability.

--------------------------------------------------------------------------------
Section 2: Universe Construction & Blocklist Workflow (Staged, Free-First)
--------------------------------------------------------------------------------

**Nightly Build (Multi-Pass Staged Process):**

1. **Source all possible equity symbols from public/free sources:**  
   - e.g., `nasdaqlisted.txt`, `otherlisted.txt` (NASDAQ FTP), Tradier, Yahoo Finance, IEX (free tier), or any delayed/CSV list.  
   - Symbol loading uses modular adapters located in `symbol_sources/`, each sourcing symbols using provider-specific credentials managed centrally.  
   - Write all candidate symbols (symbol, exchange, name) to a temporary candidate list.

2. **For each candidate symbol (Pass 1):**  
   a. **If on blocklist:** skip immediately.  
   b. **If not blocklisted:** Query *price only* from a free/delayed API provider selected via configured priority list and centralized credentials.  
   c. **If price < MIN_PRICE:** Add symbol to blocklist with UTC timestamp, data source provider, and "below price floor" reason.  
   d. **If price ≥ MIN_PRICE:** mark symbol as eligible for full metadata pass.

3. **Write blocklist to disk after every batch** for durability and crash resilience.

4. **For eligible, non-blocklisted, price ≥ MIN_PRICE symbols (Pass 2):**  
   a. Query *full metadata* (lastClose, marketCap, sector/industry, exchange, fractional eligibility) using the highest-quality configured API provider for metadata, selected via central credentials and provider priority.  
   b. Write each symbol’s full metadata immediately to `symbol_universe.unfiltered.json` with deduplication as processing proceeds.

5. **Apply core filters to each symbol as fetched (Pass 3):**  
   - Exchange must be one of the allowed exchanges (e.g. "NYSE", "NASDAQ", "ARCA").  
   - Price between `MIN_PRICE` and `MAX_PRICE`, with broker fractional eligibility enforced for high-priced symbols.  
   - Market Cap within configured `MIN_MARKET_CAP` and `MAX_MARKET_CAP` bounds.  
   - Fields must be valid, non-null, non-placeholder values.  
   - All filter passes, fails, and reasons are logged for audit and debugging.

6. **For symbols passing filter, immediately write to both `symbol_universe.partial.json` and `symbol_universe.json`** for real-time build progress tracking and crash resilience.

7. **At end-of-build:**  
   - Compare and merge `symbol_universe.partial.json` and `symbol_universe.json` to remove duplicates and missing entries, ensuring final file integrity.  
   - Write comprehensive build audit/log entry covering all passes, batch sizes, errors, and durations.

**Blocklist Maintenance (Recovery Passes):**  
- Blocklist is automatically refreshed nightly as part of the universe build process using free/delayed price sources with credentials managed centrally.  
- On weekends or scheduled intervals, **re-poll blocklisted tickers** using free price sources to check for price recovery above `MIN_PRICE`.  
  - Symbols passing recovery criteria are immediately removed from the blocklist and queued for full metadata retrieval on next build.  
- Blocklist may be manually updated by authorized users via the Web UI; all manual changes are audit-logged with user, timestamp, and reason, and flagged within the blocklist file.
--------------------------------------------------------------------------------
Section 3: File/Script Layout & Responsibilities
--------------------------------------------------------------------------------

- `symbol_universe.unfiltered.json`: All raw, deduped, fetched symbols with full metadata (no placeholders).
- `symbol_universe.partial.json`: Inline-filtered, progress-tracking, filtered symbols.
- `symbol_universe.json`: Final, validated, production-ready universe (only fully eligible symbols).
- `screener_blocklist.txt`: Blocklisted tickers with UTC timestamp, source provider, reason, audit-logged.
- `universe_ops.log`: UTC timestamped progress and audit log for all universe/blocklist build, update, and recovery events.
- `tbot_bot/screeners/symbol_universe_refresh.py`: Orchestrates staged fetch, blocklist management, filtering, and atomic file writes. Implements multi-pass, multi-provider staged workflow, crash recovery, and audit logging.
- `tbot_bot/screeners/screener_utils.py`: Loads, validates universes and blocklist; performs filtering, merging, deduplication, drift detection, and utility helpers.
- `tbot_bot/screeners/blocklist_manager.py`: Encapsulates blocklist CRUD, archival, audit-logging, and periodic recovery polling logic with multi-provider awareness.
- `tbot_bot/screeners/universe_logger.py`: Dedicated UTC, structured logger for all staged universe/build/blocklist events and user actions.
- `tbot_web/py/universe_web.py`: Web UI API endpoints for universe/blocklist display, rebuild, blocklist management, export, status, manual un/blocklisting, and audit log access.
- `tbot_bot/screeners/symbol_source_loader.py`: Modular orchestrator loading all symbol sources using provider-specific credentials and error handling.
- `tbot_bot/screeners/symbol_sources/`: Modular provider adapters implementing symbol loading with central credential usage.
- `tbot_bot/support/secrets_manager.py`: Central encrypted credential loader used by all screeners and symbol sources, ensures secure key/token management and audit.

--------------------------------------------------------------------------------
Section 4: Web UI and User Actions
--------------------------------------------------------------------------------

1. **Web UI `/universe` displays:**
   - Real-time counts and status for all universe and blocklist files.
   - Four side-by-side, infinitely scrollable tables for unfiltered, partial, final universes, and blocklist.
   - Global search/filter box applying across all tables simultaneously.
   - At-a-glance checksum/hash and record counts for file integrity verification.
   - Buttons for “Force Rebuild”, “Re-filter”, and “Update Blocklist” actions with real-time progress feedback.
   - Live progress/heartbeat logs displayed as they occur.
   - Export options for all tables/files in CSV and JSON formats.

2. **Manual 'Re-filter':**
   - Re-applies filtering logic from the current unfiltered universe file.
   - Writes updated partial and final universe files with deduplication and audit logging.

3. **Manual 'Update Blocklist':**
   - Triggers a recovery pass to re-poll blocklisted symbols using free sources.
   - Unblocks symbols that have recovered above threshold.
   - All changes audit-logged with user, timestamp, and reason.

4. **Manual un/blocklisting via UI:**
   - Authorized users can add or remove tickers from blocklist.
   - Each manual change is logged with user identity, timestamp, and justification.
   - Changes persist atomically and update blocklist file with audit flags.

5. **All universe and blocklist files are exportable** as CSV and JSON formats for offline review or backup.

--------------------------------------------------------------------------------
Section 5: Validation & Maintenance
--------------------------------------------------------------------------------

1. **Validation of all universe and blocklist files prior to use:**
   - Each entry must include required fields: symbol, exchange, lastClose, marketCap.
   - Strict deduplication enforced at every file save.
   - Files must be valid UTF-8 encoded JSON, with no placeholders or nulls.
   - Blocklist entries must include timestamp, data source/provider, and audit flags.
   - All validation errors and anomalies are logged with UTC timestamps and detailed context for diagnostics.

2. **Automated test and QA utility scripts** validate schema compliance, data integrity, filtering logic correctness, and credential completeness.  
   - These run on-demand or as part of CI/CD pipelines.
   - Any missing or broken configuration or credential flags failure.

3. **Atomic save policy:**
   - No universe or blocklist file is overwritten or deleted on failure.
   - Temporary files and atomic rename used to guarantee disk integrity.

4. **Update cadence:**
   - Universe and blocklist files are updated only after market close or via manual triggers.
   - Runtime systems never perform real-time or dynamic global symbol fetching or universe rebuilding during active trading sessions.

--------------------------------------------------------------------------------
Section 6: API, Quota, and Performance Considerations
--------------------------------------------------------------------------------

1. **API keys are securely sourced exclusively from the central encrypted credentials store** (`screener_api.json.enc`); never hardcoded or stored in plaintext.  
2. **All blocklist management and initial universe screening utilize only free, delayed, or anonymous APIs wherever feasible** to minimize quota consumption and cost.  
3. **Paid or limited quota APIs (e.g., Finnhub, IBKR, Polygon) are only called for eligible, non-blocklisted, price-qualified symbols** to optimize usage and cost.  
4. **API calls are staged and throttled with provider-specific sleep intervals (`UNIVERSE_SLEEP_TIME`) and batched where supported to comply with rate limits.**  
5. **The universe build supports atomic batch persistence with resumability via incremental writes to `symbol_universe.unfiltered.json` and `screener_blocklist.txt`.**  
6. **Blocklist recovery polling is strictly performed using free or delayed data sources to avoid consuming paid API quotas.**  
7. **All API errors, quota limits, throttling events, and recoveries are logged with detailed batch and ticker context for diagnostics and audit.**  
8. **Data source priority and order is modular and dynamically configurable via user settings or UI control, enabling easy source updates or swaps.**  
9. **If all free data sources fail or become unavailable, the system falls back to the last successful universe build or pauses build with logged alerts.**  
10. **Credential loading failures must fail fast, aborting the build step, and must log sanitized error events without exposing secrets.**  
11. **All credential access is centralized through the secure credential loader, ensuring consistency and minimizing risk of hardcoded or environment variable leaks.**

--------------------------------------------------------------------------------
Section 7: Error Handling, Logging, and Recovery
--------------------------------------------------------------------------------

1. **All failures, API errors, quota exceptions, and build anomalies are logged in detail to `universe_ops.log` using UTC timestamps in structured JSON Lines or equivalent format.**  
2. **No failed or partial universe or blocklist build will overwrite existing valid files; atomic renames ensure integrity and crash recovery.**  
3. **Full manual review, audit, and export of all universe, blocklist, and operational logs are supported via Web UI interfaces.**  
4. **Planned future enhancements include alerting and notification on critical build failures or quota exhaustion events.**  
5. **All critical actions including universe build, blocklist update, and manual un/blocklisting via UI are audit logged with user identity, timestamps, and reasons (without storing secrets).**  
6. **All Web UI operations that mutate universe or blocklist files must perform atomic writes and record user and action context for compliance and traceability.**  
7. **Credential changes and access events are also audit logged with user and timestamp metadata, ensuring traceability of all sensitive operations.**  
8. **Failure or misconfiguration in credentials triggers build aborts with sanitized logs, preventing corrupted or insecure universe states.**


--------------------------------------------------------------------------------
Section 8: Extensibility and Future-Proofing
--------------------------------------------------------------------------------

1. **The architecture supports:**
   - Multiple brokers operating simultaneously, each with independent universe and blocklist files.
   - User-supplied symbol lists and the ability to integrate alternate data sources.
   - Plug-and-play symbol feed adapters for free, paid, delayed, CSV, or broker-native data feeds.
   - Dynamic broker API integration to determine tradability and fractional share eligibility.
   - Comprehensive audit history with exportable logs and change tracking.
   - Modular codebase and configuration to add new exchanges, asset classes, or geographic regions easily.
   - Versioned universe and blocklist schemas with migration utilities for seamless upgrades.
   - Fully modular, user-configurable data source priority and credential management via secure UI.
   - Future integration pathways for AI-driven filtering, advanced analytics, or expansion to other asset classes.

2. **Deployment considerations:**
   - Universe and blocklist files can be pre-built, snapshotted, or exported to onboard new entities or enable rapid deployments.
   - Changes in entity or jurisdiction require only a single rebuild to bring new bot instances online with data integrity maintained.
   - All data files remain human- and machine-readable to facilitate audit, recovery, and continuous integration workflows.

3. **Long-term stability:**
   - The staged, free-first data architecture is designed to operate reliably for years without vendor lock-in or interruptions due to API changes, pricing, or outages.


--------------------------------------------------------------------------------
Section 9: Dedicated Screener Source Credential Management
--------------------------------------------------------------------------------

**Purpose:**  
Centralize all API keys, tokens, usernames, and passwords for universe/screener symbol sources (Finnhub, IBKR, Polygon, Yahoo, etc.) in a *dedicated, auditable, secure UI and encrypted secrets file.*

**Requirements:**

1. **All screener and universe modules must load credentials exclusively from a single, centralized encrypted secrets file:**  
   - Path: `tbot_bot/storage/secrets/screener_api.json.enc`  
   - Contains all API keys, tokens, usernames, and passwords for all supported symbol sources, indexed by provider.

2. **Dedicated credential management UI:**  
   - Accessible at `/screener_credentials` route (admin only).  
   - Supports adding, editing, rotating, and removing screener source credentials in a unified interface.  
   - Enforces field validation (minimum length, format, and required labels).  
   - Logs all changes (user identity, timestamp, action, and changed fields).  
   - Never logs sensitive secret values in plaintext; logs only metadata.

3. **Backend API endpoints:**  
   - `GET /api/screener_credentials` — Returns decrypted credentials for authorized admin users only.  
   - `POST /api/screener_credentials` — Creates or updates credentials for a given provider.  
   - `DELETE /api/screener_credentials/<provider>` — Removes credentials for specified provider.  
   - All endpoints require proper authentication and authorization.

4. **Atomic encrypted persistence:**  
   - All changes are atomically written to `screener_api.json.enc` using strong encryption (e.g., Fernet).  
   - Previous versions rotated to timestamped backup files for audit and rollback.  
   - Secrets are never stored or transmitted unencrypted at rest or in transit.

5. **UI/UX details:**  
   - Credential management integrated into admin sidebar or navigation menu.  
   - Modal dialogs for adding or editing credentials, including fields for provider, API key, secret, username/password, etc.  
   - Credentials display with masked values and show/hide toggle.  
   - Warnings displayed for missing, incomplete, or expired credentials.

6. **Frontend components:**  
   - `tbot_web/templates/screener_credentials.html`: Credential management page template.  
   - `tbot_web/static/js/screener_credentials.js`: JavaScript logic for form handling, API calls, masking, and validation.  
   - `tbot_web/static/css/pages/screener_credentials.css`: Styling specific to the credential management UI.

7. **Backend components:**  
   - `tbot_web/py/screener_credentials_web.py`: Flask blueprint managing UI and API routes for credential management.  
   - Integrates with the existing encryption/decryption utilities in `secrets_manager.py`.  
   - Enforces strict access control allowing only admins to view or modify credentials.

8. **Usage in universe builds and source loaders:**  
   - All screener modules and symbol source adapters must load all API credentials exclusively via the centralized credential loader function (e.g., `get_screener_credentials`).  
   - Must never read secrets from environment variables or main bot configuration.  
   - Credential loading failures must fail fast and generate sanitized error logs.  
   - Test and QA utilities must validate credential completeness and correctness before any universe build.

9. **Audit and logging:**  
   - All add/edit/delete/rotate operations on credentials are audit logged with user, timestamp, provider, and action (never including secret contents).  
   - Audit logs are stored at `tbot_bot/output/logs/screener_credentials_audit.log`.

10. **Deployment and migration:**  
    - Credential secrets file (`screener_api.json.enc`) must always be included during deployment and entity onboarding; never committed to source control.  
    - A schema-only example file (`screener_api.json.enc.example`) is provided for reference.  
    - Backup and restore processes must re-encrypt credentials and never leave secrets in plaintext.  
    - Universe validation utilities must verify credential presence and integrity before any build attempt.


--------------------------------------------------------------------------------
Section 10: New/Updated File List for Screener Credential Management
--------------------------------------------------------------------------------

**Backend:**
- `tbot_web/py/screener_credentials_web.py`       # Flask blueprint: UI and API for managing screener credentials
- `tbot_bot/support/secrets_manager.py`           # Core encryption/decryption and credential management utilities
- `tbot_bot/storage/secrets/screener_api.json.enc`   # Encrypted screener credentials (production)
- `tbot_bot/storage/secrets/screener_api.json.enc.example`  # Schema-only example credentials file

**Frontend/UI:**
- `tbot_web/templates/screener_credentials.html`  # Credential management page template
- `tbot_web/static/js/screener_credentials.js`    # JS form logic and API integration
- `tbot_web/static/css/pages/screener_credentials.css`  # Page-specific CSS styling

**Audit/Logging:**
- `tbot_bot/output/logs/screener_credentials_audit.log`   # Audit log for all credential change events

**Integration/Usage:**
- All screener modules, symbol source loader, and universe build process must exclusively load credentials via:  
  `from tbot_bot.support.secrets_manager import get_screener_credentials`  
  Never use bot config or environment variables for API secrets.

**Migration/QA:**
- Migration and backup/restore workflows must re-encrypt credentials properly.  
- Universe validation utilities enforce credential integrity and flag missing or broken secrets prior to build.

--------------------------------------------------------------------------------
Section 9: Dedicated Screener Source Credential Management
--------------------------------------------------------------------------------

**Purpose:**  
Centralize all API keys, tokens, usernames, and passwords for universe/screener symbol sources (Finnhub, IBKR, Polygon, Yahoo, etc.) in a *dedicated, auditable, secure UI and encrypted secrets file.*

**Requirements:**

1. **All screener and universe modules must load credentials exclusively from a single, centralized encrypted secrets file:**  
   - Path: `tbot_bot/storage/secrets/screener_api.json.enc`  
   - Contains all API keys, tokens, usernames, and passwords for all supported symbol sources, indexed by provider.

2. **Dedicated credential management UI:**  
   - Accessible at `/screener_credentials` route (admin only).  
   - Supports adding, editing, rotating, and removing screener source credentials in a unified interface.  
   - Enforces field validation (minimum length, format, and required labels).  
   - Logs all changes (user identity, timestamp, action, and changed fields).  
   - Never logs sensitive secret values in plaintext; logs only metadata.

3. **Backend API endpoints:**  
   - `GET /api/screener_credentials` — Returns decrypted credentials for authorized admin users only.  
   - `POST /api/screener_credentials` — Creates or updates credentials for a given provider.  
   - `DELETE /api/screener_credentials/<provider>` — Removes credentials for specified provider.  
   - All endpoints require proper authentication and authorization.

4. **Atomic encrypted persistence:**  
   - All changes are atomically written to `screener_api.json.enc` using strong encryption (e.g., Fernet).  
   - Previous versions rotated to timestamped backup files for audit and rollback.  
   - Secrets are never stored or transmitted unencrypted at rest or in transit.

5. **UI/UX details:**  
   - Credential management integrated into admin sidebar or navigation menu.  
   - Modal dialogs for adding or editing credentials, including fields for provider, API key, secret, username/password, etc.  
   - Credentials display with masked values and show/hide toggle.  
   - Warnings displayed for missing, incomplete, or expired credentials.

6. **Frontend components:**  
   - `tbot_web/templates/screener_credentials.html`: Credential management page template.  
   - `tbot_web/static/js/screener_credentials.js`: JavaScript logic for form handling, API calls, masking, and validation.  
   - `tbot_web/static/css/pages/screener_credentials.css`: Styling specific to the credential management UI.

7. **Backend components:**  
   - `tbot_web/py/screener_credentials_web.py`: Flask blueprint managing UI and API routes for credential management.  
   - Integrates with the existing encryption/decryption utilities in `secrets_manager.py`.  
   - Enforces strict access control allowing only admins to view or modify credentials.

8. **Usage in universe builds and source loaders:**  
   - All screener modules and symbol source adapters must load all API credentials exclusively via the centralized credential loader function (e.g., `get_screener_credentials`).  
   - Must never read secrets from environment variables or main bot configuration.  
   - Credential loading failures must fail fast and generate sanitized error logs.  
   - Test and QA utilities must validate credential completeness and correctness before any universe build.

9. **Audit and logging:**  
   - All add/edit/delete/rotate operations on credentials are audit logged with user, timestamp, provider, and action (never including secret contents).  
   - Audit logs are stored at `tbot_bot/output/logs/screener_credentials_audit.log`.

10. **Deployment and migration:**  
    - Credential secrets file (`screener_api.json.enc`) must always be included during deployment and entity onboarding; never committed to source control.  
    - A schema-only example file (`screener_api.json.enc.example`) is provided for reference.  
    - Backup and restore processes must re-encrypt credentials and never leave secrets in plaintext.  
    - Universe validation utilities must verify credential presence and integrity before any build attempt.

--------------------------------------------------------------------------------
Section 11: Credential Usage Best Practices, Security, and Maintenance
--------------------------------------------------------------------------------

1. **Fail-Fast and Sanitized Error Handling:**  
   - All screener modules must immediately fail and log sanitized error events if required credentials are missing, invalid, or expired, to prevent silent failures during universe builds.

2. **Testing and QA Integration:**  
   - Universe validation and screener test utilities must verify credential presence, validity, and completeness prior to initiating any build or API calls, minimizing runtime errors and build failures.

3. **Credential Rotation and Expiration:**  
   - Credential rotation is supported via the UI with automatic backup of old credentials stamped by UTC timestamp.  
   - Expiration tracking and rotation reminders are recommended to maintain uninterrupted API access.

4. **Role-Based Access Control (RBAC):**  
   - Only authorized admin users may access or modify screener credentials through the web UI or API.  
   - All endpoints enforce strict authentication and authorization controls.

5. **Versioning and Schema Evolution:**  
   - Credential file format is versioned and designed for backward compatibility to allow seamless upgrades and schema migrations without disruption.

6. **Automated Encrypted Backups and Recovery:**  
   - Every credential change triggers an automatic encrypted backup to support recovery from accidental corruption or deletion.  
   - Backups are stored securely with UTC timestamp metadata for audit and rollback purposes.

7. **Audit Trail and Operational Transparency:**  
   - All credential operations (add, edit, delete, rotate) are fully audit logged without exposing secret values, ensuring traceability and security compliance.

8. **Security Compliance and Best Practices:**  
   - Secrets must never be stored or transmitted in plaintext at any stage.  
   - Credential management aligns with organizational security policies and regulatory requirements.

