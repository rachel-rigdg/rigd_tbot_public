
================================================================================
Document:080
Env_Security_Integration_and_Expansion_Modules
Version: v045
Date: UTC:2025-06-24 00:00:00
================================================================================



================================================================================
 Expansion_Modules
{CURRENT_VERSION}
================================================================================
Overview:
This document defines optional expansion modules for TradeBot, fully compliant with core architecture {CURRENT_VERSION}. Modules are independently testable, maintain strict separation of concerns, and must be toggled exclusively via `.env_bot`.

Modules Included:

1. Backtesting and Strategy Optimization
- Backtesting framework in `tbot_bot/backtest/`
- Supports simulation of historical trade data, slippage, latency
- Must adhere to `.env_bot.test` config schema
- Produces JSON/CSV summaries for tuning, stored in `backtest_results/`
- Optimization supports grid, bayesian, genetic methods; results versioned in Web UI

2. Detailed Broker API Integration
- Includes advanced adapters for Alpaca, IBKR, Tradier
- Handles REST/WebSocket, order lifecycle, retry, error management
- Implements `.self_check()` with connection, credential validation
- Supports fallback routing and failover per `.env_bot` toggles
- Logs all API events for audit; rate limits strictly enforced

3. Encryption & Key Management Enhancements
- Key rotation tooling (`tools/rotate_keys.py`)
- Automated config encryption/decryption workflows (`tools/encrypt_env_bot.py`)
- Secure ephemeral key storage strategies for container/cloud deployments
- Audit trails for key usage and config changes

4. Reporting & Compliance Extensions
- Extended reporting API for tax, regulatory filings
- Custom OFX export formats
- Automated backup rotation and cloud sync scripts
- Fine-grained alerting and escalation policies

Implementation Notes:
- All optional modules must NOT interfere with core runtime if disabled.
- Modules must implement `.self_check()` to integrate with system health.
- Any config toggles required must be clearly documented in `.env_bot` schema.
- Use strict logging standards and audit trails.

Compliance:
- Modules adhere strictly to {CURRENT_VERSION} build instructions and audit requirements.
- No runtime config or credential leaks permitted.
- Must operate independently of Web UI unless explicitly integrated.


================================================================================
Env_Config_and_Security Modules 
{CURRENT_VERSION}
================================================================================

This module defines environment variable configurations and security protocols for the TradeBot system.

Contents:
- .env / .env_enc – Top-Level Environment Configuration
- .env_bot / env_bot.enc – Trading Bot Configuration File
- Secure Environment Variables (UPDATED – Ephemeral Encrypted Deployment)
- Encryption and Secret Management Modules Location Update

Strict encryption, key management, and runtime validation requirements apply as detailed herein.

============================================================
.env / .env_enc – Top-Level Environment Configuration
============================================================

# This file is parsed by tbot_bot/, tbot_web/, and related utility scripts.
# It references secure decryption keys only — no raw credentials are stored here.

# Core Environment Settings
ENVIRONMENT=production
CONTROL_DIR=control
ENV_BOT_PATH=.env_bot

# Encrypted Credential Keys (Paths relative to project root)
ENV_KEY_PATH=storage/keys/env.key
ENV_ENC_KEY_PATH=storage/keys/env_enc.key
LOGIN_KEY_PATH=storage/keys/login.key
BROKER_KEY_PATH=storage/keys/broker.key
SMTP_KEY_PATH=storage/keys/smtp.key
SCREENER_API_KEY_PATH=storage/keys/screener_api.key
ACCT_API_KEY_PATH=storage/keys/acct_api.key
ALERT_KEY_PATH=storage/keys/alert.key

# Encrypted Secrets (Resolved at Runtime)
BROKER_CREDENTIALS_PATH=storage/secrets/broker_credentials.json.enc
SMTP_CREDENTIALS_PATH=storage/secrets/smtp_credentials.json.enc
SCREENER_API_PATH=storage/secrets/screener_api.json.enc
ACCT_API_CREDENTIALS_PATH=storage/secrets/acct_api_credentials.json.enc
NETWORK_CONFIG_PATH=storage/secrets/network_config.json.enc
ALERT_CHANNELS_PATH=storage/secrets/alert_channels.json.enc
BOT_IDENTITY_PATH=storage/secrets/bot_identity.json.enc

# Session / Login Controls
SESSION_TIMEOUT=3000
LOGIN_ATTEMPT_LIMIT=10
LOGIN_LOCKOUT_MINUTES=15
SESSION_TIMEOUT_MINUTES=120

================================================================================
 .env_bot / env_bot.enc – Trading Bot Configuration File
================================================================================

# .env_bot – TradeBot Configuration v1.0.0+
# All strategy logic, broker routing, and runtime behavior are driven by this file.
# Time values are specified in UTC. Comments indicate usage and system impact.
# -----------------------------------------
# General & Debugging
# -----------------------------------------
# Version tag (must match VERSION.md)
VERSION_TAG=v1.0.0
# debug or release – sets internal behavior and logging verbosity
BUILD_MODE=release
# Master kill switch to block all trading activity
DISABLE_ALL_TRADES=false
# Logging level: quiet, info, or verbose
DEBUG_LOG_LEVEL=verbose
# Enable writing log files to /logs and /backups
ENABLE_LOGGING=true
# json (structured) or csv (flat) log output format
LOG_FORMAT=json
# -----------------------------------------
# Trade Execution & Risk Controls
# -----------------------------------------
# If true, bot will wait for manual confirmation before sending trades
TRADE_CONFIRMATION_REQUIRED=false
# Number of times to retry failed broker API calls      
API_RETRY_LIMIT=3
# how many seconds before timeout 
API_TIMEOUT=30
# Allow fractional shares (broker must support)
FRACTIONAL=true
# Total capital allocated per strategy session (e.g., 2% of account)
TOTAL_ALLOCATION=0.02
# Max number of trades allowed per strategy window
MAX_TRADES=4
# Trade weight percentages based on number of triggered trades
WEIGHTS=0.4,0.2,0.2,0.2
# Absolute loss limit (e.g., 5% of capital); triggers shutdown
DAILY_LOSS_LIMIT=0.05
# Maximum allocation per trade based on account value (2.5%)
MAX_RISK_PER_TRADE=0.025
# Cap on total simultaneous positions across all strategies
MAX_OPEN_POSITIONS=5                   
# -----------------------------------------
# Price & Volume Filters
# -----------------------------------------
# Minimum price allowed per trade
MIN_PRICE=5
# Maximum price allowed per trade
MAX_PRICE=100
# Minimum volume filter 
MIN_VOLUME_THRESHOLD=1000000       
# Finnhub Guard filter 
ENABLE_FUNNHUB_FUNDAMENTALS_FILTER=true
MAX_PE_RATIO=50
MAX_DEBT_EQUITY=2.5
# -----------------------------------------
# Strategy Routing & Broker Mode
# -----------------------------------------
# Broker Name (Options: ALPACA, IBKR, TRADIER, etc.)
BROKER_NAME="ALPACA"  
# Strategy run order; values: open, mid, close
STRATEGY_SEQUENCE=open,mid,close
# Optional: override normal order and run only one strategy
STRATEGY_OVERRIDE=
# -----------------------------------------
# Automated Rebalance Triggers
# -----------------------------------------
# Master toggle for automated rebalancing
REBALANCE_ENABLED=true     
# Trigger threshold (fractional, e.g., 0.10 = 10% deviation)              
REBALANCE_THRESHOLD=0.10     
# Check interval in seconds (default: 3600s = 1 hour)            
REBALANCE_CHECK_INTERVAL=3600           
# -----------------------------------------
# Failover Broker Routing
# -----------------------------------------
# Master toggle for failover routing
FAILOVER_ENABLED=true                
# Tag applied to rerouted trades in logs/ledgers
FAILOVER_LOG_TAG=FAILOVER_ACTIVE         
# -----------------------------------------
# Global Time & Polling
# -----------------------------------------
# Days allowed for trading (UTC-based control logic)
TRADING_DAYS=mon,tue,wed,thu,fri
# Interval between polling cycles for runtime monitoring
SLEEP_TIME=1s
# -----------------------------------------
# OPEN Strategy Configuration (20 min trading)
# -----------------------------------------
# Maximum gap allowed from open to current price (used in screener)
MAX_GAP_PCT_OPEN=0.1
# Minimum and maximum market cap allowed for OPEN strategy candidates
MIN_MARKET_CAP_OPEN=2000000000
MAX_MARKET_CAP_OPEN=10000000000
# Enable or disable OPEN strategy
STRAT_OPEN_ENABLED=true
# UTC start time (market open = 9:30 AM EST)
START_TIME_OPEN=14:30
# Minutes to track high/low range before breakout
OPEN_ANALYSIS_TIME=20
# Minutes to for breakout to happen
OPEN_BREAKOUT_TIME=10
# Minutes to monitor active positions
OPEN_MONITORING_TIME=30
# Breakout threshold above high/low range (e.g., 2%)
STRAT_OPEN_BUFFER=0.02
# Shorting method: InverseETF, disabled, ShortSell, LongPut,
SHORT_TYPE_OPEN= InverseETF               
# -----------------------------------------
# MID Strategy Configuration (VWAP Reversion)
# -----------------------------------------
# Maximum gap allowed from open to current price (used in screener)
MAX_GAP_PCT_MID=0.1
# Minimum and maximum market cap allowed for MID strategy candidates
MIN_MARKET_CAP_MID=2000000000
MAX_MARKET_CAP_MID=10000000000
# Enable or disable MID strategy
STRAT_MID_ENABLED=true
# UTC start time (10:30 AM EST)
START_TIME_MID=15:30
# Minutes before trade signal is evaluated
MID_ANALYSIS_TIME=15
# Minutes to for breakout to happen
MID_BREAKOUT_TIME=10
# Maximum hold time after entry
MID_MONITORING_TIME=30
# VWAP deviation required to enter trade
STRAT_MID_VWAP_THRESHOLD=0.02
# Shorting method: InverseETF, ShortSell, LongPut,  or disabled
SHORT_TYPE_MID= InverseETF              
# -----------------------------------------
# CLOSE Strategy Configuration (EOD Momentum/Fade)
# -----------------------------------------
# Maximum gap allowed from open to current price (used in screener)
MAX_GAP_PCT_CLOSE=0.1
# Minimum and maximum market cap allowed for CLOSE strategy candidates
MIN_MARKET_CAP_CLOSE=2000000000
MAX_MARKET_CAP_CLOSE=10000000000
# Enable or disable CLOSE strategy
STRAT_CLOSE_ENABLED=true
# UTC start time (2:30 PM EST)
START_TIME_CLOSE=19:30
# Minutes to detect signal
CLOSE_ANALYSIS_TIME=5
# Minutes to for breakout to happen
CLOSE_BREAKOUT_TIME=5
# Duration to manage position after entry
CLOSE_MONITORING_TIME=25
# Min VIX level required to allow entry
STRAT_CLOSE_VIX_THRESHOLD=15
# Shorting method: InverseETF, ShortSell, LongPut, or disabled
SHORT_TYPE_CLOSE= InverseETF               
# -----------------------------------------
# Notifications
# -----------------------------------------
# Send email alert on trade entry
NOTIFY_ON_FILL=true
# Send email alert on trade exit
NOTIFY_ON_EXIT=true                    
# -----------------------------------------
# Reporting & Ledger Export
# -----------------------------------------
# auto = export after each trade, off = no export
LEDGER_EXPORT_MODE=auto
# -----------------------------------------
# Defense Mode (Disaster Risk Reduction)
# -----------------------------------------
# Set true if Disaster Protocol triggers; resets to false on recovery
DEFENSE_MODE_ACTIVE=false
# Percentage of normal MAX_CONCURRENT_TRADES allowed (rounded down)
DEFENSE_MODE_TRADE_LIMIT_PCT=66
# Maximum session allocation allowed during Defense Mode (e.g., 1%)
DEFENSE_MODE_TOTAL_ALLOCATION=0.01
# -----------------------------------------
# ENHANCEMENT MODULE TOGGLES 
# -----------------------------------------
# --- Rebalance Notification ---
ENABLE_REBALANCE_NOTIFIER=true
# Notify accounting if float deviates ±10% from target
REBALANCE_TRIGGER_PCT=10                         
# --- Role-Based Web Access ---
# Enable multi-user roles in web dashboard
RBAC_ENABLED=true
# Default role for new users                                
DEFAULT_USER_ROLE=viewer
# --- Strategy Optimizer ---
ENABLE_STRATEGY_OPTIMIZER=true
# Historical days for parameter tuning
OPTIMIZER_BACKTEST_LOOKBACK_DAYS=30
# Options: grid_search, bayesian, genetic              
OPTIMIZER_ALGORITHM=grid_search                
OPTIMIZER_OUTPUT_DIR=backtest_results/strategy_tuning/
# --- Real-Time Alerts ---
NOTIFY_ON_FILL=true
NOTIFY_ON_EXIT=true
NOTIFY_ON_FAILURE=true
 # Options: email, slack, sms, pagerduty
CRITICAL_ALERT_CHANNEL=pagerduty
# Options: email, slack                
ROUTINE_ALERT_CHANNEL=email
# --- Backtest Slippage Modeling ---
ENABLE_SLIPPAGE_MODEL=true
# Options: none, rule_based, randomized
SLIPPAGE_SIMULATION_TYPE=randomized
 # Average slippage %              
SLIPPAGE_MEAN_PCT=0.15 
# Standard deviation                         
SLIPPAGE_STDDEV_PCT=0.10
 # Artificial delay (in milliseconds) per order                         
SIMULATED_LATENCY_MS=500                        
# --- black_scholes_filter Enhancements (if applicable) ---
ENABLE_BSM_FILTER=true
# Reject if >15% over/under priced
MAX_BSM_DEVIATION=0.15
# Used in BSM if not supplied dynamically              
RISK_FREE_RATE=0.045
# Options: static, dynamic — dynamic adjusts by JURISDICTION_CODE via bot_identity                
RISK_FREE_RATE_SOURCE=dynamic       



=============================================================================================================================================
Secure Environment Variables (UPDATED – Ephemeral Encrypted Deployment)
=============================================================================================================================================

Overview:
TradeBot separates runtime configuration into two environment files:
- `.env` contains global config, API keys, encryption keys, and paths to encrypted credential files — **never raw credentials**.
- `.env_bot` defines all trading logic, risk controls, and strategy parameters — **never stored in version control**.

Security Goals:
- `.env_bot` and all sensitive config data are encrypted at rest using AES-256 (Fernet).
- Encrypted config files reside under `tbot_bot/support/` as `.env_bot.enc` and other category-specific encrypted files (`.bot_identity.enc`, `.broker.enc`, etc.).
- Corresponding encryption keys reside under `tbot_bot/storage/keys/`.
- Decryption keys and encrypted files are **never committed to source control** (enforced by `.gitignore` and `.scpignore`).
- The system performs **runtime decryption in-memory only**, avoiding persistent plaintext files on disk.
- Post-decryption, sensitive data is immediately overwritten or discarded after use.
- All decryption errors are logged securely for audit purposes.

Module Locations & Responsibilities:
- Encryption and decryption logic centralized in:
  - `tbot_bot/support/encrypt_secrets.py`
  - `tbot_bot/support/decrypt_secrets.py`
  - `tbot_bot/config/security_bot.py` (manages bot config encryption, key validation, and secret writes)
- The Web UI configuration module (`tbot_web/py/configuration_web.py`) handles:
  - Writing encrypted secret category files into `tbot_bot/support/`.
  - Initializing core databases.
  - Encrypting `.env_bot` in-memory and saving `.env_bot.enc`.
- `tbot_bot/config/env_bot.py` loads and validates decrypted bot config at runtime.
- All secret keys and encrypted files are accessed via absolute paths resolved by `tbot_bot/support/path_resolver.py`.

Ephemeral .env.enc Support:
- For container or cloud deployment, `.env` may be distributed as `.env.enc`.
- On startup, `.env.enc` is decrypted in-memory using the key at `storage/keys/env_enc.key`.
- No plaintext `.env` is ever persisted on disk in production.
- `.env_bot` follows similar ephemeral encrypted deployment, ensuring sensitive bot config is protected.

Encryption/Decryption Workflow:
1. Populate plaintext `.env_bot` with required variables.
2. Encrypt `.env_bot` using `tools/encrypt_env_bot.py` to produce `.env_bot.enc`.
3. Upload `.env_bot.enc` and corresponding keys (`env.key`, `env_enc.key`, etc.) to deployment servers.
4. At runtime, decrypt `.env_bot.enc` **in memory**; load and validate keys.
5. All category-specific encrypted JSON files (`bot_identity.json.enc`, `broker.json.enc`, etc.) are written and read from `tbot_bot/support/` during Web UI config lifecycle.
6. The bootstrap process initializes missing secret category files from Web UI input.

Validation and Error Handling:
- Decryption failures or missing required environment variables cause fatal startup errors.
- All such errors are logged with timestamps and module context.
- Clear human-readable error messages are displayed to operators without revealing secrets.
- Access to encryption keys must be strictly restricted in production environments.

Recovery:
- Restore encrypted secrets and keys from secure backups if files are lost or corrupted.
- Re-encrypt plaintext secrets if needed using `tools/encrypt_env_bot.py` and related scripts.
- Rotate encryption keys on personnel changes or compromise.

Best Practices:
- Never store plaintext secrets in version control or on persistent disk.
- Use ephemeral decrypted configs only in RAM or secure temporary storage.
- Exclude all decrypted secrets and encryption keys via `.gitignore` and `.scpignore`.
- Log all secret access and decryption events for audit trails.
- Perform thorough staging environment testing before production deployment.

Compliance and Verification:
- The `build_check.py` tool verifies presence, integrity, and consistency of all required encrypted config and key files before session start.
- Runtime config loads are monitored and audited by the logging subsystem.

---

**Summary Table:**

| File                | Type           | Storage Location                     | Deployment State       | Encryption Key Location              |
|---------------------|----------------|------------------------------------|-----------------------|------------------------------------|
| `.env`              | Global config  | Project root                       | Optional (plaintext)   | -                                  |
| `.env.enc`          | Global config  | Project root                       | Recommended (encrypted)| `storage/keys/env_enc.key`          |
| `.env_bot`          | Bot config     | Project root (temp only)           | Forbidden (prod)       | -                                  |
| `.env_bot.enc`      | Bot config     | `tbot_bot/support/`                | Required (encrypted)   | `storage/keys/env.key`              |
| `bot_identity.json.enc` | Bot identity  | `tbot_bot/support/`               | Created during bootstrap | `storage/keys/bot_identity.key`  |
| `broker.json.enc`       | Broker creds  | `tbot_bot/support/`                | Created during bootstrap | `storage/keys/broker.key`         |
| `smtp.json.enc`         | SMTP creds    | `tbot_bot/support/`                | Created during bootstrap | `storage/keys/smtp.key`           |
| `screener_api.json.enc` | Screener API  | `tbot_bot/support/`                | Created during bootstrap | `storage/keys/screener_api.key`   |
| `network_config.json.enc` | Network config | `tbot_bot/support/`              | Created during bootstrap | `storage/keys/network.key`        |
| `alert_channels.json.enc` | Alert channels | `tbot_bot/support/`              | Created during bootstrap | `storage/keys/alert.key`          |

---

**NOTE:**
- All encrypted secret category files under `tbot_bot/support/` are generated and managed exclusively by the Web UI configuration bootstrap process.
- No plaintext secrets should be stored outside the Web UI input or staging environment files.
- The bot runtime relies exclusively on the encrypted `.env_bot.enc` and the category files to operate securely.
- Encrypted files and keys must never be committed to any version control system.

---

================================================================================
Broker_API_Integration Modules
{CURRENT_VERSION}
================================================================================
Overview:
Defines broker API integration specifications for Alpaca, IBKR, and Tradier within TradeBot {CURRENT_VERSION}. Enforces unified interface, error handling, compliance, auditability, and now symbol universe caching and efficient screener support per latest requirements.

Core Principles:
- Single active broker per bot instance.
- API credentials loaded securely from encrypted secrets at bootstrap.
- No hardcoded credentials or fallback keys.
- All API communication uses secure HTTPS connections.
- All broker events logged with UTC timestamps and strategy context.
- Retry logic capped by `API_RETRY_LIMIT` in `.env_bot`.
- Self-check ensures connectivity and credential validity.
- **Screener logic operates from a pre-filtered, pre-cached symbol universe, NOT the full broker or market list at runtime.**
- **Symbol universe is prepared overnight, filtered by exchange, market cap, price, and exclusions (see "Symbol Universe & Screener" section below).**

Broker-Specific Details:

Alpaca:
- Supports REST and WebSocket.
- Enables long equity and inverse ETFs.
- Fractional shares supported if enabled in `.env_bot`.
- Supports order types: market, limit, stop.
- Rate-limited per Alpaca API policy; backoff used on 429 errors.
- **All screener operations use a cached symbol universe, never full API queries.**

IBKR:
- Supports TWS/Gateway client with async fallback.
- Supports long equity, inverse ETFs, long puts.
- Requires client ID and port configured securely.
- Implements order management, fills, and position sync.
- Supports delayed market data, real-time updates.
- Rate limits respected; errors logged and notified.
- **All screener operations use a cached symbol universe, never full API queries.**

Tradier:
- REST-only broker integration.
- Supports long equity and inverse ETFs.
- Order lifecycle fully managed via REST API calls.
- No websocket support.
- Position sync via polling.
- Suitable for test or smaller deployments.
- **All screener operations use a cached symbol universe, never full API queries.**

Common Interface Requirements:
- All brokers must implement:
  - connect()
  - submit_order()
  - cancel_order()
  - get_positions()
  - get_account_info()
  - self_check()

- Broker adapters reside in `tbot_bot/broker/brokers/`.
- Broker selection and toggles in `.env_bot`: e.g., `ALPACA_ENABLED=true`.
- Fallback and failover handled via `FAILOVER_ENABLED` and `FAILOVER_LOG_TAG`.

Error Handling & Logging:
- All broker exceptions caught, logged with detailed context.
- Fatal connection failures trigger `kill_switch.py`.
- Partial failures retried per `API_RETRY_LIMIT`.
- Order rejects recorded in `unresolved_orders.log`.

Audit & Compliance:
- All broker API requests and responses logged in structured format.
- Sensitive info redacted in logs.
- Compliance with broker TOS enforced.

================================================================================  
Section: Symbol Universe & Screener Caching  
================================================================================

**Symbol Universe Caching Specification:**

- Every night (off-hours), the bot fetches the complete list of supported equities for the target exchanges (NYSE/NASDAQ) using the broker’s API.
- For each symbol:
  - Fetch symbol metadata (ticker, exchange, price, market cap).
  - Apply filters:
    - Exchange: Only NYSE or NASDAQ.
    - Market Cap: $2B ≤ market cap ≤ $10B.
    - Last close price: $5 ≤ price ≤ $100.
  - Exclude delisted, illiquid, blocklisted, or otherwise ineligible symbols.
- The filtered/cached symbol universe is stored as `output/cache/symbol_universe.json` and refreshed nightly.
- **At screener runtime (open/mid/close strategies), only fetch quotes for these pre-filtered symbols.**
- The same cached universe is used by all screeners (Alpaca, IBKR, Tradier, etc.).
- Never make full market API calls during active trading hours; only pull quotes for known eligible symbols.
- **API quotas are preserved; risk of stale or missing price data is minimized.**

**Rationale:**
- Ensures efficient, API-quota-respecting screening.
- Greatly reduces latency and rate limit risk.
- Enables consistent cross-broker symbol handling.
- No wasted API quota on irrelevant symbols.

================================================================================  
Section: Broker Credential Variable Standardization  
================================================================================

**Unified Broker Credential Variables**  
To ensure maintainability and avoid code drift, all broker integrations must consume credentials and endpoint settings from a standardized, broker-agnostic variable set. This applies to both the decrypted `.env_bot` and encrypted `broker_credentials.json.enc` files.

**Mandatory Broker Credential Fields:**  
BROKER_CODE=              # Internal identifier ("ALPACA", "IBKR", "TRADIER", etc.)
BROKER_HOST=              # Broker API host address (if applicable)
BROKER_USERNAME=          # Username or login credential (for brokers requiring authentication)
BROKER_PASSWORD=          # Password or API passphrase (never stored in plaintext)
BROKER_ACCOUNT_NUMBER=    # Account number or ID (if required by the broker)
BROKER_API_KEY=           # Primary API key or token
BROKER_SECRET_KEY=        # Secret key or secondary token (if required)
BROKER_URL=               # Full API base URL (e.g., https://paper-api.alpaca.markets)

**Broker Integration Requirements:**  
- All broker adapters (e.g., `broker_alpaca.py`, `broker_ibkr.py`) must load only these variables from the config/environment, regardless of broker.
- No broker-specific variable names (e.g., `ALPACA_API_KEY`, `IBKR_API_HOST`) are permitted in the config, adapters, or runtime logic.
- Broker adapters are responsible for mapping these generic variables to the exact fields and authentication flows required by their respective APIs.
- All secret fields must be sourced via secure decryption (never from plaintext `.env` in production).

**Example Usage in Broker Adapter:**
```python
# Example (Alpaca)
self.api_key    = env.get("BROKER_API_KEY")
self.secret_key = env.get("BROKER_SECRET_KEY")
self.base_url   = env.get("BROKER_URL")
# ...etc.

# Example (IBKR)
self.host       = env.get("BROKER_HOST")
self.username   = env.get("BROKER_USERNAME")
self.password   = env.get("BROKER_PASSWORD")
self.account    = env.get("BROKER_ACCOUNT_NUMBER")
# ...etc.


Enforcement:

All new broker integrations, migrations, and maintenance updates must use the agnostic variable standard.

The configuration bootstrap and web UI must write these variables into all new bot configs and encrypted secrets files.

Build and test checks should verify that no deprecated broker-specific variables are referenced in any part of the codebase or configuration.

Rationale:

Enables easy switching between brokers and multi-broker expansion.

Avoids codebase drift, brittle logic, and credential sprawl.

Aligns with the overall system architecture and security design.




================================================================================
User Credential & Configuration Lifecycle Blueprint
{CURRENT_VERSION}
================================================================================

This blueprint defines user credential management, configuration file lifecycle, encryption practices, Fernet key provisioning, role-based access controls (RBAC), and the initial user registration flow for RIGD TradeBot.  
**All provisioning, key generation, secrets management, and user registration triggers are launched via the Web UI, with all privileged operations performed in backend scripts in `tbot_bot/config/`. No privileged action occurs in Flask or web endpoints.**

---

## 1. Core Principles

- **Autonomy:** After secure bootstrap, the bot manages user credentials, Fernet keys, config, and authentication fully locally—*no runtime dependency on external systems*.
- **Web UI as Trigger:** All credential, key, config file creation—including Fernet key provisioning and user registration—is *triggered exclusively via the Web UI*. No CLI/manual provisioning is permitted after bootstrap.
- **Backend Provisioning:** *All privileged actions* (key generation, encrypted secret/DB creation, bootstrapping) are performed by backend scripts in `tbot_bot/config/`, *never* directly by Flask or tbot_web.
- **Encrypted local storage:** All credentials and sensitive configs are **always encrypted at rest** under `tbot_bot/storage/secrets/` (JSON) and Fernet keys under `tbot_bot/storage/keys/`.
- **No shared/runtime auth:** Bot never queries external systems for credentials or Fernet keys at runtime; all storage is local and autonomous.

---

## 2. User Credential Lifecycle

### 2.1 Creation & Storage

- Credentials (username, bcrypt password, roles, email) are managed via the Web UI and initial registration flow. 
- If no user exists after provisioning and bootstrapping, the user is redirected to a *dedicated user registration page* (`register.html`, `register_web.py`).
- Passwords are securely hashed with **bcrypt** and encrypted using Fernet; plaintext is never stored or transmitted.
- Credentials are stored in **`SYSTEM_USERS.db`** (`tbot_bot/core/databases/`), encrypted using Fernet key at `tbot_bot/storage/keys/login.key`.
- Initial user registration and DB/user setup is *triggered only via Web UI* (not CLI/scripts), and user registration may be invoked separately after bootstrap.
- Fernet key files for credentials are auto-provisioned and stored in `tbot_bot/storage/keys/`—by backend provisioning script (`provisioning_runner.py`), *never manually*.

### 2.2 Password Update & User Management

- User registration and password change are handled by a persistent registration form (`register.html`) and endpoint (`register_web.py`).
- After first successful provisioning and bootstrapping, if no users exist in the database, the bot automatically redirects to the registration page.
- To change username or password later, user navigates to registration page to update credentials, which persist in SYSTEM_USERS.db and update encrypted keys as needed.

### 2.3 Backup & Recovery

- Credential backups (bcrypt hashes/metadata) are saved encrypted under `tbot_bot/storage/backups/`.
- All backups are encrypted; plaintext is forbidden.
- Import/export is performed via future Web UI tools, never CLI/manual.
- Periodic encrypted backup and rotation is best practice.

### 2.4 Authentication & Runtime

- Auth and session management are *fully local*; Fernet-encrypted session tokens with UTC expiry.
- Password rehashing/upgrades handled locally.
- All auth/session events are audit-logged (UTC, user, IP, event).

---

## 3. Secrets, Identity, and Key File Management

### 3.1 Broker API Credentials

- Encrypted broker API credentials (`broker_credentials.json.enc`) are imported via UI, stored at `tbot_bot/storage/secrets/`.
- **Fernet key (`broker.key`) is provisioned by the backend provisioning script, triggered by the UI.**

### 3.2 Entity/Jurisdiction/Bot Identity

- Identity metadata (`ENTITY_CODE`, `JURISDICTION_CODE`, `BROKER_CODE`, `BOT_ID`) is imported/updated via the Web UI and written as encrypted JSON.
- **Fernet key for identity (`bot_identity.key`) is provisioned by backend only.**
- No external queries/calls for identity.

### 3.3 Key File Provisioning Policy

- **All Fernet key files are provisioned and checked by the backend (`key_manager.py`/`provisioning_helper.py`), triggered by the Web UI.**
- Keys are written only to `tbot_bot/storage/keys/`.
- *Manual/CLI key creation is forbidden* and will be flagged as noncompliant.

---

## 4. Configuration & User Registration Sync Flow

1. **Trigger:** User saves config via Web UI (`configuration.html` POST), which writes runtime config and sets provisioning trigger/flag (`PROVISION_FLAG`).
2. **Backend Provisioning:** `tbot_bot/config/provisioning_runner.py` detects the trigger, performs all key generation, encrypted config/secret creation, DB initialization, and writes status.
3. **Validation:** Strict validation for completeness, schema, checksums; audit logs for every step.
4. **Initial User Registration:** After provisioning and bootstrapping, if no user exists, UI automatically redirects to `/register`. Registration persists user/password in SYSTEM_USERS.db.
5. **Atomic & Safe:** All syncs are atomic and concurrency-safe.
6. **Audit:** All events logged with UTC, checksum, user/context, success/failure.
7. **Separation:** UI triggers provisioning/user registration; *backend does all privileged actions.*

---

## 5. Support Module Responsibilities

| Module                      | Role                                            | Enforcement Policy                                            |
|-----------------------------|------------------------------------------------|--------------------------------------------------------------|
| `key_manager.py`            | Fernet key creation/rotation/checks             | Only called by provisioning_runner.py; never CLI/UI direct   |
| `security_users.py`         | User RBAC and Fernet key helpers                | Key/user provisioning only from backend                      |
| `config_encryption.py`      | Encrypts/decrypts secrets/backups, secure writes| Always uses keys from `storage/keys/`                        |
| `db_bootstrap.py`           | DB initialization via backend scripts           | Invoked only by provisioning_runner.py                       |
| `auth_web.py`               | Handles login/session/token in UI               | No key or secret management                                  |
| `register_web.py`           | Manages user registration and persistence       | Updates SYSTEM_USERS.db if no users, or when credentials are changed |
| `default_config_loader.py`  | Loads UI config templates                       | No key/secret management                                     |
| `session_manager.py`        | Session state, token handling                   | No key or secret storage                                     |
| `utils_web.py`              | Web-only helpers, non-secret logic              | No config/secret/key writes                                  |

---

## 6. Separation of Concerns Table

| Function                    | Responsible System         | Storage Location                                    | Runtime Access          |
|-----------------------------|---------------------------|----------------------------------------------------|------------------------|
| User credentials/auth       | Bot (backend only)         | `tbot_bot/core/databases/SYSTEM_USERS.db`, `tbot_bot/storage/keys/login.key` | Local only             |
| Broker API keys/secrets     | Bot (backend only)         | `tbot_bot/storage/secrets/broker_credentials.json.enc` + key                | Local only             |
| Entity/Jurisdiction/Identity| Bot (backend only)         | `tbot_bot/storage/secrets/bot_identity.json.enc`, `env.json.enc`            | Local only             |
| Config sync logs/audit      | Bot (backend only)         | Encrypted logs in `tbot_bot/storage/backups/`                              | Local only             |
| Fernet keys (all categories)| Bot (backend only)         | `tbot_bot/storage/keys/`                                                    | Local only             |

---

## 7. Security Considerations

- All credentials/config files are encrypted using Fernet keys per category, provisioned only via backend (`key_manager.py`) on UI trigger.
- All config import/export is local and authenticated—never via CLI/manual/script.
- No web endpoint or Flask code runs privileged actions, creates keys, or touches DB/OS state directly.
- All provisioning, bootstrap, and user registration actions are handled by backend scripts (`provisioning_runner.py`, `register_web.py`), never directly from UI.
- All events are logged (UTC, user, checksum, result). Plaintext/temporary artifacts are forbidden.
- Key lifecycle is managed with strict rotation; manual key file creation is forbidden.
- Decryption failures cause logged, user-safe fatal errors.

---

## 8. Compliance Summary (Lock)

- **Bootstrap:** All keys, credentials, and config are created by backend provisioning script, triggered by the Web UI config step.
- **Separation:** Flask/web UI never executes privileged or OS-level setup; all logic is split and secured.
- **Local only:** All secrets and keys are stored and used locally, always encrypted.
- **User Registration:** After initial provisioning, registration is enforced if no user exists in SYSTEM_USERS.db.
- **No CLI-based provisioning:** No key, credential, or config files may be created outside of the UI-triggered provisioning flow and backend runner.  
- **Audit:** All changes and events are audit-logged for compliance.

---

================================================================================
Encryption_and_Key_Management
{CURRENT_VERSION}
================================================================================

Overview:
Defines encryption, key management, and secure config handling for TradeBot v1.0+. All practices strictly enforce RIGD security and architecture standards as per `040_Directory_Structure_v041.txt` and all live compliance policies.

--------------------------------------------------------------------------------
Core Concepts
--------------------------------------------------------------------------------
- All sensitive files are encrypted at rest using AES-256 (Fernet, per category).
- Keys are always stored separately under `tbot_bot/storage/keys/`—never inside code, backups, or secrets.
- No plaintext credentials/configs exist in the repo or persistent storage post-bootstrap.
- All encrypted config files (`.env_bot.enc`, `.env.enc`, all `*.json.enc` for broker, identity, API, SMTP) and user credentials DB.
- Decryption occurs only at runtime, with decrypted values held in memory or ephemeral temp; any plaintext files are immediately overwritten or deleted.

--------------------------------------------------------------------------------
Key Management Policies
--------------------------------------------------------------------------------
- **Unique Fernet keys per category:** (`login.key`, `broker.key`, `env.key`, `env_bot.key`, `smtp.key`, etc.).
- **Key lifecycle is 100% Web UI controlled:**  
  - Key generation, validation, rotation are performed only via the configuration/provisioning workflow (`tbot_web/py/configuration_web.py`, `key_manager.py`, `security_users.py`).  
  - Manual or CLI-based key generation is strictly forbidden after bootstrap.
- **Rotation is atomic and logged:**  
  - Key rotations, re-provisioning, or recovery are performed from the Web UI only.  
  - All events are logged with UTC timestamp, user, affected category, and change context.
- **No key file is ever committed to VCS, backup, or exported:**  
  - .scpignore, .gitignore, and all backup/archiving scripts must enforce this.

--------------------------------------------------------------------------------
Encryption Workflows
--------------------------------------------------------------------------------
- Encrypt `.env_bot` and all config files exclusively using Web UI via helper modules; keys read from `storage/keys/`.
- `.env` may be optionally encrypted for ephemeral/prod cloud deployments.
- Decrypt only on runtime startup or configuration reload; any failure is fatal and blocks the process.
- Plaintext configs (if any) are ephemeral—held only in RAM or secure temp, then destroyed/overwritten after use.
- All encryption and decryption events are logged for audit review.

--------------------------------------------------------------------------------
Secure Backup & Recovery
--------------------------------------------------------------------------------
- All backup artifacts are encrypted and stored under `tbot_bot/storage/backups/`.
- Restore includes validation of both key and config file; successful restoration must re-encrypt using current keys.
- Loss or compromise of any key triggers immediate forced key rotation via the Web UI, and all affected configs must be re-encrypted.
- All recovery and restore events are audit logged (timestamp, user, affected category).

--------------------------------------------------------------------------------
Compliance and Best Practices
--------------------------------------------------------------------------------
- Minimal, role-based key access only; secrets and keys never shared or exposed.
- All key transmission, storage, and recovery is via secure, authenticated channels and Web UI workflow.
- All encryption/decryption and key-related operations are logged for full forensic traceability.
- .scpignore and .gitignore must exclude all decrypted secrets and key files; plaintext is ephemeral only.
- All encrypted config is validated at every startup; decryption failure is fatal and logs forensic event.
- Penetration testing and security review are periodic and enforced as part of CI/CD.

--------------------------------------------------------------------------------
Functional Requirements
--------------------------------------------------------------------------------
- All provisioning, credential creation, key management, and encryption occurs **exclusively** via the TradeBot Web UI configuration step.  
- No external tool, CLI, script, or manual operator may create, rotate, or inject any Fernet key, config, or secret after bootstrap.
- All encryption helpers (`key_manager.py`, `config_encryption.py`, `security_users.py`) must enforce this policy and reject any unauthorized usage.
- All key and config storage paths, naming, and lifecycle strictly follow the structure defined in `040_Directory_Structure_v042.txt`.

--------------------------------------------------------------------------------
bot_state.txt State Management 
--------------------------------------------------------------------------------
- `tbot_bot/control/bot_state.txt` holds the authoritative session state string for both the runtime and UI routing.
- Valid states:  
  `initialize`, `provisioning`, `bootstrapping`, `idle`, `analyzing`, `trading`, `monitoring`, `updating`, `shutdown`, `graceful_closing_positions`, `emergency_closing_positions`, `shutdown_triggered`, `error`
- UI routing is driven by `bot_state.txt` as follows:
    - `initialize`, `provisioning`, `bootstrapping`: show configuration UI (`configuration.html`)
    - `idle`, `trading`, `monitoring`, `analyzing`, `updating`: show main dashboard UI (`main.html`)
    - `shutdown`, `graceful_closing_positions`, `emergency_closing_positions`, `shutdown_triggered`, `error`: show error state/page and halt further operations
- The state machine is cross-referenced and enforced per `090_Runtime_and_Lifecycle_v041.txt` and `110_Web_Interface_and_Dashboard_v041.txt`.


--------------------------------------------------------------------------------
Summary
--------------------------------------------------------------------------------
- Encryption and key management is centralized, automated, and strictly audited via the TradeBot Web UI.  
- No manual key or credential handling is permitted.  
- All failures or policy violations trigger fatal errors and are recorded for compliance review.
- The bot state machine (`bot_state.txt`) governs runtime session transitions, UI routing, and error states, and must always be kept in sync with session events for full compliance.




