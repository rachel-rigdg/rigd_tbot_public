================================================================================
Document: 060
Accounting_Integration
Version: v048
Date: UTC:2025-08-23 00:00:00
================================================================================

This module mandates alignment of TradeBot with the internal, OFX-compliant accounting and ledger structure. *No external or shared ledger/accounting system may alter, inject, or provision data into the bot’s runtime, ledger, or COA files. All accounting integration is local, explicit, and compliance-locked.*

Contents:
- TBOT LEDGER INTEGRATION: ARCHITECTURE & COMPLIANCE
- Chart of Accounts — Single-Broker TBot Architecture
- Atomic Key/Secret Rotation Compliance

Ledger integrity, OFX compliance, UTC timestamps, path resolution via `tbot_bot/support/path_resolver.py`, and append-only audit traceability are enforced at every stage.

{BOT_IDENTITY} = {ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}

=============================================================================================================================================
TBOT LEDGER INTEGRATION: ARCHITECTURE & COMPLIANCE
=============================================================================================================================================

**Purpose:**  
Defines all rules for TradeBot accounting integration, ledger outputs, and compliance traceability. All logic is strictly local, never driven by an external accounting system or tool.

**Scope:**  
These rules apply to:
- All live or test-mode tbot trading
- All float/cash movement, profit/loss logging, reconciliation, and reporting
- All file paths resolved **only** through `path_resolver.py` (no direct/relative literals)

----------------------------------------------------------------------  
CORE INTEGRATION RULES  
----------------------------------------------------------------------

1. **LEDGER ISOLATION & FILENAME STRUCTURE**
   - All bot trading/actions write *only* to that bot's assigned ledger:  
     - `output/{BOT_IDENTITY}/ledgers/{ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_ledger.db`
   - No cross-bot/entity writes; no shared ledgers. Path is obtained from `path_resolver.py`.

2. **MULTI-CURRENCY AND ENTITY METADATA**
   - Each ledger entry includes explicit `currency_code`, `entity_code`, `jurisdiction_code`, `broker_code`, and `bot_id` fields.
   - Multi-currency and multi-entity compliance is always enabled, regardless of single-broker use.

3. **OFX-ALIGNED ENTRY & EXPORT (REQUIRED FIELDS)**
   - Every ledger entry is OFX-aligned and includes **`TRNTYPE`**, **`DTPOSTED`** (UTC), and **`FITID`**.  
   - `DTPOSTED` is persisted as UTC ISO-8601 (`YYYY-MM-DDTHH:MM:SSZ`).  
   - `FITID` is globally unique per economic event and must be stable/idempotent.

4. **DOUBLE-ENTRY ENFORCEMENT (SUM=0)**
   - All postings are **double-entry**: each economic event yields at least two splits whose signed amounts **sum to 0**.  
   - Posting is atomic; failure rolls back the entire batch. Single-entry writes are prohibited.

5. **AUDIT LOGGING**
   - All ledger-related logic is implemented in `tbot_bot/accounting/ledger_modules/` and imported in main modules.
   - Manual edits, resolutions, or corrections are recorded as new audit events in an **append-only** trail.

6. **STRICT SYSTEM INDEPENDENCE**
   - No runtime or test logic may query, ingest, or update external accounting systems or ledgers.
   - All trade/test actions are local to the bot’s ledgers and logs.

7. **ATOMIC KEY/SECRET ROTATION**
   - All Fernet keys and corresponding encrypted secrets used for accounting, ledger, and export modules are automatically regenerated and re-encrypted atomically whenever any config, credential, or sensitive secret is modified or a user is created/modified.  
   - Key/secret rotation does not require manual steps; all affected files are backed up before any overwrite and no old key or secret is reused.

8. **COA GOVERNANCE VIA WEB UI**
   - The bot’s COA is managed **exclusively** via the Web UI (`tbot_web/py/coa_web.py`) using `tbot_web/support/utils_coa_web.py`; ledger/schema helpers reside in `tbot_bot/accounting/coa_utils.py`. No CLI utilities may alter COA.

9. **UTC & IMMUTABILITY**
   - All timestamps persisted to ledgers/audit are UTC. Audit logs are append-only; edits are recorded as new events referencing prior entries.

10. **NO DIRECT SQL OUTSIDE `ledger_modules`**
    - All reads/writes occur through the modular API in `tbot_bot/accounting/ledger_modules/*`. Any direct SQL in web, broker, or strategy code is prohibited.

----------------------------------------------------------------------  
CANONICAL SCHEMAS & REQUIRED FIELDS (Authoritative)  
----------------------------------------------------------------------

+**Terminology note (accounts):**  
The TRADES table uses `account` (human-readable COA code), while LEDGER_ENTRIES uses `account_code`.  
Both MUST resolve via the active `coa_mapping_table.json`; posting is blocked if unresolved.

All accounting table columns are defined in code at:
`tbot_bot/accounting/ledger_modules/ledger_fields.py`.

**Rule:** All writers/readers MUST import and use these lists verbatim to prevent schema drift.  
**Order matters** wherever noted.

Identity note: the DB column is `bot_id` (lowercase) and its value equals `{BOT_IDENTITY}`.

**OFX Field Aliases & Canonicalization:**  
- `DTPOSTED` (UTC) is the canonical timestamp. Implementation may also store `datetime_utc` as an alias, but **`DTPOSTED` must exist**.  
- `TRNTYPE` is required for each split (e.g., `BUY`, `SELL`, `DIV`, `FEE`, `XFER`).  
- `FITID` is required and **UNIQUE** across the database.

### A) TRADES table (order-sensitive; matches SQLite schema excluding autoincrement `id`)
TRADES_FIELDS = [
    "FITID",
    "DTPOSTED",
    "TRNTYPE",
    "ledger_entry_id",
    "datetime_utc",
    "symbol",
    "symbol_full",
    "action",
    "quantity",
    "quantity_type",
    "price",
    "total_value",
    "amount",
    "side",
    "commission",
    "fee",
    "broker_code",
    "account",
    "trade_id",
    "group_id",
    "strategy",
    "tags",
    "notes",
    "jurisdiction_code",
    "entity_code",
    "language",
    "created_by",
    "updated_by",
    "approved_by",
    "approval_status",
    "status",
    "created_at",
    "updated_at",
    "gdpr_compliant",
    "ccpa_compliant",
    "pipeda_compliant",
    "hipaa_sensitive",
    "iso27001_tag",
    "soc2_type",
    "currency_code",
    "language_code",
    "price_currency",
    "fx_rate",
    "commission_currency",
    "fee_currency",
    "accrued_interest",
    "accrued_interest_currency",
    "tax",
    "tax_currency",
    "net_amount",
    "settlement_date",
    "trade_date",
    "description",
    "counterparty",
    "sub_account",
    "extra_fields",
    "json_metadata",
    "raw_broker_json",
    "response_hash",
    "sync_run_id",
    "bot_id"
]

**Minimum non-null fields on INSERT (trades):**  
`FITID`, `DTPOSTED`, `TRNTYPE`, `symbol`, `action` (in ALLOWED_TRADE_ACTIONS), `quantity`, `price` (when applicable),  
`broker_code`, `account` (valid COA), `trade_id` (stable), `jurisdiction_code`, `entity_code`, `currency_code`, `bot_id`.

### B) LEDGER_ENTRIES table (double-entry split records)
LEDGER_ENTRIES_FIELDS = [
    "FITID", "DTPOSTED", "TRNTYPE",
    "entry_type", "symbol", "symbol_full", "isin", "cusip", "sedol", "figi",
    "action", "trade_id",
    "broker_code", "account_code", "account_id", "sub_account",
    "quantity", "quantity_type", "price", "price_currency",
    "amount", "total_value", "currency_code", "fx_rate",
    "commission", "commission_currency", "fee", "fee_currency",
    "accrued_interest", "accrued_interest_currency",
    "tax", "tax_currency", "net_amount",
    "settlement_date", "trade_date", "description", "counterparty",
    "strategy", "tags", "notes",
    "jurisdiction_code", "entity_code", "language_code",
    "created_by", "updated_by", "approved_by", "approval_status",
    "created_at", "updated_at",
    "gdpr_compliant", "ccpa_compliant", "pipeda_compliant", "hipaa_sensitive", "iso27001_tag", "soc2_type",
    "extra_fields", "json_metadata", "raw_broker_json",
    "group_id", "response_hash", "sync_run_id",
    "bot_id"
]

**Minimum non-null fields on INSERT (ledger_entries):**  
`FITID`, `DTPOSTED` (UTC), `TRNTYPE`, `entry_type`, `action`, `account_code` (COA-resolved), `currency_code`,  
and either `total_value` or (`amount` + `fx_rate`), plus `jurisdiction_code`, `entity_code`, `broker_code`, `bot_id`.  
**Constraint:** double-entry batch per event must sum to zero; enforced in `ledger_double_entry.py`.

### C) RECONCILIATION_LOG table
RECONCILIATION_LOG_FIELDS = [
    "id", "trade_id", "entity_code", "jurisdiction_code", "broker_code", "broker",
    "error_code", "account_id", "statement_date",
    "ledger_balance", "ledger_entry_id", "broker_balance", "delta",
    "status", "resolution", "resolved_by", "resolved_at",
    "raw_record", "notes", "recon_type", "raw_record_json",
    "compare_fields", "json_metadata",
    "timestamp_utc", "sync_run_id", "api_hash", "mapping_version",
    "imported_at", "updated_at", "user_action"
]

**Status values:** `ok`, `mismatch`, `local-only`, `broker-only`, `resolved`.

### Allowed trade actions (normalized)
ALLOWED_TRADE_ACTIONS = [
    "long", "short", "put", "inverse", "call", "assignment", "exercise", "expire", "reorg", "other"
]

**Validation rules (applies to all writers):**  
- Any broker verb outside ALLOWED_TRADE_ACTIONS must be normalized or mapped to `"other"` with the original preserved in `json_metadata`.  
- `DTPOSTED` MUST be UTC ISO-8601 with a `Z` suffix, e.g. `2025-08-23T14:32:10.123Z`.  
- `account`/`account_code` must resolve via the active `coa_mapping_table.json`; **unmapped ⇒ skip_insert** (record flagged for mapping).  
- Store `raw_broker_json` and cryptographic `response_hash` for provenance.  
- Producers/consumers must import `ledger_fields.py` (no ad-hoc column lists).

**Enumerations (required):**
- `approval_status`: `pending` | `approved` | `rejected`  
- `trades.status`: `filled` | `partial` | `cancelled` | `expired` | `rejected` | `pending`

----------------------------------------------------------------------  
ENFORCEMENT & SYSTEM CONSTRAINTS  
----------------------------------------------------------------------

- *All CSV/JSON exports are external artifacts, never re-ingested by the bot.*
- Only validated, double-entry-compliant data is written to ledgers after each strategy session, sync, or holdings operation.
- If the ledger fails schema or double-entry validation, all exports and downstream reporting are blocked until resolved.
- All compliance, schema, and field requirements are enforced by:
  - `tbot_bot/accounting/accounting_config.py`                         # Output folder structure, schema/COA existence, config validation, environment checks
  - `tbot_bot/accounting/coa_utils.py`                                 # COA metadata structure, COA db helpers, import/export, UI-driven editing
  - `tbot_bot/accounting/ledger_modules/ledger_account_map.py`         # Logical account path lookups and mapping for all posting ops
  - `tbot_bot/accounting/ledger_modules/ledger_compliance_filter.py`   # Transaction validation pre-write; enforces compliance for all ledger entries
  - `tbot_bot/accounting/ledger_modules/ledger_deduplication.py`       # Idempotency keys: **FITID** + content hash; duplicate prevention/metrics
  - `tbot_bot/accounting/ledger_modules/ledger_double_entry.py`        # Double-entry posting, debit/credit logic, **sum==0** validation, atomic batches
  - `tbot_bot/accounting/ledger_modules/ledger_edit.py`                # Editing, updating, resolving, or deleting ledger entries (audit-logged)
  - `tbot_bot/accounting/ledger_modules/ledger_entry.py`               # Entry structure/normalization helpers (no direct writes)
  - `tbot_bot/accounting/ledger_modules/ledger_grouping.py`            # Grouping/rollup logic for UI, reconciliation, and reporting
  - `tbot_bot/accounting/ledger_modules/ledger_snapshot.py`            # **Snapshots**: atomic ledger backup before sync/update/destructive ops
  - `tbot_bot/accounting/ledger_modules/ledger_sync.py`                # Orchestrates broker sync, mapping, compliance, dedupe, double-entry, audit, reconciliation
  - `tbot_bot/accounting/reconciliation_log.py`                        # Reconciliation table I/O; status tracking; audit and querying
  - Reporting/export modules (e.g., `tbot_bot/reporting/ledger_report.py`) for downstream integration
- **All paths are obtained via `path_resolver.py`.**  
- **No direct SQL outside `ledger_modules`.**

**Schema & Indices (enforced by `ledger_db.py` / schema SQL):**  
- Tables include at minimum: `ledger_entries`, `trades`, `audit_trail`, `reconciliation_log`, `trade_group_collapsed`.  
- Indices include: `UNIQUE(FITID)` on `ledger_entries` (and on `trades` when present), lookups on `DTPOSTED`, `group_id`, `trade_id`, `account_code`.  
- Foreign/key references are logical (by IDs/keys) due to SQLite constraints; integrity enforced in module code.

**Note:** Inverse ETF, leveraged, or synthetic short trades are recorded to standard accounts; type/leverage tracked via `tags` and (if used) `leverage_multiplier` in `json_metadata`, plus the broker payload `response_hash`.

----------------------------------------------------------------------  
COMPLIANCE FILTER RULES (PRE-WRITE)  
----------------------------------------------------------------------

Minimum checks applied by `ledger_compliance_filter.py` before any write:
- Required non-null: `FITID`, `DTPOSTED` (UTC), `TRNTYPE`, `account_code`, `currency_code`, and economic amounts.  
- Date bounds: `DTPOSTED` not in the future; not before allowable import start date (if configured).  
- Numeric ranges: quantities/prices within sane bounds; Decimal coercion with scale checks.  
- Action/verb normalization: `action` in ALLOWED_TRADE_ACTIONS.  
- Mapping present: `account_code` resolvable via active `coa_mapping_table.json` (else **skip_insert** + flag).  
- Idempotency: reject if `FITID` already exists (dedupe).  
- Any violation ⇒ record is rejected/flagged; nothing is written for that record.

----------------------------------------------------------------------  
RISKS IF IGNORED  
----------------------------------------------------------------------

- Ledger corruption or unbalanced entries
- Cross-entity or cross-bot capital misallocation
- Audit and regulatory noncompliance (OFX, IRS, SEC)
- Broken reconciliation or tax/filing output
- Inability to distinguish live/test activity

=============================================================================================================================================
Chart of Accounts – Single-Broker TBot Architecture
=============================================================================================================================================

*Every bot instance writes to a local, OFX-compliant ledger file:*  
`output/{BOT_IDENTITY}/ledgers/{ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_ledger.db` (resolved via `path_resolver.py`)

----------------------------------------------------------------------------------------------------------------------------------------------
CHART OF ACCOUNTS: {ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_COA_v1.0.0.db 
----------------------------------------------------------------------------------------------------------------------------------------------

# -- COA Metadata (Required in all ledgers and COA files) --
COA_METADATA:
    currency_code: "USD"
    entity_code: "{ENTITY_CODE}"
    jurisdiction_code: "{JURISDICTION_CODE}"
    coa_version: "v1.0.0"
    created_at_utc: "<UTC_TIMESTAMP>"
    last_updated_utc: "<UTC_TIMESTAMP>"

# -- Account Structure (core nodes + holdings/tax/payroll/allocations) --

1000 Bank and Cash Accounts [Cash & Equivalents]
├── 1010 Float Injection – From RIGD Group
├── 1020 Float Returned – To RIGD Group
├── 1030 Alpaca – Cash
├── 1040 IBKR – Cash
├── 1050 Tradier – Cash
├── 1060 Robinhood – Cash

1100 Assets [Investing Activities]
├── 1110 Brokerage Accounts – Equities
│   ├── 1111 Alpaca – Equities
│   ├── 1112 IBKR – Equities
│   ├── 1113 Tradier – Equities
│   └── 1114 Robinhood – Equities
├── 1120 Tax Reserve (Brokerage)
├── 1130 Payroll Reserve (Brokerage)

2000 Liabilities [Operating Activities]
├── 2010 Broker Payables (Accrued Fees)
├── 2020 Market Data Payables (Accrued Subscriptions)

3000 Equity [Financing Activities]
├── 3010 Capital Float Ledger
├── 3020 Daily Float Allocation History
├── 3030 Opening Balance
├── 3040 Accumulated Profit

4000 Income [Operating Activities]
├── 4010 Realized Gains – Alpaca
├── 4020 Realized Gains – IBKR
├── 4030 Realized Gains – Tradier
├── 4040 Realized Gains – Robinhood
├── 4050 Qualified Dividends
├── 4060 Short-Term Capital Gains
├── 4070 Long-Term Capital Gains
├── 4080 Holdings Allocation Rebalancing Gain/Loss
├── 4090 Float/Tax/Payroll Reserve Transfers

5000 Expenses [Operating Activities]
├── 5010 Broker Fees – Alpaca
├── 5020 Broker Fees – IBKR
├── 5030 Broker Fees – Tradier
├── 5040 Broker Fees – Robinhood
├── 5050 Slippage / Execution Losses
├── 5060 API Timeout Penalties
├── 5070 Bot Infrastructure Costs
├── 5080 Tax Payments (Realized/Withheld)
├── 5090 Payroll Disbursements (Owner/Operator)

9100 Exports [Control & Reporting]
├── 9110 Daily P&L Export – Manager.io Format
├── 9120 CSV/JSON Trade Log Export
├── 9130 SQLite Ledger Backup
├── 9140 Broker Confirm Archive (PDFs)
├── 9150 End-of-Day Snapshot (Holdings + Cash)
├── 9160 Holdings Rebalance Audit Log Export

9200 Logging / Execution References [Control]
├── 9210 Trade UUID
├── 9220 Broker Confirm #
├── 9230 Strategy Tag
├── 9240 Source Method Tag
├── 9250 EOD Synced Flag
├── 9260 Reconciliation Passed Flag

9300 System Integrity [Control]
├── 9310 Failures & Rejected Orders
├── 9320 Manual Overrides
├── 9330 Ledger Lock Flag (YES/NO)
├── 9340 Ledger Status: ACTIVE / DECOMMISSIONED
├── 9350 Final Entry Timestamp
└── 9360 Debug / Strategy Tags


------------------------------------------------------------------------------------------
COA Metadata & Versioning Notes
------------------------------------------------------------------------------------------

- All COA files must include at minimum:  
  - `currency_code`, `entity_code`, `jurisdiction_code`, `coa_version`, `created_at_utc`, `last_updated_utc`
- Schema migration = versioned filename:  
  `{ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_COA_v1.0.0.db`
- COA metadata is stored in `coa_metadata` table (same fields as above).
- All ledgers and COA files must be ready for multi-entity/currency expansion.
- **Dynamic COA mapping assignments are stored in `coa_mapping_table.json` (in `output/{BOT_IDENTITY}/ledgers/`)**.  
  - This file is **lazy-created on first access**, and **versioned** on each change; every version is exportable for audit.  
  - Snapshots enable rollback and compliance traceability for all mapping rules.  
  - **Unmapped/ambiguous transactions are `skip_insert` and queued for admin assignment via Web UI.**

------------------------------------------------------------------------------------------
Export Constraints and Enforcement
------------------------------------------------------------------------------------------

- Only validated, reconciled trades are written to ledgers after session/sync.
- If ledger fails schema or double-entry check, export is blocked.
- `.csv`/`.json` are for external audit only, never parsed for ingestion.
- All structure, compliance, and export logic is enforced by local accounting modules.
- **COA mapping table (`coa_mapping_table.json`) is considered part of the COA: any change is audit-logged, versioned, and tied to a specific schema version.**
- **COA creation/edit/export is UI-only** (via `utils_coa_web.py`); ledger/schema integration via `tbot_bot/accounting/coa_utils.py`.
- Schema conformance: all exporters/importers must import `tbot_bot/accounting/ledger_modules/ledger_fields.py` to guarantee column order and presence; ad-hoc column lists are prohibited.

**Note:** Inverse ETF, leveraged, or synthetic trades are recorded as normal, with tags. No special COA accounts are required; leverage and synthetic details are tracked in `tags` and `json_metadata`.

=============================================================================================================================================
Automated Holdings, Float, and Reserve Management – Accounting Integration
=============================================================================================================================================

**Purpose:**  
Formalizes how all automated holdings, float, tax reserve, payroll reserve, and allocation/rebalancing activities are integrated into the bot's ledger, using the expanded COA.

----------------------------------------------------------------------
Automated Holdings/Reserves – Core Flows & Ledger Entry Points
----------------------------------------------------------------------

1. **Float Management**  
   - All float injections/returns, and any cash-top up actions, are journaled under:
     - *Bank and Cash Accounts*: 1000 series (e.g., 1030–1060)
     - *Float Injection/Return*: 1010, 1020
     - *Equity Float Ledger*: 3010, 3020
   - Float adjustment and reconciliation events must be double-entry, tagged by trigger (bot, operator, auto-rebalance).
   - **When float is restored by selling securities, any realized gain triggers a tax reserve allocation per tax reserve %, posted as below. No payroll allocation is ever triggered by float sales. Losses do not generate tax or payroll allocations.**
   - **All float management actions are posted with audit trail: user, UTC timestamp, trigger, before/after values. Allocated reserves are immutable except by explicit, audited manual override.**
   - **All float-related postings must resolve to a COA category via `coa_mapping_table.json`; any unmapped transaction is blocked (`skip_insert`) until assigned in the Web UI.**

2. **Tax Reserve**  
   - On each profit realization (bot trade or holdings sale), tax reserve allocation is split from realized gain and posted as:
     - *Assets*: 1120 (Tax Reserve)
     - *Income*: 4090 (Float/Tax/Payroll Reserve Transfers)
     - *Expense*: 5080 (Tax Payments), when cash outflow occurs
   - All splits, transfers, and payments to tax are logged per event.
   - **Once posted, tax reserves cannot be reduced or re-used for trading, float, or other flows except by explicit manual override, which is always audit-logged. No reserve is set aside for losses.**
   - **All allocations and transfers are recorded against the mapping table version active at posting; each change to tax reserve mapping snapshots `coa_mapping_table.json`.**

3. **Payroll Reserve**  
   - After tax, payroll split is posted to:
     - *Assets*: 1130 (Payroll Reserve)
     - *Income*: 4090 (Float/Tax/Payroll Reserve Transfers)
     - *Expense*: 5090 (Payroll Disbursements), when cash outflow occurs
   - Allocations logged as internal transfer at split, and as expense at disbursement.
   - **Payroll allocation only occurs on positive post-tax gains from bot trading activities, never from float sales or realized losses. Payroll reserves, once posted, are never clawed back or reused for other flows.**
   - **All payroll reserve flows are audit-linked to the mapping table snapshot in force at posting time.**

4. **Holdings Allocation/Rebalancing**  
   - Every purchase/sale of long-term securities, as well as periodic/manual rebalance, is posted to:
     - *Assets*: 1100 series (per-broker equities)
     - *Income*: 4080 (Holdings Allocation Rebalancing Gain/Loss)
     - *Exports*: 9160 (Holdings Rebalance Audit Log Export, for reporting/audit only)
   - Audit log must include action context, symbols, allocation %, cash amounts, and resulting value.
   - Unrealized and realized P/L must be reconciled to Income or Asset accounts as required.
   - **Every allocation and rebalance event must be logged to both the ledger and immutable audit trail with complete context, compliance, and rationale.**
   - **All holdings allocations and rebalance postings must resolve through `coa_mapping_table.json`; each new assignment or change is versioned, audit-logged, and rollback-capable.**

5. **General Enforcement**
   - All above entries are double-entry compliant and OFX-aligned.
   - Each automated or manual action (split, transfer, rebalance) must reference `FITID`, `DTPOSTED` (UTC), context/audit tag, and source trigger.
   - No action may be posted outside of scheduled flows, manual UI action, or validated trigger.
   - **All config or allocation changes must trigger a backup of prior config/secrets, and generate an audit entry including user, UTC timestamp, and rationale.**
   - **The active `coa_mapping_table.json` version is bound to every posting event; all edits or rule changes snapshot the table, ensuring holdings/float/reserve postings are permanently tied to a mapping version for compliance review.**

----------------------------------------------------------------------
COA Accounts Used by Holdings Management
----------------------------------------------------------------------

- **Assets:**  
    - 111x: Equities (per broker)
    - 1120: Tax Reserve (Brokerage)
    - 1130: Payroll Reserve (Brokerage)
- **Income:**  
    - 4080: Holdings Allocation Rebalancing Gain/Loss
    - 4090: Float/Tax/Payroll Reserve Transfers
- **Expenses:**  
    - 5080: Tax Payments (Realized/Withheld)
    - 5090: Payroll Disbursements (Owner/Operator)
- **Exports:**  
    - 9160: Holdings Rebalance Audit Log Export

All flows, splits, and rebalancing actions must utilize these accounts, with strict double-entry, append-only audit, and **mapping resolution enforced via `coa_mapping_table.json` with full versioning and rollback.**


=================================================================================================================
Bot–Accounting System Handshake & External Transfer Protocol
=================================================================================================================

**Purpose:**  
Defines the mandatory process for all physical cash movement between the TradeBot brokerage account and the LLC/operating account, including tax reserve and payroll siphoning, capital contributions, and any required reconciliation.  
This protocol *formally prohibits* any direct access, merging, or write-back between bot-side ledgers and the accounting system. All transfers must follow this handshake to ensure strict audit traceability and prevent double-booking or reconciliation loss.

---------------------------------------------------------------------------------------------------------------
I. Overview
---------------------------------------------------------------------------------------------------------------
The handshake protocol is the only permitted mechanism for initiating, proposing, and completing any movement of cash or allocation (float, tax, payroll, capital contribution) between the bot (broker) and the external accounting system.  
All actions are logged, time-stamped (UTC), and must be double-entry compliant in both the bot’s ledger and the accounting system.  
At no point does either system overwrite, merge, or directly write to the other’s ledger.  
All proposals and acknowledgments are append-only, with permanent audit logs.  
No exceptions, operator overrides, or emergency actions may bypass this protocol for any cash, reserve, or capital movement between the bot and any external system.

---------------------------------------------------------------------------------------------------------------
II. Core Handshake Workflow
---------------------------------------------------------------------------------------------------------------

1. **Proposal Generation (by Bot)**
    - When the bot determines that funds must be transferred (e.g., tax reserve siphoning, payroll transfer, float injection/return, capital contribution), it creates a *transfer proposal* entry, appends it to its outbound transfer queue, and writes a corresponding “pending” record in its ledger and audit log.
    - The proposal includes:
        - Unique proposal ID (UUID)
        - Action type (tax_reserve_transfer, payroll_transfer, float_injection, capital_contribution, etc.)
        - Amount (currency, value)
        - Source account (bot-side)
        - Destination account (LLC/operating or external)
        - Required chart-of-accounts mapping (bot and accounting)
        - Proposed date/time (UTC, ISO8601)
        - Reference to triggering audit/log event
        - Required double-entry splits (OFX/COA fields)
        - Current state (pending)
        - Full rationale/context (auto/manual, threshold, cycle, etc.)
        - User/trigger origin (system/operator)

2. **Export & Delivery**
    - The transfer proposal is exported as a machine-readable file (JSON or CSV, as specified), or written to a designated export folder:  
      `output/{BOT_IDENTITY}/transfers/` (resolved via `path_resolver.py`).
    - The accounting system is responsible for polling or reading these proposals at defined intervals (e.g., nightly).

3. **Accounting System Review & Execution**
    - The accounting system ingests all *pending* proposals, verifies compliance (COA mapping, amounts, rationale, available funds, regulatory and tax logic), and—if approved—initiates the actual cash transfer via the designated bank/brokerage interface.
    - No transfer is considered complete until acknowledged by the accounting system.
    - If the proposal cannot be executed, the accounting system appends a “rejected” acknowledgment, with reason, to the bot's audit trail (never deletes the original proposal).

4. **Acknowledgment (by Accounting)**
    - Upon successful transfer, the accounting system writes an *acknowledgment record* into the bot’s inbound queue:  
      `output/{BOT_IDENTITY}/transfers_ack/` (resolved via `path_resolver.py`), referencing the proposal ID.
    - This acknowledgment includes:
        - Proposal ID (must match bot’s original)
        - Execution status (completed, rejected, needs_correction)
        - Execution timestamp (UTC, ISO8601)
        - Any deviations (e.g., partial fill, fee adjustment)
        - Unique accounting system reference (for audit link)
        - Optional signed hash/confirmation (for tamper-proofing)
        - Operator/trigger ID (if manual)
        - Comments or correction instructions (if needed)

5. **Final Reconciliation (by Bot)**
    - The bot ingests the acknowledgment file and matches it to the pending proposal.
    - If “completed”: bot updates its ledger entry from “pending” to “executed”, links to the accounting system reference, and closes the audit record.
    - If “rejected” or “needs_correction”: bot logs the result, marks the proposal as failed/invalid, and requires manual operator review. No automatic resubmission is permitted—only an explicit new proposal can be created.

6. **Permanent Audit Trail**
    - All proposals, acknowledgments, and resulting ledger entries remain append-only and are never overwritten or deleted.
    - Every action is cross-referenced in the `logs/` table and the audit trail, with full timestamp, origin, and resulting status.
    - Each proposal/acknowledgment is cryptographically hashed for tamper-evidence.

---------------------------------------------------------------------------------------------------------------
III. Prohibited Actions and Enforcement
---------------------------------------------------------------------------------------------------------------

- No system may merge, sync, or import ledger data directly from the other’s database or files.
- No bot action may directly write to or reconcile the accounting system’s ledger; and vice versa.
- No proposal or acknowledgment may be deleted after creation—only appended.
- Any deviation, error, or manual correction must be audit-logged and traceable.

---------------------------------------------------------------------------------------------------------------
IV. Example Transfer Proposal (JSON)
---------------------------------------------------------------------------------------------------------------

{
  "proposal_id": "26f67c87-cd88-42fc-9b7e-ef38b5cf001e",
  "action_type": "tax_reserve_transfer",
  "amount": {"currency": "USD", "value": 2500.00},
  "source_account": "1030 Alpaca – Cash",
  "destination_account": "2000 RIGD Group LLC – Tax Reserve Bank",
  "coa_mapping": {
    "bot_ledger": ["1120 Tax Reserve (Brokerage)", "4090 Float/Tax/Payroll Reserve Transfers"],
    "accounting_ledger": ["1200 Tax Reserve", "4900 Transfers In"]
  },
  "proposed_datetime_utc": "2025-07-20T16:10:00Z",
  "audit_reference": "log_1792",
  "double_entry_splits": [
    {"account": "1030", "type": "credit", "amount": 2500.00},
    {"account": "1120", "type": "debit", "amount": 2500.00}
  ],
  "current_state": "pending",
  "rationale": "Quarterly tax reserve sweep per reserve allocation threshold.",
  "user_origin": "system"
}

---------------------------------------------------------------------------------------------------------------
V. Example Transfer Acknowledgment (JSON)
---------------------------------------------------------------------------------------------------------------

{
  "proposal_id": "26f67c87-cd88-42fc-9b7e-ef38b5cf001e",
  "status": "completed",
  "execution_datetime_utc": "2025-07-21T15:48:00Z",
  "accounting_reference": "acct_txn_9923",
  "operator_id": "user_admin",
  "comments": "Funds received, confirmed by bank transfer.",
  "hash": "ac2f98b7ab1f438e97b74e22d39e5c7a"
}

---------------------------------------------------------------------------------------------------------------
VI. Timing, Backup, and Error Handling
---------------------------------------------------------------------------------------------------------------

Bot exports proposals on event/interval (immediate for threshold actions, nightly for regular sweeps).

Accounting system imports proposals and returns acknowledgments at minimum daily intervals.

All exports are atomic (write to temp file, move/rename on completion) via `path_resolver.py` routes.

Both systems automatically back up export/import folders before purge/archive.

Any error, rejection, or missing acknowledgment blocks the next transfer of the same type and triggers an operator alert.

---------------------------------------------------------------------------------------------------------------
VII. Future-Proofing and Extensions
---------------------------------------------------------------------------------------------------------------

This protocol is mandatory for all external cash, tax, and payroll movements, even if new brokers, accounts, or legal entities are added.

Any future automation (e.g., direct bank APIs, Wise, Mercury) must still go through proposal/ack/ledger handshake, never direct merge.

Digital signature or secure messaging can be layered atop this protocol for higher trust and auditability.

---------------------------------------------------------------------------------------------------------------
VIII. Enforcement and Governance
---------------------------------------------------------------------------------------------------------------

The handshake protocol is required for regulatory audit, and any system or user bypassing this protocol will cause all subsequent exports and reconciliations to be marked noncompliant.

Enforcement is built into the export, ledger, and audit modules.

All supporting documentation (transfer logs, receipts, audit files) must be retained for a minimum of seven years or as required by law.

Any violation or bypass of this protocol (manual or automated) will be flagged as a compliance breach and subject to immediate investigation.



=================================================================================================================
Broker Ledger Sync and Reconciliation System Specification
=================================================================================================================

SCOPE: Applies to all broker adapters and the accounting/ledger subsystem.  
PURPOSE: To enable one-click, auditable, double-entry-compliant broker transaction import, sync, and reconciliation for all supported brokers (Alpaca, IBKR, etc), and to guarantee ledger integrity for tax/audit/compliance.

-------------------------------------------------------------------------------
1. BROKER SYNC: FUNCTIONAL OVERVIEW
-------------------------------------------------------------------------------
- *Objective:* 
  - Download all available trades/fills and cash transactions for the active bot broker account.
  - Normalize, validate, map, dedupe, and **double-entry post** each transaction into the bot ledger DB.
  - Mark/reconcile each matched trade; log and alert on all mismatches or missing entries.
  - Ensure **idempotency**: re-syncs do not create duplicates (**UNIQUE(FITID)**), and broker-side updates (cancels, corrections, reversals) are reflected.
  - **Every posting must resolve through the active `coa_mapping_table.json` version; unmapped ⇒ `skip_insert` and flagged for UI mapping.**

-------------------------------------------------------------------------------
2. SYSTEM COMPONENTS AND ROLES
-------------------------------------------------------------------------------
- **A. Broker Adapter (`broker_api` + plugins):**
    - Must implement:
      - `fetch_all_trades(start_date, end_date=None) -> List[dict]`
      - `fetch_cash_activity(start_date, end_date=None) -> List[dict]`
    - Each returned dict must include: stable IDs, symbol, action, quantity, price, fees, UTC timestamps, status, and raw payload for hashing.
    - Adapters handle pagination/rate limits with retry/backoff. All historical data for the window is fetched.
    - Each sync logs which API credential (or its hash) was used.

- **B. Sync Orchestrator (`tbot_bot/accounting/ledger_modules/ledger_sync.py`):**
    - Pipeline: **fetch → normalize → compliance → mapping → dedupe → double-entry post → audit → reconciliation**.  
    - Takes **snapshots** via `ledger_snapshot.py` before write operations.  
    - Writes audit events with `sync_run_id`, broker code, mapping version.

- **C. Reconciliation Engine (`tbot_bot/accounting/reconciliation_log.py`):**
    - For each broker record: mark `ok` if matched, `broker-only` if missing locally, `local-only` if in ledger but not in broker export.  
    - Required fields: `trade_id`, `status`, `compare_fields`, `sync_run_id`, `timestamp_utc`, `mapping_version`, `api_hash`.

- **D. COA Mapping Table (`tbot_bot/accounting/coa_mapping_table.py` + Web UI):**
    - **Lazy-created** `coa_mapping_table.json`; **versioned** on each edit.  
    - Unmapped/ambiguous ⇒ **skip_insert**; surfaced in UI for assignment.  
    - All changes audit-logged; export/import supported.

- **E. Log and Artifact Retention:**
    - All logs, audits, reconciliations, and mapping versions retained ≥7 years (or per law); archival to encrypted cold storage allowed (no destruction).

-------------------------------------------------------------------------------
3. TRANSACTION & FIELD MAPPING
-------------------------------------------------------------------------------
- **Alpaca (example):**
    - API: `GET /v2/orders`, `GET /v2/account/activities`
    - Map:
        - `order_id`/`id` → `trade_id`
        - `symbol` → `symbol`
        - `side` → `action` (`buy`→`long`, `sell`→`short`, else `other` with original in `json_metadata`)
        - `filled_qty` → `quantity`
        - `filled_avg_price` → `price`
        - `filled_at` → `DTPOSTED` (UTC) + store original in `json_metadata`
        - `commission`/`fees` → `commission`/`fee`
        - `status` → `status`
    - Cash activity (deposits, withdrawals, dividends, fees) mapped to proper `TRNTYPE` and COA accounts via mapping table.

- **Fees Handling:** store detailed breakdown in `json_metadata` where available.

- **Partial Fills & Corrections:** aggregate by broker semantics; maintain parent linkage in metadata; updates create audit events.

- **Field Requirements (canonical):**
    - Use `ledger_fields.py` lists (`TRADES_FIELDS`, `LEDGER_ENTRIES_FIELDS`, `RECONCILIATION_LOG_FIELDS`).  
    - `action` in ALLOWED_TRADE_ACTIONS; nonconforming verbs → `"other"` with original preserved.  
    - Store `raw_broker_json` and its `response_hash`.  
    - Missing COA mapping blocks posting (`skip_insert`) and is tied to active mapping version.

-------------------------------------------------------------------------------
4. SYNC WORKFLOW (PSEUDOCODE)
-------------------------------------------------------------------------------

def sync_broker_ledger(start_utc=None, end_utc=None):
    broker = get_active_broker()
    window = resolve_sync_window(start_utc, end_utc)
    # Fetch
    trades = broker.fetch_all_trades(window.start, window.end)
    cash   = broker.fetch_cash_activity(window.start, window.end)
    raw    = trades + cash

    # Snapshot
    take_ledger_snapshot(sync_run_id)

    # Normalize → Compliance → Mapping → Dedup → Double-Entry
    normalized = [normalize(record) for record in raw]
    valid, rejects = compliance_filter(normalized)
    mapped = map_accounts(valid)             # uses coa_mapping_table.json (lazy-created, versioned)
    dedupd = deduplicate(mapped)             # FITID + content-hash; UNIQUE(FITID) enforced
    post_double_entry(dedupd, sync_run_id)   # atomic batch; sum==0 invariant

    # Audit + Reconcile
    write_audit_events(sync_run_id, counts=...)
    reconcile_and_log(window, raw, sync_run_id, mapping_version)

    return sync_summary(counts=..., rejects=rejects)

-------------------------------------------------------------------------------
5. ERROR HANDLING AND AUDITABILITY
-------------------------------------------------------------------------------
- Full audit of every import/update; retries on API failures with backoff; errors logged with status.
- Discrepancies surfaced in UI; admin resolution required for `local-only`/`broker-only`.
- Each sync/record logs credential hash, `sync_run_id`, mapping version, and `response_hash`.
- Duplicates blocked by `UNIQUE(FITID)`; attempts are counted and reported.
- Unmapped transactions are **skip_insert** and shown in mapping UI; no partial writes.

-------------------------------------------------------------------------------
6. WEB UI REQUIREMENTS
-------------------------------------------------------------------------------
- Ledger Page (ledger.html):
    - "Sync Broker Ledger" triggers `/ledger/sync` (POST) → `ledger_sync.py`.
    - Post-sync: show new/updated trades; statuses `ok`, `mismatch`, `local-only`, `broker-only`, `resolved`.
    - Reconciliation log query/export; mapping UI with version history/rollback.
    - Every mapping change snapshots `coa_mapping_table.json` and ties to reconciliation/postings.
    - Pending/incomplete broker transactions indicated with follow-up flow.

-------------------------------------------------------------------------------
7. IDENTITY & SECURITY
-------------------------------------------------------------------------------
- Sync requires completed provisioning, identity validation, and admin RBAC.
- API key/credential usage logged on each sync.

-------------------------------------------------------------------------------
8. EXTENSIBILITY
-------------------------------------------------------------------------------
- New broker plugins conform to fetch/normalize contracts; unknown fields go to `json_metadata`.
- Mapping table supports live extension/versioning/export/import.
- Tests include mock/fuzzed broker data and mapping regressions.

-------------------------------------------------------------------------------
9. TESTING & COMPLIANCE
-------------------------------------------------------------------------------
- Verify: all broker trades present after sync; no duplicate `FITID`; ledger double-entry invariant holds; discrepancies auditable.
- Test: pagination/rate-limit handling; partial fills/corrections; reconciliation schema/population; mapping versioning; artifact retention.

-------------------------------------------------------------------------------
10. VERSIONING AND DATA RETENTION
-------------------------------------------------------------------------------
- All artifacts/logs/mapping tables/reconciliation logs versioned with schema/export version; retained ≥ 7 years.  
- Encrypted archival allowed; destruction requires explicit regulatory clearance.  
- Version metadata embedded in filenames and contents; covered by regression tests.

=============================================================================================================================================
Atomic Key/Secret Rotation Compliance
=============================================================================================================================================
- All Fernet keys and encrypted secrets (config, credentials, ledger/COA, holdings) rotate **atomically** whenever any sensitive change occurs (including user CRUD).  
- Rotation re-encrypts affected files, writes timestamped encrypted backups, and updates version metadata.  
- Old keys/secrets are never reused.  
- All rotations are append-only audit-logged with UTC timestamp, category, initiator (user/system), and affected artifacts (sanitized).
