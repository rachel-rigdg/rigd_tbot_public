=================================================================================
Document: 070
Runtime_Lifecycle_Logging_Reporting_and_Testing
Version: v048
Date: UTC:2025-08-23 00:00:00
================================================================================

This module documents the runtime session lifecycle, phases, shutdown protocols, bot_state management, and design confirmations.

Contents:
- TradeBot Runtime Flow (Spec-Locked – Final Version, RIGD_TradingBot_{CURRENT_VERSION})
- Key Design Confirmations (Spec-Locked — RIGD_TradingBot_{CURRENT_VERSION})
- TradeBot Master Build Enhancements (Post-Stabilization, Spec-Locked)
- Final Build Checklist — RIGD_TradingBot_{CURRENT_VERSION} (Spec-Locked)

All runtime logic is immutable except via Web UI configuration changes.

Audit compliance enforced.

================================================================================
RIGD PHASE SUPERVISOR: USER-MODE SYSTEMD SPECIFICATION
================================================================================

OBJECTIVE:
Eliminate `sudo`/`visudo` from bot orchestration. All orchestration runs in
*user mode* under the `tbot` account. The bot is launched via a single
user-mode unit (`tbot_bot.service`); **no separate `.timer` or `@instance`
units exist.**

Systemd model: **exactly one user-mode unit `tbot_bot.service`.**
- `tbot_bot/runtime/main.py` is the single entrypoint, launched by systemd or CLI.
- `main.py` performs build checks, launches the unified Flask UI
  (`tbot_web/py/portal_web_main.py`), and **self-schedules** the daily run of
  `tbot_supervisor.py` at a configurable UTC time.
- `tbot_supervisor.py` runs all phases (open → holdings → mid → close → universe)
  sequentially, writes `bot_state.txt`, and exits. It is **never** a systemd unit.

Environment knobs (read by `main.py`):
- `TBOT_WEB_HOST` (default `0.0.0.0`) — Flask bind host.
- `TBOT_WEB_PORT` (default `6900`)   — Flask port.
- `TBOT_SUPERVISOR_ENABLE` (`1`/`0`, default `1`) — enable daily supervisor.
- `TBOT_SUPERVISOR_UTC_HHMM` (default `0600`) — daily supervisor trigger (UTC).
  - `0600` UTC ≈ 01:00 EST / 02:00 EDT.
- `TBOT_MAIN_POLL_SECS` (default `5`) — main loop poll cadence.

Late start behavior:
- If `main.py` starts **after** the configured UTC trigger, it launches
  `tbot_supervisor.py` **immediately** for “today” and then schedules the next
  run for the following day.

--------------------------------------------------------------------------------
CORE IMPLEMENTATION
--------------------------------------------------------------------------------

1) Use user-mode systemd only:
   - Replace all `sudo systemctl …` with `systemctl --user …`.
   - Example: `systemctl --user restart tbot_bot.service`

2) User unit path:
   - `~/.config/systemd/user/tbot_bot.service`
   - `[Install]` must use `WantedBy=default.target`.

3) Persistent user manager:
   - `loginctl enable-linger tbot`

4) Session environment (add to shell profile):
   ```bash
   export XDG_RUNTIME_DIR=/run/user/$(id -u)


5) Launch & manage the bot via user systemd
  systemctl --user daemon-reload
  systemctl --user enable --now tbot_bot.service
   No `sudo` anywhere in Python or shell.

Notes

No .timer or @instance units are used.

All paths resolved via tbot_bot/support/path_resolver.py.

Logs go to journald and tbot_bot/output/ per policy.



--------------------------------------------------------------------------------
SYSTEMD INSTALLATION
--------------------------------------------------------------------------------

mkdir -p ~/.config/systemd/user
cd ~/.config/systemd/user

# Option A: symlink the provided unit
ln -sf /home/tbot/rigd_tbot/systemd_units/tbot_bot.service tbot_bot.service

# Option B: copy the unit file here

systemctl --user daemon-reload
systemctl --user enable --now tbot_bot.service

Example user unit (~/.config/systemd/user/tbot_bot.service):
----------------------------------------------------------------
[Unit]
Description=RIGD TradeBot Web UI (no scheduler)
After=network.target

[Service]
Type=oneshot
RemainAfterExit=yes
WorkingDirectory=%h/rigd_tbot
ExecStart=/usr/bin/python3 -m tbot_bot.runtime.main
# main.py stays resident (runs its own loop) or exits cleanly by design
Restart=no

# Flask bind and port (override via env if you want)
Environment=TBOT_WEB_HOST=0.0.0.0
Environment=TBOT_WEB_PORT=6900

# Journaling only
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=default.target
----------------------------------------------------------------

Validation
- `systemctl --user status tbot_bot.service`
- `journalctl --user -u tbot_bot.service -e`


=============================================================================================================================================
TradeBot Runtime Flow 
=============================================================================================================================================

Phase 0: Pre-Session (Preparation)
↓
- Edit and validate `.env_bot` (strategy, risk, runtime) and `.env` (keypaths, credentials).
- If encrypted, decrypt `.env_bot.enc` using `security_bot.py` with AES-256 key from `storage/keys/env_bot.key` (path via `path_resolver.py`).
- Bootstrap via Web UI only (which writes required secrets and config).
- Ensure all encrypted secret files (`bot_identity.json.enc`, `broker.json.enc`, etc.) exist post-bootstrap.

Phase 1: System Boot Validation
↓
- `security_bot.py` decrypts `.env_bot.enc` using key from `storage/keys/env_bot.key`.
- `env_bot.py` validates required env vars; missing/malformed values cause fatal error and halt.
- Run `.self_check()` on critical modules (`risk_module.py`, `kill_switch.py`, `watchdog_bot.py`, `error_handler.py`, `strategy_router.py`).
- Failures abort session and log error to `output/logs/error_tracebacks.log` (UTC).

Phase 2: Session Initialization
↓
- `holdings_manager.py` manages float/reserve/allocations with settings from encrypted holdings secrets.
- Runtime trading parameters are loaded from `.env_bot`.
- Defense-mode overrides enforced when enabled.
- `status_bot.py` writes initial status to `output/{BOT_IDENTITY}/logs/status.json`.
- Unified Flask UI starts (binding controlled by `TBOT_WEB_HOST`/`TBOT_WEB_PORT`).

Phase 3: Daily Scheduling & Strategy Cycle (supervisor-driven, UTC)
↓
- `main.py` self-schedules the daily supervisor trigger at `TBOT_SUPERVISOR_UTC_HHMM` (UTC).
  - If `main.py` starts **after** the trigger, it fires the supervisor immediately.
- `tbot_supervisor.py` executes the day’s phases in order:
  1) **Open**  → `strategy_router --session=open`
  2) **Holdings** (after open, delay from `.env_bot`)
  3) **Mid**   → `strategy_router --session=mid`
  4) **Close** → `strategy_router --session=close`
  5) **Universe** (after close, delay from `.env_bot`)
- Supervisor writes:
  - `bot_state.txt` transitions (`analyzing`, `trading`, `updating`, `idle`, etc.)
  - Phase logs: `open.log`, `holdings.log`, `mid.log`, `close.log`, `universe.log`
  - `supervisor.log` and a JSON schedule snapshot `schedule.json`
- Strategy and worker subprocess stdout/stderr are appended to the respective phase logs.

Phase 4: Risk/Fault Monitoring (Continuous)
↓
- Risk, loss limits, API health, and watchdogs as specified remain active.
- Defense mode events are logged and enforced.

Phase 5: Session Termination
↓
- Positions closed as configured; reporting & backups run.
- Ledgers written via `ledger_modules/` only.
- Mark session closed in `status.json`.

Phase 6: Manual Review / Rebalancing
↓
- Operator reviews logs, ledgers, and summaries in the Web UI.
- All holdings/float/reserve actions use the holdings module and ledger modules for audit.

--------------------------------------------------------------------------------
Runtime Worker: `sync_broker_ledger` (Structured Logs & Snapshot Retention)
--------------------------------------------------------------------------------
- **Location:** `tbot_bot/runtime/sync_broker_ledger.py`
- **Launched by:** `main.py` (on admin Web UI POST `/ledger/sync`) or scheduled internal trigger; never by CLI or web directly.
- **Responsibilities:**
  - Resolve paths via `path_resolver.py`; ensure COA and ledger DB exist.
  - Take **pre-sync snapshot** via `ledger_modules/ledger_snapshot.py` to `output/{BOT_IDENTITY}/ledgers/snapshots/` (UTC-name, atomic). Enforce retention window from `.env_bot` (e.g., `LEDGER_SNAPSHOT_RETENTION_DAYS`).
  - Invoke `tbot_bot/accounting/ledger_modules/ledger_sync.py` (Alpaca → normalizers → compliance → mapping → dedupe → double-entry).
  - Emit **structured JSONL** to `output/{BOT_IDENTITY}/logs/ledger_sync.log`:
    - Fields: `timestamp_utc`, `sync_run_id`, `broker`, `start`, `end`, `fetched_trades`, `fetched_cash`, `inserted_rows`, `updated_rows`, `skipped_duplicates`, `skipped_unmapped`, `mapping_version`, `snapshot_file`, `duration_ms`, `status`, `error`.
  - Append audit events via `ledger_modules/ledger_audit.py`.
- **Constraints:** UTC timestamps, Decimal math, no direct SQL or file access outside `ledger_modules/`. Idempotent.

=============================================================================================================================================
Bot State Definitions (bot_state.txt values)
=============================================================================================================================================

- `initialize`: Initial bot startup, configuration phase.
- `provisioning`: Generating keys, secrets, initial config encryption.
- `bootstrapping`: Running DB init, user/account setup.
- `registration`: User account registration UI active.
- `started`: Bot system fully started but not actively trading/analyzing.
- `idle`: Bot ready and primed, not actively analyzing or trading but able to start.
- `analyzing`: Strategy analyzing market data.
- `trading`: Active trade execution ongoing.
- `monitoring`: Post-trade monitoring active.
- `updating`: Runtime updates or config reloads in progress.
- `graceful_closing_positions`: Closing positions in controlled manner on stop command.
- `emergency_closing_positions`: Immediate position close on kill command.
- `stopped`: Bot is halted, no strategies running; requires manual start.
- `shutdown`: System shutdown in progress.
- `shutdown_triggered`: Forced shutdown triggered.
- `error`: Fatal error state; bot halted.

=============================================================================================================================================
UI Behavior Based on Bot State
=============================================================================================================================================

- `initialize`, `provisioning`, `bootstrapping` → show configuration.html UI for setup.
- `registration` → show registration UI.
- `started`, `idle`, `analyzing`, `trading`, `monitoring`, `updating` → show main.html dashboard.
- `graceful_closing_positions`, `emergency_closing_positions` → show main.html with graceful/hard shutdown feedback.
- `stopped` → show main.html indicating stopped state; no strategies running.
- `shutdown`, `shutdown_triggered`, `error` → show error or shutdown page; halt further operations.

=============================================================================================================================================
Bot Control Commands via Web UI  (clarified)
=============================================================================================================================================

- **Stop Bot (graceful):**
  - Web UI writes `control_stop.flag`.
  - `tbot_supervisor.py` detects the flag **between phases**, transitions `bot_state.txt` to
    `graceful_closing_positions`, completes any current phase if safe, and halts remaining phases.

- **Kill Now (immediate):**
  - Web UI writes `control_kill.flag`.
  - `tbot_supervisor.py` detects the flag **between phases**, transitions `bot_state.txt` to
    `shutdown_triggered`, and aborts remaining phases.

- **Start / Resume:**
  - Remove any stop/kill flags in the UI.
  - `main.py` continues to self-schedule daily runs; next run occurs at the next UTC trigger (or immediately if started after the trigger).

- UI remains accessible in all states.


=============================================================================================================================================
Hot Configuration Updates
=============================================================================================================================================

- Configuration page accessible at all times.
- Config changes saved instantly to encrypted runtime config.
- Bot reads config changes dynamically without restart.
- No re-provisioning triggered on config update.
- Prevent accidental re-provisioning or bot restart via config save restrictions in code logic.

=============================================================================================================================================
Key Design Confirmations
=============================================================================================================================================

- Single broker assignment per bot session.
- Float and risk limits strictly enforced from `.env_bot`.
- Real-time PnL logged for dashboard; accounting provides official PnL.
- Defense mode enforces stricter limits and screening.
- All audit logs timestamped and immutable.
- Web dashboard displays live states and alerts.
- No hybrid or dual broker modes.
- Changes managed only via Web UI configuration.

=============================================================================================================================================
TradeBot Master Build Enhancements (Post-Stabilization, Spec-Locked)
=============================================================================================================================================

1. Automated Rebalance Triggers:
- Float deviation thresholds set in `.env_bot`.
- Accounting notified on deviation; bot never initiates transfers.
- Event logged with UTC timestamp and session context.

2. Multi-User Access Roles (RBAC):
- Multi-role access managed in `SYSTEM_USERS.db`.
- Access attempts logged.
- Role-based UI permissions.

3. Strategy Optimization Module:
- Scheduled backtests with paramized methods.
- Human approval required for config changes.

4. Real-Time Alerting:
- Multi-channel alerts per `.env_bot`.
- Configurable per event and strategy.

5. Slippage & Latency Simulation:
- Optional slippage and latency simulation for backtests only.
- No impact on live trading.

=============================================================================================================================================
Final Build Checklist
=============================================================================================================================================

- `.env` and `.env_bot` encryption and validation.
- Bootstrap/init scripts run via Web UI only.
- Environment variables fully validated.
- Strategy modules implement `.self_check()`.
- Logs and ledgers written as per spec.
- Ledger files OFX-aligned, double-entry.
- Risk, shutdown, and notifications implemented.
- Web UI RBAC enforced.
- Bot lifecycle state machine followed strictly.
- Hot config updates dynamic, no restart needed.
- No worker, watcher, or helper is ever launched except by main.py.

================================================================================
Logging_and_Reporting
{CURRENT_VERSION}
================================================================================

This module defines the formats, storage locations, and field requirements for all TradeBot logs, trade records, summaries, and audit outputs.
Every log is written only by its named responsible script as defined below. Any change must update this doc and corresponding code comment.

Contents:
- Logging & Reporting Format
- Modular Strategy Reporting & Audit Output Specification

All outputs are UTC-timestamped, deterministic, OFX-aligned, and compliance-ready.

**Policy:**  
All provisioning, credential creation, encrypted config management, and COA operations are performed *exclusively* via the TradeBot Web UI. No external or accounting system may provision, inject, or modify any credential, secret, key, or config file after bootstrap. Only ledger export and float assignment for audit are accounting roles.

{BOT_IDENTITY} = {ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}

=============================================================================================================================================
Logging & Reporting Format 
=============================================================================================================================================

**Overview:**  
Each bot instance writes structured outputs to isolated, per-bot subdirectories for audit trails, dashboards, compliance, and reconciliation. *All outputs and filenames are governed by `.env_bot` and path resolver logic; no runtime mode switching, no dual-broker operation.*

---

**Primary Output Directories and Log Files**

| Directory                                 | Contents / Log Files                                               | Shown in logs.html?     |
|--------------------------------------------|--------------------------------------------------------------------|-------------------------|
| `output/logs/`                             | System/global logs:                                                |                         |
|                                            | - `main_bot.log` / `system_logs.log` (system lifecycle)            | Yes                     |
|                                            | - `heartbeat.log` (API/connection status)                          | Yes                     |
|                                            | - `router.log` (strategy routing, optional)                        | Yes, if present         |
|                                            | - `screener.log` (screener events, optional)                       | Yes, if present         |
|                                            | - `kill_switch.log` (shutdown triggers, optional)                  | Yes, if present         |
|                                            | - `provisioning.log` (provisioning run log)                        | Yes                     |
|                                            | - `provisioning_status.json` (provisioning status)                 | Yes                     |
|                                            | - `auth_web.log` (web auth activity)                               | Yes                     |
|                                            | - `security_users.log` (user/role management)                      | Yes                     |
|                                            | - `system_users.log` (user CRUD/audit log)                         | Yes                     |
|                                            | - `user_activity_monitoring.log` (user login/session/RBAC)         | Yes                     |
|                                            | - `start_log` (bot/session start events)                           | Yes                     |
|                                            | - `stop_log` (bot/session stop events)                             | Yes                     |
|                                            | - `password_reset_tokens.log` (runtime password reset events)      | Optional                |
|                                            | - `init_system_logs.log` (bootstrap-only, not shown in logs.html)  | No                      |
|                                            | - `init_system_users.log` (bootstrap-only, not shown in logs.html) | No                      |
|                                            | - `init_user_activity_monitoring.log` (bootstrap-only, not shown)  | No                      |
|                                            | - `init_password_reset_tokens.log` (bootstrap-only, not shown)     | No                      |
| `output/{BOT_IDENTITY}/logs/`              | Per-bot/session logs:                                              |                         |
|                                            | - `open.log` (open strategy events)                                | Yes                     |
|                                            | - `mid.log` (mid strategy events)                                  | Yes                     |
|                                            | - `close.log` (close strategy events)                              | Yes                     |
|                                            | - `unresolved_orders.log` (failed/stale orders)                    | Yes                     |
|                                            | - `error_tracebacks.log` (exceptions/errors)                       | Yes                     |
|                                            | - `daily_summary.json` (end-of-session summary)          	        | Yes                     |
|                                            | - `ledger_sync.log` (structured JSONL for sync runs)               | Yes                     |
|                                            | - `status.json` (session state, not a log, not shown in logs.html) | No                      |
| `output/{BOT_IDENTITY}/trades/`            | Per-session trade history logs (`csv` or `json`)                   | No                      |
| `output/{BOT_IDENTITY}/summaries/`         | Session summaries: PnL, stats, win-rate                            | No                      |
| `backups/`                                 | Auto-archived logs, ledgers, config backups (rotated)              | No                      |

---

**Filename Structure**

| Type               | Example Filename                   | Notes                                                     |
|--------------------|------------------------------------|-----------------------------------------------------------|
| System Logs        | `main_bot.log`, `system_logs.log`  | System/global events, lifecycle, errors                   |
| Strategy Logs      | `open.log`, `mid.log`, `close.log` | One per strategy, per bot/session (shown in logs.html)    |
| Unresolved Orders  | `unresolved_orders.log`            | Rejects, partials, stale orders (shown in logs.html)      |
| Error Traces       | `error_tracebacks.log`             | Exceptions/errors (shown in logs.html)                    |
| Start/Stop Events  | `start_log`, `stop_log`            | Session/bot start/stop events (shown in logs.html)        |
| Ledger Sync        | `ledger_sync.log`                  | JSONL records from runtime sync worker                    |
| Activity/Audit     | `user_activity_monitoring.log`, `system_users.log`, `security_users.log`, `auth_web.log` | Audit/compliance (shown) |
| Provisioning       | `provisioning.log`, `provisioning_status.json` | Setup/provisioning (shown in logs.html)                   |
| Trade History      | `trade_history.csv`, `.json`       | All executed trades, full session                         |
| Daily Summary      | `daily_summary.json`               | End-of-session PnL/stats/metrics (optional in logs.html)  |
| Password Reset     | `password_reset_tokens.log`        | Password reset event log (optional in logs.html)          |

*All output filenames are always resolved per bot identity and session by the path resolver.*

---

**Log Format**

Set via `.env_bot`:

- `LOG_FORMAT=csv`  → human-readable
- `LOG_FORMAT=json` → structured for dashboard/ingestion

Only one format is written per session.

---

**Required Fields – `trade_history.json`**

Each entry must include:

- `timestamp`          (ISO 8601 UTC)
- `strategy_name`      (open, mid, close)
- `ticker`             (equity/ETF symbol)
- `side`               (long/short)
- `size`               (quantity)
- `entry_price`        (float)
- `exit_price`         (float)
- `PnL`                (realized)
- `broker`             (from `.env_bot`)
- `error_code`         (if any; e.g., rejection)

---
**Ledger Routing – Single-Broker Enforcement**

All trades, cash events, and holdings-related actions are posted exclusively via the modular ledger interface, ensuring all entries are routed to the correct per-bot ledger using:

- `ENTITY_CODE`, `JURISDICTION_CODE`, `BROKER_CODE`, `BOT_ID`
- Ledger filename suffix: `_BOT_ledger.db`

Ledger path format:  
`tbot_bot/output/{BOT_IDENTITY}/ledgers/{ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_ledger.db`

*All path resolution and naming are enforced by runtime config and `path_resolver.py`; no hardcoded paths permitted. Legacy ledger.py/ledger_utils.py are fully deprecated.*
---

**Export + Archive Flow**

1. `reporting_bot.py` collects/exports logs after each session
2. Ledger/export paths resolved by config and path_resolver
3. `generate_ofx.py` produces OFX export
4. `auto_backup.py` compresses/archives all output

---

**Principles**

- Logs = parallel audit artifacts—never re-imported into ledgers
- No live/paper split—bot operates on one ledger/output set
- All outputs are deterministic, UTC-stamped, and account-mapped

---

**Use Cases**

- Daily/periodic PnL reports
- Compliance/audit verification
- Dashboard ingestion (logs.html shows all marked "Yes" above)
- Historical/strategy analytics
- Tax/regulatory export (OFX, CSV, JSON)

---

==========================================================
Modular Strategy Reporting & Audit Output Specification
==========================================================

**Objective:**  
Support per-strategy, per-session reporting for live audit, optimization, and validation.  
**All logs, summaries, and reporting outputs MUST be generated exclusively via the modular ledger and reporting system (`tbot_bot/accounting/ledger_modules/`, `reporting/`). Legacy helpers and ledger.py are forbidden.**

---

**1. Logs and Summaries Per Strategy**

Each strategy **must** generate:

- `open.log`, `mid.log`, `close.log`              # Per-strategy logs, written only by the assigned strategy logic (main.py), never by subprocess or worker.
- `trade_history.json`, `trade_history.csv`        # Trade-by-trade session record, aligned with ledger event records in `ledger_modules/`.
- `daily_summary.json`                             # PnL, stats, outcomes.

**Fields in all logs/trade records:**  
*Fields must be consistent and sourced via modular ledger APIs; no legacy/adhoc log output is permitted.*

- `strategy_name`
- `signal_trigger_time`
- `entry_timestamp`
- `exit_timestamp`
- `trade_side` (long/short)
- `entry_price`
- `exit_price`
- `size`
- `PnL`
- `broker`
- `exit_reason` (stop_loss, timeout, manual, target_hit)
- `ledger_event_id` (cross-ref to modular ledger event, required)
- `session_id` (for multi-session audit traceability)
- `user` (for manual or UI-initiated actions; RBAC enforced)

---

**2. Daily Summary Metrics**

Each `daily_summary.json` must include:

- `win_rate_per_strategy`
- `total_trades`
- `average_pnl_per_trade`
- `max_gain`
- `max_loss`
- `trade_count_vs_signals_triggered`
- `average_holding_time`
- `most_profitable_tickers`
- `worst_tickers`
- `audit_event_ids` (all relevant modular ledger event/audit IDs)
- `compliance_flags` (any compliance issues/warnings detected)

---

**3. Web UI Reporting**

Expose core metrics/logs in the dashboard:

- Win rate, PnL, trade count (open/mid/close)
- Load/display JSON stats on `status.html`
- Overlay PnL/trade charts by session/strategy
- **All reporting data, summaries, and audit links must be queried through the modular ledger system and never from legacy logs or files.**
- Any holdings/float/reserve/COA events impacting session stats must be linked and displayed in the UI.

---

**4. Runtime Validation**

In `env_bot.py` and runtime logic:

- Enforce that keys exist and are valid:
    - `ENABLE_LOGGING=true`
    - `LOG_FORMAT=json` or `csv`
- Raise fatal error if missing/invalid, with a clear operator message.
- Runtime checks must confirm modular ledger APIs are in use for all trade/log/summarization events; block run if legacy helpers detected.

---

**5. Tuning & Optimization**

- `tuning_tracker.py`:
  - Loads/compares logs across runs using modular ledger API endpoints.
  - Recommends optimal values for buffers/thresholds (e.g., `STRAT_*_BUFFER`).
  - Exports table: buffer → win%, avg PnL, duration, block/reject counts, ticker frequency, compliance events.

---

**RBAC Enforcement — Ledger Web Endpoints**
- **Scope:** `tbot_web/py/ledger_web.py` endpoints (`/ledger`, `/ledger/sync`, `/ledger/groups`, `/ledger/balances`, `/ledger/reconciliation`).
- **Roles:**
  - `Admin`: Full access, including POST `/ledger/sync` (triggers runtime worker), edits to mapping via dedicated mapping blueprint.
  - `Analyst`: Read-only access to ledger listings, groups, balances, reconciliation; **no sync**.
  - `Viewer`: Read-only limited (no reconciliation export).
- **Rules:**
  - All endpoints validate session user + role; unauthorized requests → `403` with audit entry (`auth_web.log` + `user_activity_monitoring.log`).
  - All ledger data access uses `ledger_modules/*` APIs; **no direct SQL/file access**.
  - Each request logs `{timestamp_utc, user_id, role, endpoint, params_hash, result_count, status}` to `auth_web.log`.

---
================================================================================
TEST_MODE
{CURRENT_VERSION}
================================================================================

TEST_MODE Specification for RIGD TradeBot

OVERVIEW:
TEST_MODE is a transient, runtime-only mode triggered by the presence of `tbot_bot/control/test_mode.flag` or any `tbot_bot/control/test_mode_<test>.flag`.
It enables full end-to-end dry-run validation of TradeBot execution and/or any individual test script without live trades or persistent data changes.

PURPOSE:
- Validate scheduling, strategies, screener filtering, order logic, logs, ledgers, and UI display.
- Prevent real capital usage, real orders, notifications, or permanent ledger changes.
- Allow automated/manual testing via Web UI or CLI triggers, including individual test selection.

SCOPE:
If the optional TEST_MODE subsystem is enabled:
- Flags are written by the Web UI (`test_web.py`).
- Test orchestration is handled by **main.py** (not the supervisor) which may launch
  the integration test runner when global/per-test flags are present.
- No tests are launched from systemd directly; production runs never execute tests
  unless flags are explicitly set via the UI/CI.

TRIGGERING:
- Presence of `test_mode.flag` enables TEST_MODE for a full end-to-end test run.
- Presence of `test_mode_<test>.flag` triggers execution of a single corresponding test module.
- Setting TEST_MODE or running individual tests via Web UI writes the appropriate flag file.
- Test completes after the specified scope: full (sequential strategies and reporting) or individual (one test script).
- Upon completion, relevant flag(s) are auto-deleted, returning bot to normal mode.
- UI includes dedicated `test.html` page for triggering and monitoring all or individual tests.

BEHAVIOR:

1. Screener:
 - Ignores fundamentals; filters symbols only by price.
 - Enables rapid symbol pipeline validation.

2. Strategies:
 - Analysis/monitoring windows forced to 1 minute.
 - Executes all three strategies sequentially immediately on global flag set.
 - Individual strategy/test scripts execute only when their flag is present.
 - Bypasses normal schedule (`START_TIME_*`, `TRADING_DAYS`).
 - Stub order submission: no live broker calls.
 - Capital allocation and risk limits ignored or simulated.
 - Outputs/logs/ledgers routed to ephemeral test paths.
 - Suppresses notifications/alerts.

3. Trade Execution:
 - `orders_bot.py` simulates order success; no API calls.
 - Logs all simulated trades with TEST_MODE tag.

4. Logging & Reporting:
 - Separate test-only logs and ledger files used.
 - No changes to live data.
 - Audit logs capture test start/end and all events.

5. UI & Control:
 - `test_web.py` toggles per-test or global flag files.
 - Dedicated `test.html` page allows full or individual test triggers and log streaming.
 - UI disables live trading actions while test(s) active.
 - Displays test progress, results, and completion status.
 - Auto-reset of relevant flag(s) after test ends.

6. Lifecycle:
 - Single run per flag set; non-persistent across restarts.
 - Prevents accidental persistent TEST_MODE.
 - Clear differentiation from live mode in all outputs.
 - Individual test flags take precedence for corresponding scripts; full flag triggers all.

SECURITY & COMPLIANCE:
- Immutable audit logging of test mode lifecycle and all simulated actions.
- No live trades or financial exposure.
- Flag file access secured to admin users only.

FILES AFFECTED:
- `tbot_bot/control/test_mode.flag` (global full test)
- `tbot_bot/control/test_mode_<test>.flag` (individual tests)
- `tbot_bot/config/env_bot.py` (read test_mode flags)
- `tbot_bot/screeners/finnhub_screener.py`
- `tbot_bot/strategy/*.py` (open, mid, close)
- `tbot_bot/trading/orders_bot.py`
- `tbot_bot/trading/notifier_bot.py`
- `tbot_bot/reporting/reporting_bot.py`
- `tbot_bot/accounting/ledger_modules/*`
- `tbot_bot/accounting/ledger_modules/ledger_sync.py`
- `tbot_bot/runtime/sync_broker_ledger.py`
- `tbot_web/py/settings_web.py`
- `tbot_web/py/ledger_web.py` (optional logs display; RBAC enforced)
- `tbot_web/py/test_web.py` and `templates/test.html` (dedicated UI and per-test controls)
- `tbot_web/templates/settings.html` (toggle update)
- `tbot_bot/test/*` (all test scripts now require relevant flag to execute)

TEST VALIDATION:
- Full pytest/unittest integration in `tbot_bot/test/` with per-test and global flag support.
- Logs and ledgers segregated in all test runs.
- UI test page verified for trigger, progress display, and individual test control/cleanup.



================================================================================
Testing_and_Validation
{CURRENT_VERSION}
================================================================================

This module defines the comprehensive testing and CI validation framework for TradeBot v1.0+.

Contents:
- Testing and Validation Suite (Lossless Compression Spec v1.1)

All tests are required pre-deployment; any test failure is a fatal compliance violation.

=============================================================================================================================================
Testing and Validation Suite
=============================================================================================================================================

**Overview:**  
All critical bot logic, modules, and outputs must be validated via an explicit, automated testing framework. All tests must be run and pass before any production deployment, upgrade, or strategy change.  
*No runtime/test code may bypass test enforcement or version checks.*

**Testing Directory:**  
`tbot_bot/test/`

**Test Modules (Matrix — required):**
- `test_main_bot.py`                 # Lifecycle loop, strategy routing, logger flow, shutdown/resume checks
- `test_env_bot.py`                  # .env_bot variable coverage, error, defaults, VERSION_TAG matches VERSION.md (fatal if mismatch)
- `test_backtest_engine.py`          # Historical sim, fills, drift checks
- `test_strategy_selfcheck.py`       # All .self_check() methods True; logs failures
- `test_logging_format.py`           # Log structure matches output JSON schema / required fields
- `test_broker_trade_stub.py`        # Randomized micro-trades, order submission/logging/flow
- `test_screener_random.py`          # Symbol screener randomized eligibility/filter logic
- `test_screener_integration.py`     # Screener module integration using cache and API simulation
- `test_ledger_schema.py`            # Schema validation; double-entry rules; uses `ledger_modules/*` APIs only
- `test_ledger_double_entry.py`      # Debit/credit balance invariant (sum=0) across events; AJEs; fees/taxes
- `test_broker_sync.py`              # Normalizer + sync pipeline; idempotency; mapping enforcement; snapshot before/after
- `test_ledger_deduplication.py`     # FITID + content-hash idempotency; repeat runs
- `test_ledger_reconciliation.py`    # Reconciliation states: ok/mismatch/local-only/broker-only/resolved
- `test_ledger_concurrency.py`       # Concurrent writes/locks; thread/process contention
- `test_ledger_write_failure.py`     # Disk/permission failures; rollback; error propagation
- `test_coa_mapping.py`              # Mapping CRUD/versioning; unmapped=skip_insert; rollback to prior mapping version
- `test_coa_web_endpoints.py`        # /coa UI/API; RBAC; version export/import
- `test_ledger_web_rbac.py`          # Ledger endpoints RBAC: role gates, audit logging, 403 paths
- `integration_test_runner.py`       # E2E: provisioning→config→strategies→sync→reports; mapping version linkage

**Framework:**
- pytest/unittest, CLI/CI-compatible, `--junitxml` supported
- Each test launched only when its flag present (or global `test_mode.flag`)

**Test Commands:**
- Run all tests:  
  `pytest tbot_bot/test/`
- Run individual test (with flag):  
  `touch tbot_bot/control/test_mode_<testname>.flag && python3 -m tbot_bot.test.test_<testname>`

**Integration Test Flow:**
- Loads `.env_bot.test`
- Invokes `main.py` in TEST_MODE (via the global flag)
- Confirms strategy order, log/output generation, triggers/errors, trade/log/export correctness, session integrity
- Validates that all ledger/COA/holdings events are posted and queried via `ledger_modules/` only

**Web UI & Flag Requirements:**
- `test_web.py` + `test.html` allow triggering ALL or INDIVIDUAL tests
- Flags auto-removed on completion
- No test runs without proper flag(s)

**CI/DevOps:**
- Headless; no live broker API required
- `.env_bot.test` allowed for CI; secrets stubbed

**Version Enforcement:**
- `test_env_bot.py` verifies `.env_bot["VERSION_TAG"]` matches `VERSION.md` (fatal if mismatch)

**Required Validation (All Tests):**
- All outputs match runtime schema in 030/020 specs (current version)
- Ledgers pass double-entry rules; OFX alignment; UTC timestamps
- UI/reporting pull via modular ledger APIs only
- Sync worker produces `ledger_sync.log` entries; snapshot files exist; retention enforced

**Summary:**  
Any failing test blocks release. Logs, ledgers, summaries, and mapping versions are validated as part of the integration suite. UI/CLI may launch full or single tests via flags. All modular ledger/holdings/COA functionality must be covered.

================================================================================
TESTING, WATCHER/WORKER, AND LOGGING SYSTEM DEFINITIONS
================================================================================

Definitions:
- **Watcher:** Long-running daemon/process launched by main.py to monitor or maintain a system aspect (health, heartbeat, broker connection, etc.).
- **Worker:** A process launched by main.py to perform an active task (strategy run, reporting, logging). Never supervises other workers.
- **Helper/Utility:** Python module only imported, never launched as a standalone process or via subprocess. Pure logic/support.
- **Test Runner:** Script that executes an automated test sequence. May be launched by main.py (in test mode), CI, or developer directly.
- **Web UI Test Trigger:** Triggers a control flag (never launches processes directly); main.py is responsible for launching any required test runners.

--------------------------------------------------------------------------------
tbot_bot/runtime/
--------------------------------------------------------------------------------
main.py
    # SINGLE ENTRYPOINT. Launched by systemd (user-mode) or CLI.
    # - Runs build checks/env decrypt/identity snapshot.
    # - Launches unified Flask UI (portal_web_main.py) — bind/port via TBOT_WEB_HOST/TBOT_WEB_PORT.
    # - Self-schedules and launches tbot_supervisor.py daily at TBOT_SUPERVISOR_UTC_HHMM (UTC).
    #   * Fires immediately if started after the daily trigger; schedules next for tomorrow.
    # - Clean shutdown: propagates SIGTERM/SIGINT to child processes.
    # Writes: main_bot.log, start_log, stop_log; updates bot_state to reflect activity.


status_bot.py
    # WATCHER. Launched by main.py only.
    # Tracks health/state, writes status.json, session logs.
    # Writes: tbot_bot/output/{bot_id}/logs/status.json, and system logs (system_logs.log, shown in logs.html)

watchdog_bot.py
    # WATCHER. Launched by main.py only.
    # Monitors broker connection/heartbeat.
    # Writes: tbot_bot/output/logs/heartbeat.log (shown in logs.html)

tbot_supervisor.py
    # DAILY ONE-SHOT SUPERVISOR. Launched only by main.py (never a systemd unit).
    # - Computes today’s UTC schedule using env_bot (already UTC).
    # - Writes schedule.json; runs phases sequentially: open → holdings → mid → close → universe.
    # - Honors control flags between phases; updates bot_state; routes stdout/stderr to per-phase logs.
    # - Exits after completing the day’s phases (no daemon loop).

sync_broker_ledger.py
    # WORKER. Launched by main.py on admin Web UI POST /ledger/sync (RBAC: Admin only).
    # Takes pre-sync snapshot (ledger_snapshot.py), enforces retention, invokes ledger_modules/ledger_sync.py, writes JSONL to ledger_sync.log, appends audit records.
    # Never runs on its own; never touches DB/files directly outside ledger_modules/ and path_resolver.

--------------------------------------------------------------------------------
tbot_bot/reporting/
--------------------------------------------------------------------------------
auto_backup.py, daily_summary.py, log_rotation.py, notify_rebalance_requirements.py,
report_router.py, session_report.py, status_logger.py, trade_logger.py
    # WORKERS. Only launched by main.py or imported.
    # Each worker writes to its documented output file ONLY.
    # For example, status_logger.py writes tbot_bot/output/{bot_id}/logs/status.json
    # Other reporting modules may write: provisioning.log, provisioning_status.json, daily_summary.json, unresolved_orders.log, error_tracebacks.log, etc.

--------------------------------------------------------------------------------
tbot_bot/test/
--------------------------------------------------------------------------------
integration_test_runner.py
    # TEST RUNNER. Launched by main.py (in TEST_MODE), tbot_supervisor.py, web UI, or manually/CI.
    # Checks for per-test flags (test_mode_<test>.flag) to run a single test; if only test_mode.flag is present, runs all tests.
    # NEVER launches any watcher/worker; only starts dedicated test helpers if needed.
    # Writes: tbot_bot/output/{bot_id}/logs/test_mode.log, and output artifacts.
    # Deletes its own flag(s) after completion.

test_*.py
    # DEV/CI TESTS. Run by pytest/unittest or manually.
    # Each test requires presence of its control flag (test_mode_<test>.flag or test_mode.flag) to run.
    # After completion, test scripts auto-delete their own control flag.
    # NEVER launched by production bot. NEVER writes production logs or flags.

README.md (in test/)
    # Clarifies which scripts are web UI-triggered, which are CI/dev/manual, and the flag requirements for test execution.

--------------------------------------------------------------------------------
tbot_web/py/
--------------------------------------------------------------------------------
test_web.py
    # WEB UI TEST FLAG HANDLER. Triggered only by admin action via Web UI.
    # Writes: tbot_bot/control/test_mode.flag (all), or tbot_bot/control/test_mode_<test>.flag (individual).
    # Does NOT launch any processes directly—main.py or tbot_supervisor.py watches for flag(s) and launches integration_test_runner.py.
    # Also provides log reading endpoint for UI: reads tbot_bot/output/{bot_id}/logs/test_mode.log

logs_web.py
    # LOG READER/WEB ENDPOINT. Reads from tbot_bot/output/logs/*.log and tbot_bot/output/{bot_id}/logs/*.log (all shown-in-logs.html files listed in directory spec), never writes.

ledger_web.py
    # LEDGER BLUEPRINT. RBAC-enforced endpoints for /ledger, /ledger/sync, /ledger/groups, /ledger/balances, /ledger/reconciliation.
    # Uses ledger_modules/* APIs only; Admin required for POST /ledger/sync; read endpoints allow Analyst/Viewer per policy.
    # All requests audit-logged with user, role, endpoint, params hash, status.

ALL OTHER BLUEPRINTS (configuration_web.py, settings_web.py, etc.):
    # NEVER launch workers/watchers; may write control flags for main.py to pick up.

--------------------------------------------------------------------------------
tbot_bot/support/
--------------------------------------------------------------------------------
All modules (utils_*, path_resolver.py, etc.)
    # HELPERS. Imported ONLY. Never launched directly or by subprocess. Never supervise or spawn any process.
    # May read/write helper log files if documented.

--------------------------------------------------------------------------------
LOG FILE LOCATIONS & RESPONSIBILITY
--------------------------------------------------------------------------------
tbot_bot/output/logs/main_bot.log               # Written only by: main.py (system lifecycle) — shown in logs.html
tbot_bot/output/logs/supervisor.log             # Written only by: tbot_supervisor.py (daily orchestration) — shown
tbot_bot/output/logs/schedule.json              # Written only by: tbot_supervisor.py (daily schedule snapshot) — shown
tbot_bot/output/logs/heartbeat.log              # Written only by: watchdog_bot.py — shown
tbot_bot/output/logs/router.log                 # Optional, strategy router — shown if present
tbot_bot/output/logs/screener.log               # Optional, screener modules — shown if present
tbot_bot/output/logs/kill_switch.log            # Optional, kill/defense events — shown if present
tbot_bot/output/logs/start_log                  # Written only by: main.py — shown
tbot_bot/output/logs/stop_log                   # Written only by: main.py — shown
tbot_bot/output/logs/provisioning.log           # Provisioning runner — shown
tbot_bot/output/logs/provisioning_status.json   # Provisioning status — shown
tbot_bot/output/logs/auth_web.log               # Web auth activity — shown
tbot_bot/output/logs/security_users.log         # User/role management — shown
tbot_bot/output/logs/system_users.log           # User CRUD/audit — shown
tbot_bot/output/logs/user_activity_monitoring.log # Session/RBAC — shown
tbot_bot/output/logs/init_*                     # Bootstrap-only (not shown in logs.html)

tbot_bot/output/{bot_id}/logs/open.log          # Written only by: supervisor (open phase) — shown
tbot_bot/output/{bot_id}/logs/holdings.log      # Written only by: supervisor (post-open holdings) — shown
tbot_bot/output/{bot_id}/logs/mid.log           # Written only by: supervisor (mid phase) — shown
tbot_bot/output/{bot_id}/logs/close.log         # Written only by: supervisor (close phase) — shown
tbot_bot/output/{bot_id}/logs/universe.log      # Written only by: supervisor (post-close universe) — shown
tbot_bot/output/{bot_id}/logs/error_tracebacks.log # Exceptions/errors — shown
tbot_bot/output/{bot_id}/logs/unresolved_orders.log # Orders needing attention — shown
tbot_bot/output/{bot_id}/logs/daily_summary.json   # Session summary — (optional shown)
tbot_bot/output/{bot_id}/logs/ledger_sync.log      # Sync worker JSONL — shown
tbot_bot/output/{bot_id}/logs/status.json          # Status (used by dashboard; not shown in logs.html)

--------------------------------------------------------------------------------
CONTROL FILES & FLAGS
--------------------------------------------------------------------------------
tbot_bot/control/bot_state.txt         # Written by: tbot_supervisor.py (during phases), main.py (lifecycle hints)
tbot_bot/control/control_start.flag    # (If used) Written by Web UI; read by main.py (legacy compatibility)
tbot_bot/control/control_stop.flag     # Written by Web UI; read by supervisor between phases for graceful halt
tbot_bot/control/control_kill.flag     # Written by Web UI; read by supervisor between phases for immediate abort
tbot_bot/control/test_mode.flag        # (If test system enabled) Global full test trigger; removed by test runner
tbot_bot/control/test_mode_<test>.flag # (If test system enabled) Per-test trigger; removed by test runner

================================================================================
SUMMARY TABLE (Updated)
================================================================================
Script Name                    | Launched By           | Role        | When Launched                                  | Writes/Reads
-------------------------------|-----------------------|-------------|-----------------------------------------------|------------------------
main.py                        | systemd/CLI           | Entry Point | always                                         | main_bot.log, start_log, stop_log; launches Flask; schedules/starts supervisor; bot_state (hints)
status_bot.py                  | main.py               | Watcher     | always (if enabled)                            | status.json; system logs
watchdog_bot.py                | main.py               | Watcher     | always (if enabled)                            | heartbeat.log
tbot_supervisor.py             | main.py               | Supervisor  | daily at TBOT_SUPERVISOR_UTC_HHMM (UTC); immediate if late | supervisor.log, schedule.json; phase logs; bot_state transitions; honors stop/kill flags
sync_broker_ledger.py          | main.py (via Web UI)  | Worker      | on Admin POST /ledger/sync                     | ledger_sync.log; snapshots; audit events
integration_test_runner.py     | main.py / CI (opt.)   | Test runner | test mode only (flags present)                 | test_mode.log; cleans up flags
test_web.py                    | Web UI                | Test flags  | admin/test action (optional subsystem)         | test_mode.flag / test_mode_<test>.flag
test_*.py                      | CI/manual             | Dev/CI test | never prod                                     | temp logs/console; cleans up flags

--------------------------------------------------------------------------------
NOTES
--------------------------------------------------------------------------------
- No watcher/worker/test runner ever launches another watcher/worker. All process launches are direct from main.py or tbot_supervisor.py.
- Only helpers/utilities are imported; never run as standalone or as subprocesses.
- Web UI triggers only write flags; main.py or tbot_supervisor.py does all process launching.
- All log file locations are exclusive: only the named script writes that file.
- Any changes to this convention MUST be reflected here and in code comments.
- All tests and integration test runner require the appropriate test_mode.flag or test_mode_<test>.flag to run, and must auto-remove their flag after completion.

================================================================================
