================================================================================
Document: 060
Accounting_Integration
Version: v047
Date: UTC:2025-07-19 00:00:00
================================================================================

This module mandates alignment of TradeBot with the internal, OFX-compliant accounting and ledger structure. *No external or shared ledger/accounting system may alter, inject, or provision data into the bot’s runtime, ledger, or COA files. All accounting integration is local, explicit, and compliance-locked.*

Contents:
- TBOT LEDGER INTEGRATION: ARCHITECTURE & COMPLIANCE
- Chart of Accounts — Single-Broker TBot Architecture
- Atomic Key/Secret Rotation Compliance

Ledger integrity, OFX compliance, and audit traceability are enforced at every stage.

{BOT_IDENTITY} = {ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}

=============================================================================================================================================
TBOT LEDGER INTEGRATION: ARCHITECTURE & COMPLIANCE
=============================================================================================================================================

**Purpose:**  
Defines all rules for TradeBot accounting integration, ledger outputs, and compliance traceability. All logic is strictly local, never driven by an external accounting system or tool.

**Scope:**  
These rules apply to:
- All live or test-mode tbot trading
- All float/cash movement, profit/loss logging, reconciliation, and reporting

----------------------------------------------------------------------  
CORE INTEGRATION RULES  
----------------------------------------------------------------------

1. **LEDGER ISOLATION & FILENAME STRUCTURE**
   - All bot trading/actions write *only* to that bot's assigned ledger:  
     - `output/{BOT_IDENTITY}/ledgers/{ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_ledger.db`
   - No cross-bot/entity writes; no shared ledgers.

2. **MULTI-CURRENCY AND ENTITY METADATA**
   - Each ledger entry includes explicit `currency_code`, `entity_code`, `jurisdiction_code`, `broker_code`, and `BOT_ID` fields.
   - Multi-currency and multi-entity compliance is always enabled, regardless of single-broker use.

3. **OFX-ALIGNED ENTRY & EXPORT**
   - All ledger/trade entries are OFX-aligned for export (`TRNTYPE`, `DTPOSTED`, `FITID`, etc.).
   - *No direct DB writes to final reporting tables*—all output goes through bot's local ingestion and reconciliation logic.

4. **DOUBLE-ENTRY ENFORCEMENT**
   - All tbot-generated ledger entries are double-entry, balancing debits/credits for trade, PnL, float, and fees.
   - Bot *never* bypasses or weakens double-entry; integrity check enforced before export.

5. **AUDIT LOGGING**
   - All actions triggering ledger changes are audit-logged (`logs/` table).
   - Manual edits or corrections are flagged, referenced, and subject to review.

6. **STRICT SYSTEM INDEPENDENCE**
   - No runtime or test logic may query, ingest, or update external accounting systems or ledgers.
   - All trade/test actions are local to the bot’s ledgers and logs.

7. **Atomic Key/Secret Rotation**
   - All Fernet keys and corresponding encrypted secrets used for accounting, ledger, and export modules are automatically regenerated and re-encrypted atomically whenever any config, credential, or sensitive secret is modified or a user is created/modified.  
   - Key/secret rotation does not require manual steps; all affected files are backed up before any overwrite and no old key or secret is reused.

----------------------------------------------------------------------  
MANDATORY FIELDS FOR EACH TRADE/ACTION  
----------------------------------------------------------------------

Each bot ledger entry **must include**:

- `TRNTYPE` (e.g., BUY, SELL, SHORT, COVER)
- `DTPOSTED` (UTC, ISO-8601)
- `FITID` (unique transaction ID)
- `currency_code` (e.g., USD)
- `entity_code`, `jurisdiction_code`, `broker_code`, `BOT_ID`
- `strategy` (open, mid, close)
- `ticker`/`symbol`
- `side` (long/short)
- `size`
- `entry_price`, `exit_price`
- `PnL`
- `audit_reference` (link to log/audit table)
- `TAG` (e.g., InverseETF, if applicable)
- `LEVERAGE_MULTIPLIER` (if leveraged ETF)

**All above fields are required for validation, audit, and export.**

----------------------------------------------------------------------  
ENFORCEMENT & SYSTEM CONSTRAINTS  
----------------------------------------------------------------------

- *All CSV/JSON exports are external artifacts, never re-ingested by the bot.*
- Only validated, double-entry-compliant data is written to ledgers after each strategy session.
- If ledger fails schema or double-entry validation, export is blocked.
- All compliance, schema, and field requirements are enforced by:
  - `tbot_bot/accounting/accounting_config.py`
  - `tbot_bot/accounting/ledger_utils.py`
  - `tbot_bot/accounting/coa_utils.py`
  - Export/report modules

**Note:** Inverse ETF, leveraged, or synthetic short trades are recorded with standard accounts; type and leverage tracked via `TAG` and `LEVERAGE_MULTIPLIER` fields.

----------------------------------------------------------------------  
RISKS IF IGNORED  
----------------------------------------------------------------------

- Ledger corruption or unbalanced entries
- Cross-entity or cross-bot capital misallocation
- Audit and regulatory noncompliance (OFX, IRS, SEC)
- Broken reconciliation or tax/filing output
- Inability to distinguish live/test activity

=============================================================================================================================================
Chart of Accounts – Single-Broker TBot Architecture
=============================================================================================================================================

*Every bot instance writes to a local, OFX-compliant ledger file:*
`output/{BOT_IDENTITY}/ledgers/{ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_ledger.db`

----------------------------------------------------------------------------------------------------------------------------------------------
CHART OF ACCOUNTS: {ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_COA.db 
----------------------------------------------------------------------------------------------------------------------------------------------

# -- COA Metadata (Required in all ledgers and COA files) --
COA_METADATA:
    currency_code: "USD"
    entity_code: "{ENTITY_CODE}"
    jurisdiction_code: "{JURISDICTION_CODE}"
    coa_version: "v1.0.0"
    created_at_utc: "<UTC_TIMESTAMP>"
    last_updated_utc: "<UTC_TIMESTAMP>"

# -- Account Structure (core nodes + holdings/tax/payroll/allocations) --

1000 Bank and Cash Accounts [Cash & Equivalents]
├── 1010 Float Injection – From RIGD Group
├── 1020 Float Returned – To RIGD Group
├── 1030 Alpaca – Cash
├── 1040 IBKR – Cash
├── 1050 Tradier – Cash
├── 1060 Robinhood – Cash

1100 Assets [Investing Activities]
├── 1110 Brokerage Accounts – Equities
│   ├── 1111 Alpaca – Equities
│   ├── 1112 IBKR – Equities
│   ├── 1113 Tradier – Equities
│   └── 1114 Robinhood – Equities
├── 1120 Tax Reserve (Brokerage)
├── 1130 Payroll Reserve (Brokerage)

2000 Liabilities [Operating Activities]
├── 2010 Broker Payables (Accrued Fees)
├── 2020 Market Data Payables (Accrued Subscriptions)

3000 Equity [Financing Activities]
├── 3010 Capital Float Ledger
├── 3020 Daily Float Allocation History
├── 3030 Opening Balance
├── 3040 Accumulated Profit

4000 Income [Operating Activities]
├── 4010 Realized Gains – Alpaca
├── 4020 Realized Gains – IBKR
├── 4030 Realized Gains – Tradier
├── 4040 Realized Gains – Robinhood
├── 4050 Qualified Dividends
├── 4060 Short-Term Capital Gains
├── 4070 Long-Term Capital Gains
├── 4080 Holdings Allocation Rebalancing Gain/Loss
├── 4090 Float/Tax/Payroll Reserve Transfers

5000 Expenses [Operating Activities]
├── 5010 Broker Fees – Alpaca
├── 5020 Broker Fees – IBKR
├── 5030 Broker Fees – Tradier
├── 5040 Broker Fees – Robinhood
├── 5050 Slippage / Execution Losses
├── 5060 API Timeout Penalties
├── 5070 Bot Infrastructure Costs
├── 5080 Tax Payments (Realized/Withheld)
├── 5090 Payroll Disbursements (Owner/Operator)

9100 Exports [Control & Reporting]
├── 9110 Daily P&L Export – Manager.io Format
├── 9120 CSV/JSON Trade Log Export
├── 9130 SQLite Ledger Backup
├── 9140 Broker Confirm Archive (PDFs)
├── 9150 End-of-Day Snapshot (Holdings + Cash)
├── 9160 Holdings Rebalance Audit Log Export

9200 Logging / Execution References [Control]
├── 9210 Trade UUID
├── 9220 Broker Confirm #
├── 9230 Strategy Tag
├── 9240 Source Method Tag
├── 9250 EOD Synced Flag
├── 9260 Reconciliation Passed Flag

9300 System Integrity [Control]
├── 9310 Failures & Rejected Orders
├── 9320 Manual Overrides
├── 9330 Ledger Lock Flag (YES/NO)
├── 9340 Ledger Status: ACTIVE / DECOMMISSIONED
├── 9350 Final Entry Timestamp
└── 9360 Debug / Strategy Tags


------------------------------------------------------------------------------------------
COA Metadata & Versioning Notes
------------------------------------------------------------------------------------------

- All COA files must include at minimum:  
  - `currency_code`, `entity_code`, `jurisdiction_code`, `coa_version`, `created_at_utc`, `last_updated_utc`
- Schema migration = versioned filename:  
  `{ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_COA_v1.0.0.db`
- COA metadata is stored in `coa_metadata` table (same fields as above).
- All ledgers and COA files must be ready for multi-entity/currency expansion.

------------------------------------------------------------------------------------------
Export Constraints and Enforcement
------------------------------------------------------------------------------------------

- Only validated, reconciled trades are written to ledgers after session.
- If ledger fails schema or double-entry check, export is blocked.
- `.csv`/`.json` are for external audit only, never parsed for ingestion.
- All structure, compliance, and export logic is enforced by local accounting modules.

**Note:** Inverse ETF, leveraged, or synthetic trades are recorded as normal, with tags. No special COA accounts are required.


=============================================================================================================================================
Automated Holdings, Float, and Reserve Management – Accounting Integration
=============================================================================================================================================

**Purpose:**  
Formalizes how all automated holdings, float, tax reserve, payroll reserve, and allocation/rebalancing activities are integrated into the bot's ledger, using the expanded COA.

----------------------------------------------------------------------
Automated Holdings/Reserves – Core Flows & Ledger Entry Points
----------------------------------------------------------------------

1. **Float Management**  
   - All float injections/returns, and any cash-top up actions, are journaled under:
     - *Bank and Cash Accounts*: 1000 series (e.g., 1030–1060)
     - *Float Injection/Return*: 1010, 1020
     - *Equity Float Ledger*: 3010, 3020
   - Float adjustment and reconciliation events must be double-entry, tagged by trigger (bot, operator, auto-rebalance).
   - **When float is restored by selling securities, any realized gain triggers a tax reserve allocation per tax reserve %, posted as below. No payroll allocation is ever triggered by float sales. Losses do not generate tax or payroll allocations.**
   - **All float management actions are posted with audit trail: user, UTC timestamp, trigger, before/after values. Allocated reserves are immutable except by explicit, audited manual override.**

2. **Tax Reserve**  
   - On each profit realization (bot trade or holdings sale), tax reserve allocation is split from realized gain and posted as:
     - *Assets*: 1120 (Tax Reserve)
     - *Income*: 4090 (Float/Tax/Payroll Reserve Transfers)
     - *Expense*: 5080 (Tax Payments), when cash outflow occurs
   - All splits, transfers, and payments to tax are logged per event.
   - **Once posted, tax reserves cannot be reduced or re-used for trading, float, or other flows except by explicit manual override, which is always audit-logged. No reserve is set aside for losses.**

3. **Payroll Reserve**  
   - After tax, payroll split is posted to:
     - *Assets*: 1130 (Payroll Reserve)
     - *Income*: 4090 (Float/Tax/Payroll Reserve Transfers)
     - *Expense*: 5090 (Payroll Disbursements), when cash outflow occurs
   - Allocations logged as internal transfer at split, and as expense at disbursement.
   - **Payroll allocation only occurs on positive post-tax gains from bot trading activities, never from float sales or realized losses. Payroll reserves, once posted, are never clawed back or reused for other flows.**

4. **Holdings Allocation/Rebalancing**  
   - Every purchase/sale of long-term securities, as well as periodic/manual rebalance, is posted to:
     - *Assets*: 1100 series (per-broker equities)
     - *Income*: 4080 (Holdings Allocation Rebalancing Gain/Loss)
     - *Exports*: 9160 (Holdings Rebalance Audit Log Export, for reporting/audit only)
   - Audit log must include action context, symbols, allocation %, cash amounts, and resulting value.
   - Unrealized and realized P/L must be reconciled to Income or Asset accounts as required.
   - **Every allocation and rebalance event must be logged to both the ledger and immutable audit trail with complete context, compliance, and rationale.**

5. **General Enforcement**
   - All above entries are double-entry compliant and OFX-aligned.
   - Each automated or manual action (split, transfer, rebalance) must reference FITID, DTPOSTED, context/audit tag, and source trigger.
   - No action may be posted outside of scheduled flows, manual UI action, or validated trigger.
   - **All config or allocation changes must trigger a backup of prior config/secrets, and generate an audit entry including user, UTC timestamp, and rationale. System must block any non-compliant or out-of-bounds action and notify the user.**


----------------------------------------------------------------------
COA Accounts Used by Holdings Management
----------------------------------------------------------------------

- **Assets:**  
    - 111x: Equities (per broker)
    - 1120: Tax Reserve (Brokerage)
    - 1130: Payroll Reserve (Brokerage)
- **Income:**  
    - 4080: Holdings Allocation Rebalancing Gain/Loss
    - 4090: Float/Tax/Payroll Reserve Transfers
- **Expenses:**  
    - 5080: Tax Payments (Realized/Withheld)
    - 5090: Payroll Disbursements (Owner/Operator)
- **Exports:**  
    - 9160: Holdings Rebalance Audit Log Export

All flows, splits, and rebalancing actions must utilize these accounts, with strict double-entry and append-only audit.

=================================================================================================================
Bot–Accounting System Handshake & External Transfer Protocol
=================================================================================================================

**Purpose:**  
Defines the mandatory process for all physical cash movement between the TradeBot brokerage account and the LLC/operating account, including tax reserve and payroll siphoning, capital contributions, and any required reconciliation.  
This protocol *formally prohibits* any direct access, merging, or write-back between bot-side ledgers and the accounting system. All transfers must follow this handshake to ensure strict audit traceability and prevent double-booking or reconciliation loss.

---------------------------------------------------------------------------------------------------------------
I. Overview
---------------------------------------------------------------------------------------------------------------
The handshake protocol is the only permitted mechanism for initiating, proposing, and completing any movement of cash or allocation (float, tax, payroll, capital contribution) between the bot (broker) and the external accounting system.  
All actions are logged, time-stamped, and must be double-entry compliant in both the bot’s ledger and the accounting system.  
At no point does either system overwrite, merge, or directly write to the other’s ledger.  
All proposals and acknowledgments are append-only, with permanent audit logs.
No exceptions, operator overrides, or emergency actions may bypass this protocol for any cash, reserve, or capital movement between the bot and any external system. Any violation—manual or automated—will be flagged as a compliance breach and subject to immediate investigation.

---------------------------------------------------------------------------------------------------------------
II. Core Handshake Workflow
---------------------------------------------------------------------------------------------------------------

1. **Proposal Generation (by Bot)**
    - When the bot determines that funds must be transferred (e.g., tax reserve siphoning, payroll transfer, float injection/return, capital contribution), it creates a *transfer proposal* entry, appends it to its outbound transfer queue, and writes a corresponding “pending” record in its ledger and audit log.
    - The proposal includes:
        - Unique proposal ID (UUID)
        - Action type (tax_reserve_transfer, payroll_transfer, float_injection, capital_contribution, etc.)
        - Amount (currency, value)
        - Source account (bot-side)
        - Destination account (LLC/operating or external)
        - Required chart-of-accounts mapping (bot and accounting)
        - Proposed date/time (UTC, ISO8601)
        - Reference to triggering audit/log event
        - Required double-entry splits (OFX/COA fields)
        - Current state (pending)
        - Full rationale/context (auto/manual, threshold, cycle, etc.)
        - User/trigger origin (system/operator)

2. **Export & Delivery**
    - The transfer proposal is exported as a machine-readable file (JSON or CSV, as specified), or written to a designated export folder (`output/{BOT_IDENTITY}/transfers/`).
    - The accounting system is responsible for polling or reading these proposals at defined intervals (e.g., nightly).

3. **Accounting System Review & Execution**
    - The accounting system ingests all *pending* proposals, verifies compliance (COA mapping, amounts, rationale, available funds, regulatory and tax logic), and—if approved—initiates the actual cash transfer via the designated bank/brokerage interface.
    - No transfer is considered complete until acknowledged by the accounting system.
    - If the proposal cannot be executed, the accounting system appends a “rejected” acknowledgment, with reason, to the bot's audit trail (never deletes the original proposal).

4. **Acknowledgment (by Accounting)**
    - Upon successful transfer, the accounting system writes an *acknowledgment record* (JSON/CSV or DB entry) into the bot’s inbound queue (`output/{BOT_IDENTITY}/transfers_ack/`), referencing the proposal ID.
    - This acknowledgment includes:
        - Proposal ID (must match bot’s original)
        - Execution status (completed, rejected, needs_correction)
        - Execution timestamp (UTC, ISO8601)
        - Any deviations (e.g., partial fill, fee adjustment)
        - Unique accounting system reference (for audit link)
        - Optional signed hash/confirmation (for tamper-proofing)
        - Operator/trigger ID (if manual)
        - Comments or correction instructions (if needed)

5. **Final Reconciliation (by Bot)**
    - The bot ingests the acknowledgment file and matches it to the pending proposal.
    - If “completed”: bot updates its ledger entry from “pending” to “executed”, links to the accounting system reference, and closes the audit record.
    - If “rejected” or “needs_correction”: bot logs the result, marks the proposal as failed/invalid, and requires manual operator review. No automatic resubmission is permitted—only an explicit new proposal can be created.

6. **Permanent Audit Trail**
    - All proposals, acknowledgments, and resulting ledger entries remain append-only and are never overwritten or deleted.
    - Every action is cross-referenced in the `logs/` table and the audit trail, with full timestamp, origin, and resulting status.
    - Each proposal/acknowledgment is cryptographically hashed for tamper-evidence.

---------------------------------------------------------------------------------------------------------------
III. Prohibited Actions and Enforcement
---------------------------------------------------------------------------------------------------------------

- No system may merge, sync, or import ledger data directly from the other’s database or files.
- No bot action may directly write to or reconcile the accounting system’s ledger; and vice versa.
- No proposal or acknowledgment may be deleted after creation—only appended.
- Any deviation, error, or manual correction must be audit-logged and traceable.

---------------------------------------------------------------------------------------------------------------
IV. Example Transfer Proposal (JSON)
---------------------------------------------------------------------------------------------------------------

```json
{
  "proposal_id": "26f67c87-cd88-42fc-9b7e-ef38b5cf001e",
  "action_type": "tax_reserve_transfer",
  "amount": {"currency": "USD", "value": 2500.00},
  "source_account": "1030 Alpaca – Cash",
  "destination_account": "2000 RIGD Group LLC – Tax Reserve Bank",
  "coa_mapping": {
    "bot_ledger": ["1120 Tax Reserve (Brokerage)", "4090 Float/Tax/Payroll Reserve Transfers"],
    "accounting_ledger": ["1200 Tax Reserve", "4900 Transfers In"]
  },
  "proposed_datetime_utc": "2025-07-20T16:10:00Z",
  "audit_reference": "log_1792",
  "double_entry_splits": [
    {"account": "1030", "type": "credit", "amount": 2500.00},
    {"account": "1120", "type": "debit", "amount": 2500.00}
  ],
  "current_state": "pending",
  "rationale": "Quarterly tax reserve sweep per reserve allocation threshold.",
  "user_origin": "system"
}

---------------------------------------------------------------------------------------------------------------
V. Example Transfer Acknowledgment (JSON)
---------------------------------------------------------------------------------------------------------------

{
  "proposal_id": "26f67c87-cd88-42fc-9b7e-ef38b5cf001e",
  "status": "completed",
  "execution_datetime_utc": "2025-07-21T15:48:00Z",
  "accounting_reference": "acct_txn_9923",
  "operator_id": "user_admin",
  "comments": "Funds received, confirmed by bank transfer.",
  "hash": "ac2f98b7ab1f438e97b74e22d39e5c7a"
}

---------------------------------------------------------------------------------------------------------------
VI. Timing, Backup, and Error Handling
---------------------------------------------------------------------------------------------------------------

Bot exports proposals on event/interval (immediate for threshold actions, nightly for regular sweeps).

Accounting system imports proposals and returns acknowledgments at minimum daily intervals.

All exports are atomic (write to temp file, move/rename on completion).

Both systems automatically back up export/import folders before purging/archive.

Any error, rejection, or missing acknowledgment blocks the next transfer of the same type and triggers an operator alert.

---------------------------------------------------------------------------------------------------------------
VII. Future-Proofing and Extensions
---------------------------------------------------------------------------------------------------------------

This protocol is mandatory for all external cash, tax, and payroll movements, even if new brokers, accounts, or legal entities are added.

Any future automation (e.g., direct bank APIs, Wise, Mercury) must still go through proposal/ack/ledger handshake, never direct merge.

Digital signature or secure messaging can be layered atop this protocol for higher trust and auditability.

---------------------------------------------------------------------------------------------------------------
VIII. Enforcement and Governance
---------------------------------------------------------------------------------------------------------------

The handshake protocol is required for regulatory audit, and any system or user bypassing this protocol will cause all subsequent exports and reconciliations to be marked noncompliant.

Enforcement is built into the export, ledger, and audit modules.

All supporting documentation (transfer logs, receipts, audit files) must be retained for a minimum of seven years or as required by law.

Any violation or bypass of this protocol (manual or automated) will be flagged as a compliance breach and subject to immediate investigation.


=================================================================================================================
Broker Ledger Sync and Reconciliation System Specification
=================================================================================================================

SCOPE: Applies to all broker adapters and the accounting/ledger subsystem.  
PURPOSE: To enable one-click, auditable, double-entry-compliant broker transaction import, sync, and reconciliation for all supported brokers (Alpaca, IBKR, etc), and to guarantee ledger integrity for tax/audit/compliance.

-------------------------------------------------------------------------------
1. BROKER SYNC: FUNCTIONAL OVERVIEW
-------------------------------------------------------------------------------
- *Objective:* 
  - Download all available trades/fills and cash transactions for the active bot broker account.
  - Import and reconcile each transaction into the bot ledger DB (`trades` and/or `ledger_entries`).
  - Mark/reconcile each matched trade; log and alert on all mismatches or missing entries.
  - Ensure idempotency: re-syncs do not create duplicates, and all broker-side updates (cancels, corrections, reversals) are reflected.

-------------------------------------------------------------------------------
2. SYSTEM COMPONENTS AND ROLES
-------------------------------------------------------------------------------
- **A. Broker Adapter (`broker_api.BrokerAdapter` + plugins):**
    - Must implement:
      - `fetch_all_trades(start_date, end_date=None) -> List[dict]`
      - `fetch_cash_activity(start_date, end_date=None) -> List[dict]`
    - Each returned dict must include all standard fields: trade_id, symbol, action, qty, price, fee/fees, datetime, status, etc.
    - **Adapters must fully handle broker-side pagination, continuation tokens, and API rate limits (retry, exponential backoff, etc).** All available historical data for the requested window must be fetched, regardless of result count or server paging.
    - All syncs must log which API credential was used (or a hash thereof) with each sync event for audit and debugging.

- **B. Sync Orchestrator (`sync_broker_ledger`):**
    - Calls the above plugin functions.
    - Deduplicates via unique trade_id.
    - Maps and upserts into the bot ledger tables.
    - Logs all actions to `audit_trail` and `reconciliation_log`.
    - Sync operations may be triggered manually via web UI, or scheduled for automatic execution (e.g., nightly). The default implementation must support both, with all logs/audit entries identical regardless of trigger method.
    - **All sync/exported artifacts (logs, audit records, reconciliation files) must be versioned with schema and export version.**

- **C. Reconciliation Engine:**
    - Scans bot ledger for all trades within the broker’s returned range.
    - For every broker trade:
        - If trade_id exists in ledger, mark as "ok" and update as needed.
        - If missing, import as "broker-only" (mismatch, requires review).
        - If in ledger but not in broker export, flag as "local-only" (potential error, requires review).
    - **All reconciliation results are written to the `reconciliation_log` table, which must include at minimum:**  
      `trade_id`, `status` (`ok`, `mismatch`, `local-only`, `broker-only`, `resolved`), `compare_fields` (summary of compared fields and any differences), `sync_run_id`, `timestamp_utc`, and a cryptographic hash of the broker-provided record for provenance.
    - **If broker APIs return pending/incomplete trades (e.g., partial/late/processing), such entries are imported as "pending" and flagged for later sync. Status is updated when final.**

- **D. COA Mapping Table System:**
    - Maintains a dynamic COA mapping table for all imported broker transactions.
    - For any unmapped/ambiguous transaction type or detail, the admin may assign the correct COA category via the web UI.
    - All manual assignments immediately update the mapping table, so future matching transactions are auto-allocated.
    - Mapping keys may use broker fields (e.g., action, subtype, description, etc).
    - Every assignment/change is audit-logged with user and timestamp.
    - Mapping table is admin-editable, exportable/importable, and auto-extends as new transaction types appear.
    - All unmapped/ambiguous transactions are flagged and queued for admin review.
    - Over time, the system "learns" optimal GL/COA allocations, minimizing manual intervention and maximizing auditability.
    - **All changes to mapping rules create a new version or snapshot for rollback/audit.**
    - **Every mapping table version is uniquely versioned and exportable for external audit, and old versions are retained for at least 7 years or as required by law.**

- **E. Log and Artifact Retention:**
    - All sync logs, reconciliation logs, audit records, and mapping table versions are retained and/or archived for a minimum of seven years, or as required by law.
    - Policy for archiving or purging old reconciliation and sync logs: logs older than the retention window may be moved to encrypted cold storage but must not be destroyed.

-------------------------------------------------------------------------------
3. TRANSACTION & FIELD MAPPING
-------------------------------------------------------------------------------
- **Alpaca (example):**
    - API: `GET /v2/orders` and `GET /v2/account/activities`
    - Map:
        - trade_id/order_id → trade_id
        - symbol            → symbol
        - side              → action ("buy"/"sell" → "long"/"short", etc)
        - filled_qty        → quantity
        - filled_avg_price  → price
        - filled_at         → datetime_utc
        - filled_fee        → fee/fees (if available)
        - status            → status ("filled", "cancelled", etc)
    - All cash activity (deposits, withdrawals, dividends, fees) are mapped to corresponding action/account in ledger.
    - **All broker-provided timestamps must be stored both as UTC (`datetime_utc`) and the original broker-reported local/exchange time, in `json_metadata`.**

- **Fees Handling:**
    - Always extract both `fee` and `fees` fields, map to bot schema (see existing robust fee/fees logic).
    - Commission/fee breakdowns (if available) are stored in json_metadata for audit.

- **Partial Fills & Corrections:**
    - All trades with partial fills must be aggregated under the original trade_id unless the broker’s system issues unique IDs for each fill (in which case each is imported as a unique record, with parent linkage noted in metadata).
    - Corrections/amendments and broker-side cancels must always update the status and details in the bot ledger and be audit-logged as such.

- **Required/Optional Fields:**
    - trade_id (required, unique)
    - symbol, action, quantity, price, total_value, fee/fees, datetime_utc, status
    - All other broker-provided metadata stored in `json_metadata`.
    - If available, each imported record should store a hash or signature of the raw broker API response for forensic traceability.

-------------------------------------------------------------------------------
4. SYNC WORKFLOW (PSEUDOCODE)
-------------------------------------------------------------------------------

def sync_broker_ledger(start_date=None, end_date=None):
# 1. Load broker adapter
broker = get_active_broker()
# 2. Define sync range (default: last 30 days)
if not start_date: start_date = now() - timedelta(days=30)
# 3. Fetch all broker trades and cash activity (with paging, rate-limit/backoff, etc)
trades = broker.fetch_all_trades(start_date, end_date)
cash_activity = broker.fetch_cash_activity(start_date, end_date)
# 4. Merge all (for unified processing)
all_records = trades + cash_activity
# 5. For each record:
for rec in all_records:
    trade_id = rec["trade_id"]
    # 5a. Check if trade_id exists in ledger
    existing = lookup_ledger_entry_by_trade_id(trade_id)
    if existing:
        # Compare all key fields (action, qty, price, fee, etc)
        if not entries_equal(existing, rec):
            # Update ledger with latest broker info
            update_ledger_entry(existing["id"], rec)
            log_audit("updated", trade_id)
        else:
            continue
    else:
        # Insert as new entry (status: ok/mismatch)
        insert_ledger_entry(rec)
        log_audit("imported", trade_id)
# 6. Flag ledger-only trades (not in broker export) as "local-only"
for entry in ledger_entries_in_range(start_date, end_date):
    if entry["trade_id"] not in [r["trade_id"] for r in all_records]:
        flag_entry_as_local_only(entry)
# 7. Update reconciliation_log
update_reconciliation_log(start_date, end_date)
# 8. Write summary to sync_broker_ledger.log, flash user

-------------------------------------------------------------------------------
5. ERROR HANDLING AND AUDITABILITY
-------------------------------------------------------------------------------
- **All syncs are fully logged:** Every import/update/deletion goes to `audit_trail`.
- **All API failures:** Retried N times, then logged with error status.
- **All mismatches:** User notified on next web UI load.
- **Ledger-only/broker-only discrepancies:** Must be cleared by admin, with audit log.
- **Every sync and each imported broker record must log the credential used, sync_run_id, and broker-side data provenance (API response hash).**
- **All logs, audit records, reconciliation files, and mapping table versions are versioned and retained for a minimum of seven years or as required by law. Pending/incomplete syncs are flagged for follow-up and not purged.**

-------------------------------------------------------------------------------
6. WEB UI REQUIREMENTS
-------------------------------------------------------------------------------
- **Ledger Page (ledger.html):**
    - "Sync Broker Ledger" button triggers `/ledger/sync` (POST), calls `sync_broker_ledger()`.
    - After sync: page reloads, shows new/updated trades, flags mismatches.
    - Status column indicates: "ok", "mismatch", "local-only", "broker-only", "resolved".
    - Admins may resolve, update, or delete entries as needed.
    - All reconciliation log entries must be queryable and exportable for compliance review.
    - **COA mapping assignments and mapping table are fully manageable via the UI, with flagged unmapped transactions and history/audit log per change.**
    - **Any change to COA mapping rules automatically snapshots the mapping table for rollback/versioning, and all versions are exportable for external audit.**
    - **Pending/incomplete broker transactions and related sync log entries are clearly indicated, with follow-up workflow for resolution.**
    - **UI provides version and schema metadata for all exports and artifacts.**

-------------------------------------------------------------------------------
7. IDENTITY & SECURITY
-------------------------------------------------------------------------------
- All sync operations require:
    - Completed provisioning and identity validation.
    - Only admin users can initiate sync.
    - All credential/API key use is logged with each sync event.

-------------------------------------------------------------------------------
8. EXTENSIBILITY
-------------------------------------------------------------------------------
- New broker plugins must implement required fetch functions and mapping logic.
- Field mapping/normalization must be maintained per-broker.
- Schema updates: new fields must be stored in `json_metadata` if not in core schema.
- All adapters must implement robust pagination, rate-limiting, and full historical data retrieval for all fetch functions.
- **COA mapping table must support live extension, admin export/import, auto-learning from ledger-edited transactions, and immutable versioning of all mapping rules for compliance rollback/audit.**
- **Automated and manual edits to COA mapping must be integrated in integration/regression tests.**
- **Test artifacts and mapping tables are versioned and retained as per retention policy.**

-------------------------------------------------------------------------------
9. TESTING & COMPLIANCE
-------------------------------------------------------------------------------
- Automated tests must verify:
    - All broker trades are present after sync.
    - No duplicate trade_id exists.
    - Ledger remains double-entry compliant.
    - All discrepancies are flagged and auditable.
    - Pagination, rate-limit handling, and partial fill/correction logic is verified in test coverage.
    - Reconciliation log is populated as per schema.
    - **COA mapping logic is covered in integration/regression tests; test suite must simulate ambiguous transactions and verify mapping table updates, versioning, and audit log accuracy.**
    - **Test suite must include mock/fuzzed broker data for nonstandard and new broker plugins, as well as mapping table edge-case regression.**
    - **Automated tests must include schema/export version handling, artifact retention, and follow-up of pending/incomplete transactions and logs.**

-------------------------------------------------------------------------------
10. VERSIONING AND DATA RETENTION
-------------------------------------------------------------------------------
- **All exported artifacts, logs, mapping tables, and reconciliation logs are versioned with schema/export version, and previous versions are retained for no less than 7 years (or as required by law).**
- **Archival policy must support encrypted cold storage for all artifacts/logs older than the retention window, and no destruction of audit material is allowed without explicit regulatory clearance.**
- **Artifacts must be tagged with version metadata in both filenames and file contents.**
- **All audit/retention/archive logic is to be included in regression and compliance testing.**

================================================================================
