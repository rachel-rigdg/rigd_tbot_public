================================================================================
Document: 030
Trading_Bot_Core_Specs
Version: v047
Date: UTC:2025-07-19 00:00:00
================================================================================

This module details the core infrastructure, risk controls, trading strategy logic, and instrument integrations for the RIGD Trading Bot system.

Contents:
- RIGD Trading Bot – Infrastructure and Deployment Overhaul Instructions (UPDATED)
- Unified Capital Risk Controls and Dynamic Broker Float Allocation
- TradeBot Strategy Logic Spec v1.1 (Self-Contained)
- InverseETF Integration Specification (Final v1.0)

All risk, allocation, and execution logic is governed *exclusively* by the deployed environment and `.env_bot` configuration.

{BOT_IDENTITY} = {ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}


================================================================================
RIGD Trading Bot – Infrastructure and Deployment Overhaul Instructions (UPDATED)
================================================================================

- **Objective:** Deploy on DigitalOcean (Premium AMD, Ubuntu 22.04+, systemd, secure, UTC standard).
- **PHASE 1:** Provisioned: nyc3, 2 vCPU, 4GB RAM, 80GB NVMe, Ubuntu 22.04, user `tbot`, SSH key, DNS/firewall active, no provider backups.
- **PHASE 2:** Hardened:
  - User: `tbot`
  - Root/SSH password disabled
  - fail2ban active
  - UFW configured
  - Auto-updates enabled
  - System timezone set to UTC
  - Python 3.10+ (3.11+ preferred)
  - pip, venv, sqlite3, rsync, curl, git installed
  - All working directories and virtual environments set up
- **PHASE 3:** Systemd Integration:
  - `/etc/systemd/system/` contains:
    - `tbot.target` (parent target for coordinated lifecycle)
    - `tbot-open.service` (9:30–9:50 UTC)
    - `tbot-mid.service` (12:00–12:30 UTC)
    - `tbot-close.service` (15:45–16:00 UTC)
    - `tbot-monitor.service` (trailing stop, runtime health check)
    - `tbot-backup.service` + `.timer` (scheduled backup/rotation)
    - `tbot-sync.service` + optional `.timer` (accounting sync)
  - All services run as `tbot` user
  - `Restart=on-failure` enforced
  - `WorkingDirectory` set to project root (e.g., `~/rigd_tbot`)
  - `ExecStart` points to proper entry script (never Flask web, never manual)
  - Logs routed to journald and to `/logs/` as per bot policy
  - `/etc/tbot.env` (optional) for non-secrets environment overrides
  - All timers use `OnCalendar=`, `Persistent=true` for reliability
- **PHASE 4:** Logging/Backups:
  - Script: `~/rigdtb/scripts/backup_bot_to_iceland.sh` compresses logs, SQLite ledgers, configs, pushes to remote DR/backup; prunes archives >7 days old.
  - (Optional) Mirror to `/mnt/shared` or DR storage; verify archive consistency
- **PHASE 5:** Validation:
  - Use `systemctl list-timers` and `status tbot.target` to confirm operations
  - Simulate session and backup triggers; verify archive output
  - Simulate crash/kill and auto-restart; verify end-to-end continuity
- **Critical:**
  - *All bot operations must be controlled exclusively via systemd*—no manual launches, no cron, no root SSH.
  - All logs/backups must be fail-safe and non-blocking
  - System clocks, logs, ledgers must be UTC

================================================================================
Unified Capital Risk Controls and Dynamic Broker Float Allocation
================================================================================

**Overview:**  
TradeBot enforces dynamic float allocation and strict per-session risk controls for each trading window (OPEN, MID, CLOSE).  
**All thresholds and limits are sourced from `.env_bot` via the Web UI—no hardcoded limits or overrides.**

**Risk per Strategy Session (TOTAL_ALLOCATION):**  
- Max session risk: `broker_current_float * TOTAL_ALLOCATION` (configurable)
- Per-trade allocation split by `WEIGHTS` (must match `MAX_TRADES`)

**Allocations Example:**  
- 1 signal → 100%  
- 2 signals → 60%, 40%  
- 3 signals → 40%, 30%, 30%  
- 4 signals → 40%, 20%, 20%, 20%  
- If Broker Float = $2,500, TOTAL_ALLOCATION = 0.02 → Session cap = $50

**MAX_OPEN_POSITIONS / MAX_TRADES:**  
- `MAX_TRADES`: per-session entry count  
- `MAX_OPEN_POSITIONS`: system-wide cap (across strategies)

**WEIGHTS:**  
- List, length equals `MAX_TRADES`; sourced from `.env_bot`

**DAILY_LOSS_LIMIT:**  
- Trading halts if `realized_loss > broker_current_float * DAILY_LOSS_LIMIT`  
- Halting enforced in `kill_switch.py`

**Ledger/Accounting:**  
- Bot reads float/config at session start only; never moves float at runtime.
- Float adjustments/reconciliations are operator tasks, never bot runtime.
- Ledgers and trade logs are generated locally.

**Rebalancing:**  
- Bot monitors float for deviation triggers (`REBALANCE_TRIGGER_PCT`).
- If deviation breached, logs operator notification—bot never manages float or rebalancing.

**Scaling:**  
- All risk caps and allocations scale with broker float.
- Only adjustable via `.env_bot` (Web UI).

**Enforcement Modules:**  
- `risk_bot.py`: enforces all risk/session/trade limits from config
- `kill_switch.py`: enforces DAILY_LOSS_LIMIT
- `watchdog_bot.py`: halts trading if API/system is unstable

**Test/Live:**  
- *All controls are identical in test/live.*
- **No manual overrides** except via `.env_bot` (Web UI).


================================================================================
Automated Holdings, Float, and Reserve Management
================================================================================

The RIGD Trading Bot now implements a fully automated, audit-compliant holdings management system responsible for all float, tax, payroll, and long-term portfolio allocations.

- **Scope:**  
  All cash float targets, tax reserve funding, payroll allocations, and periodic portfolio rebalancing are managed by the holdings management module. This system replaces all operator/manual float management, automating nightly (post-open) and scheduled (rebalance) adjustments.
  - **All reserve, float, and allocation actions are strictly audit-logged with full double-entry COA and immutable audit trail, including user, timestamp (UTC), action, and before/after values.**
  - **Once tax or payroll reserves are allocated, they can never be reduced or repurposed for trading or float, except by explicit manual override, which requires a mandatory audit rationale and user tracking.**

- **Configuration and Persistence:**  
  - Allocation settings, securities list, and target percentages are configured exclusively via the Web UI and persisted in an encrypted holdings secrets file (`storage/secrets/holdings_config.json.enc`), not `.env_bot.enc`.
  - `.env_bot.enc` contains only the pointer and enablement flag for holdings management; it does not store allocation or securities data.
  - **All changes to holdings config trigger a secrets file backup and persistent audit entry. Environment variables are never the primary source of truth.**

- **Float, Tax, and Payroll Reserves:**  
  - Float Target %, Tax Reserve %, and Payroll % are enforced and maintained automatically.
  - After each trading day’s open session, realized gains are split per configured percentages and posted to the correct COA/ledger accounts and audit trail.
  - Float top-ups (security sales to restore float) result in tax reserve allocations on any realized gain, but never payroll allocations. Losses result in no reserve.
  - Payroll allocations are applied only to post-tax realized gains from trading bot activities (never float sales or losses).
  - **Allocated tax and payroll reserves are never reduced or clawed back in drawdowns.**
  - All float/cash shortfalls or overages are resolved via automated security sales/purchases, with complete audit trail.

- **Portfolio Rebalancing:**  
  - Long-term holdings are rebalanced according to user-defined intervals (3, 6, 12 months) or on manual trigger from the UI.
  - Rebalance logic supports explicit and blank allocation fields—any blank allocation symbols receive equal split of the remainder.
  - All buy/sell transactions are double-entry compliant and posted to the ledger with audit metadata.
  - **System must block any config, split, or rebalance if it would violate compliance (float, reserve, or allocation). All actions are previewed and simulated before commit, and noncompliant actions are not performed.**

- **Compliance, Audit, and UI:**  
  - The system blocks configuration or rebalance if any allocations, splits, or reserve settings are out of compliance.
  - “Preview”/simulation of all rebalance actions is available before commit, and every step is immutably logged and exportable.
  - The management UI presents live status, current allocations, and compliance warnings in real time.
  - **Automated tests and simulations must cover normal, edge, and error states for float, reserve, allocation, and compliance logic, as well as audit logging.**

- **Integration:**  
  - The holdings management module works alongside and independently of the trading strategy modules. It interfaces with broker APIs for order execution and posts all ledger entries using the updated chart of accounts.
  - All risk controls, float splits, and reserve logic are now automated and cannot be overridden manually via CLI or external config.

**See:**  
- `Long-Term Holdings Management Module Specification` for complete logic, workflow, and configuration requirements.
- `tbot_bot/trading/holdings_manager.py` and `tbot_bot/support/holdings_secrets.py` for implementation details.
- `tbot_web/templates/holdings.html` for UI/UX structure and compliance features.





=============================================================================================================================================
TradeBot Strategy Logic Spec v1.1 (Updated for Accounting System Integration)
=============================================================================================================================================

**Overview:**  
TBot executes intraday breakout and mean-reversion strategies using a unified logic pipeline. All trade entries are directional and follow structured risk, time, and allocation parameters as defined in `.env_bot`. All parameters, filters, and toggles must be dynamically sourced—no hardcoded logic.

**Supported Instruments:**  
- Long equity (common stocks or ETFs)
- Inverse ETFs (e.g., SH, SQQQ)
- Long puts (IBKR only)

**Trade Direction Rules:**  
- Long trades: Supported on all brokers
- Bearish trades: Executed only if corresponding `SHORT_TYPE_*` is not `disabled`
- Puts: Used only if broker is IBKR and `SHORT_TYPE_* = LongPut`
- Inverse ETFs: Used for non-options brokers when `SHORT_TYPE_* = InverseETF`

**Supported Brokers:**  
- Alpaca: long equity, inverse ETFs
- IBKR: long equity, inverse ETFs, long puts
- Tradier: long equity, inverse ETFs

**Execution Framework:**  
- Strategy execution is sequenced via `STRATEGY_SEQUENCE` in `.env_bot`
- Each strategy module (`strategy_open.py`, `strategy_mid.py`, `strategy_close.py`) is loaded independently by `strategy_router.py`
- Runtime logic strictly observes UTC windows and `.env_bot` timing/config variables

**Ledger and Accounting Integration:**  
- **All trade activities, allocations, and PnL updates are written directly to:**
    - `output/ledgers/{ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_ledger.db`
- **All ledger entries** must comply with OFX schema:
    - Required fields: `TRNTYPE`, `DTPOSTED` (UTC), `FITID`, broker, strategy, ticker, side, size, entry_price, exit_price, PnL, and audit references.
- `.csv` or `.json` trade histories are external audit artifacts and not parsed for ledger ingestion.
- All reporting and reconciliation flow through the accounting system’s ingestion modules.

---

**Active Strategies:**

---------------------------------------------------------
Strategy: strategy_open.py – Opening Range Breakout
---------------------------------------------------------
- **Time Window:**
  - Start: `START_TIME_OPEN` (14:30 UTC = 9:30 AM EST)
  - Analysis: `OPEN_ANALYSIS_TIME` (minutes)
  - Breakout: `OPEN_BREAKOUT_TIME` (minutes)
  - Monitoring: `OPEN_MONITORING_TIME` (minutes)
- **Trade Direction:** Long by default; short only if `SHORT_TYPE_OPEN` ≠ `disabled`
- **Entry Logic:**
  - Track high/low during analysis window
  - Enter if price > high * (1 + `STRAT_OPEN_BUFFER`) or < low * (1 - `STRAT_OPEN_BUFFER`)
  - Entry must occur within breakout window
- **Exit Logic:** 2% trailing stop or monitoring timeout
- **Shorting:** Controlled by `SHORT_TYPE_OPEN`: InverseETF, LongPut, ShortSell, or disabled
- **Logging:**
  - Logs: `open.log`
  - Ledger: `output/ledgers/{ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_ledger.db`
  - Trade History: `output/trades/{ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_trade_history.csv/json`

---------------------------------------------------------
Strategy: strategy_mid.py – VWAP Mean Reversion
---------------------------------------------------------
- **Time Window:**
  - Start: `START_TIME_MID` (15:30 UTC = 10:30 AM EST)
  - Analysis: `MID_ANALYSIS_TIME` (minutes)
  - Breakout: `MID_BREAKOUT_TIME` (minutes)
  - Monitoring: `MID_MONITORING_TIME` (minutes)
- **Trade Direction:** Long or Bearish
- **Entry Logic:**
  - Enter on price deviation from VWAP ±`STRAT_MID_VWAP_THRESHOLD`
  - Confirm with ADX and Bollinger filters
  - Entry must be within breakout window
- **Exit Logic:** VWAP touch, 1.5% stop loss, or timeout
- **Shorting:** Controlled by `SHORT_TYPE_MID`: InverseETF, LongPut, ShortSell, or disabled
- **Enhancements:** `adx_filter.py`, `bollinger_confluence.py`
- **Logging:**
  - Logs: `mid.log`
  - Ledger: `output/ledgers/{ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_ledger.db`
  - Trade History: `output/trades/{ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_trade_history.csv/json`

---------------------------------------------------------
Strategy: strategy_close.py – End-of-Day Momentum / Fade
---------------------------------------------------------
- **Time Window:**
  - Start: `START_TIME_CLOSE` (19:30 UTC = 2:30 PM EST)
  - Analysis: `CLOSE_ANALYSIS_TIME` (minutes)
  - Breakout: `CLOSE_BREAKOUT_TIME` (minutes)
  - Monitoring: `CLOSE_MONITORING_TIME` (minutes)
- **Trade Direction:** Long or Bearish
- **Entry Logic:**
  - Enter on momentum continuation or spike reversal
  - Requires VIX > `STRAT_CLOSE_VIX_THRESHOLD`
  - Entry must be within breakout window
- **Exit Logic:** 2% stop loss or hard exit at session end
- **Shorting:** Controlled by `SHORT_TYPE_CLOSE`: InverseETF, LongPut, ShortSell, or disabled
- **Enhancements:** `vix_gatekeeper.py`, `imbalance_scanner_ibkr.py`, `ticker_blocklist.py`
- **Logging:**
  - Logs: `close.log`
  - Ledger: `output/ledgers/{ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_ledger.db`
  - Trade History: `output/trades/{ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_trade_history.csv/json`

---

**Strategy Failover Logic**
- Any `.self_check()` failure skips that strategy; all failures logged with UTC timestamp
- If `STRATEGY_OVERRIDE` is set (e.g., `mid`), only the specified strategy executes
- All execution strictly enforces:
  - `DISABLE_ALL_TRADES`
  - `DAILY_LOSS_LIMIT`
  - `MAX_OPEN_POSITIONS`
  - `TOTAL_ALLOCATION` and `WEIGHTS`
  - Broker status, float, and account restrictions
- All risk and execution constraints sourced dynamically from `.env_bot` (never hardcoded or inferred)


================================================================================
InverseETF Integration Specification (Final v1.0)
================================================================================

- *All ETF eligibility, logic, and lists are maintained and edited only via internal config and Web UI—never by external system or CLI utility.*
- No accounting system may inject, provision, or control ETF eligibility or strategy logic.


================================================================================
 Ranked Symbol Fallback and Fractional Trading Logic (v1.0)
================================================================================

**Overview:**
This section formalizes the unified, ranked fallback symbol selection and broker eligibility enforcement for all TradeBot strategies.  
ALL symbol eligibility, fallback, and fractional support logic must comply with this specification—no hardcoded or strategy-specific short-circuiting allowed.

--------------------------------------------------------------------------------
Ranked Candidate Pool and Fallback Logic (ALL STRATEGIES)
--------------------------------------------------------------------------------

- **Ranked Pool Sourcing:**
  - Each strategy (open/mid/close) requests a *ranked* candidate pool from its screener module.
  - **Pool size = MAX_TRADES × CANDIDATE_MULTIPLIER** (see `.env_bot`).
  - Ranking is by strategy fitness (momentum, volatility, filter score, etc.), *not* by broker eligibility or tradability.
  - Screeners do **not** check broker support or tradability; they only rank and return the full candidate pool.

- **Eligibility/Execution Filtering:**
  - Strategy or central router must query the broker module for each candidate (in ranked order):
    - Is the symbol tradable right now?
    - Does broker support fractional for this symbol (if FRACTIONAL=true)?
    - Is minimum order size met given the session’s capital and weight?
    - Any other broker/account restriction?
  - Select top N eligible candidates (`N = MAX_TRADES`).
  - If fewer than `MAX_TRADES` are eligible, skip, log the cause, and do not substitute lower-ranked symbols from outside the pool.

- **Fallback Cycling:**
  - If any selected symbol fails a runtime eligibility check (e.g., no fractional support, insufficient capital, rejected order), the next-ranked eligible symbol from the pool is automatically used as fallback for that slot.
  - Rejection causes must be logged with timestamp, rejected symbol, and reason.
  - UI and logs must indicate which fallback level was used for each trade.

- **Strategy/Router Enforcement:**
  - **No strategy module may pre-filter or short-circuit the pool by broker eligibility.**
  - All runtime checks must be after ranking and prior to order submission.
  - All final selection, fallback, and eligibility filtering must be broker-agnostic until the broker module is queried.

- **Broker Module Requirements:**
  - Must implement `supports_fractional(symbol)` and `get_min_order_size(symbol)`.
  - Must return true/false for fractional and minimum size eligibility (per symbol, per broker).

- **Order Handling:**
  - All trade orders must pass runtime broker eligibility and capital checks.
  - If a symbol is rejected at order stage (e.g., due to sudden broker restriction), cycle to next eligible fallback immediately.

--------------------------------------------------------------------------------
Parameters and Config (All in `.env_bot` Only)
--------------------------------------------------------------------------------

- `MAX_TRADES`: Number of trades per strategy session
- `CANDIDATE_MULTIPLIER`: How many fallback candidates to include (pool size = MAX_TRADES × CANDIDATE_MULTIPLIER)
- `FRACTIONAL`: Enable/disable fractional trade logic (if true, check per symbol)
- All other trade, capital, and eligibility limits as already documented.

--------------------------------------------------------------------------------
Logging and UI
--------------------------------------------------------------------------------

- All fallback selection, eligibility rejections, and trade status changes must be logged with full context (symbol, reason, pool rank, timestamp).
- Web UI must display the current ranked pool, fallback level in use, and rejection reasons for each trade attempt.

--------------------------------------------------------------------------------
Testing and Validation
--------------------------------------------------------------------------------

- Automated tests must fully cover: fallback cycling, fractional checks, minimum order size, and all capital constraints per strategy and broker module.
- Simulate all failure/rejection modes for fallback validation.

--------------------------------------------------------------------------------
NO EXCEPTIONS:
- No broker/capital/fractional logic in screener modules.
- No duplicate ranking, filtering, or fallback logic in multiple modules.
- All risk and eligibility logic is single-source-of-truth as above.

================================================================================



