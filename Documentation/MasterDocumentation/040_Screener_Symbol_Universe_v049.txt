================================================================================
Document: 040
Screener_Symbol_Universe
Version: v048
Date: UTC:2025-08-23 00:00:00
================================================================================
Overview:
--------------------------------------------------------------------------------
This document defines the unified, staged, and *fully free/low-cost data source* approach for building, caching, filtering, and consuming the symbol universe for all trading screeners in the RIGD TradeBot system. Incorporates:  
- Crash resilience  
- Real-time auditability  
- Robust disk-first design using unfiltered and filtered JSON universes  
- Staged API and blocklist workflow  
- "Free-first" data polling (when enabled by the operator)  
- Blocklist recovery/maintenance  
- Long-term stability  
- Fully modular data source integration with generic indexed credential storage, enabling multiple simultaneous providers with dedicated API keys and settings per provider.

All screener modules must source their eligible symbol list exclusively from the pre-filtered, pre-built universe file (`symbol_universe.json`). No screener may fetch global lists or build real-time universes at runtime.


# ===========================
# Section 1: Core Principles
# ===========================
1. **Single atomic universe file** (`symbol_universe.json`) is built per trading day and is the exclusive source for all screeners and strategies.
2. **Universe is built nightly** (post-market close, pre-market open), strictly from exchange-approved symbols (e.g., NYSE, NASDAQ, NYSE Arca), with full API-based validation, filtering, and no dependency on TXT/CSV lists.
3. **Provider selection is manual—no defaults:**
   - Providers for **Universe Build**, **Enrichment**, and **Trading** are selected explicitly via checkboxes in `/screener_credentials` (credentials control panel).
   - The system assumes **no default provider**.
   - **If zero providers are enabled for “Universe Build”, the orchestrator does _not_ fail.** It writes a minimal **waiting status** payload to `symbol_universe.json` and exits successfully:
     ```json
     {
       "status": "waiting_for_credentials",
       "counts": { "raw": 0, "unfiltered": 0, "partial": 0, "final": 0 },
       "build_timestamp_utc": "YYYY-MM-DDTHH:MM:SSZ"
     }
     ```
     Screeners must treat this as an **empty universe** and continue safely (no runtime symbol fetching). A sanitized audit entry is written.
4. **API quota minimization:**
   - All symbol fetching, enrichment, and filtering uses provider adapters selected in the credentials UI (e.g., Finnhub, IBKR, Yahoo/yfinance, etc.).
   - Operators may enable free/delayed APIs and/or paid feeds; priority is only as explicitly set in the UI.
5. **Blocklist-first, staged eligibility workflow:**
   - Blocklist checked before every fetch; if a symbol is blocklisted it is never fetched or enriched.
   - Symbols failing API lookups, pricing, or validation are atomically written to the blocklist file (`screener_blocklist.txt`) with UTC timestamp, provider, and failure reason.
   - All blocklist, unfiltered, partial, and final universe files are written atomically and support resumability after crash/interruption.
6. **No real-time symbol fetching at runtime:**
   - All screeners use the atomic, validated universe file for every session.
7. **Web UI actions ("Force Rebuild", "Re-filter", "Update Blocklist")** can be triggered any time and log progress/audit events.
8. **Crash-resilient, disk-first design:**
   - All in-progress files are atomically updated. Universe build resumes from partial/unfiltered file as needed.
9. **Credential usage and all mutations are fully audit-logged and require admin rights.**
10. **All filesystem paths are resolved via `tbot_bot/support/path_resolver.py`**—no hardcoded paths.


# ================================================
# Section 2: Universe Construction & Blocklist Workflow
# ================================================
1. **Universe Build (nightly or forced):**
   - Load all candidate symbols from the provider(s) **explicitly enabled for “Universe Build”** in the credentials UI into `symbol_universe.symbols_raw.json` (NDJSON).
   - For each symbol in `symbol_universe.symbols_raw.json`:
     a. If symbol is present in `screener_blocklist.txt`, skip all processing for that symbol (no API call, no write).  
     b. Attempt to fetch all required and up-to-date data for the symbol via the enabled provider API(s).  
     c. If fetch fails or required data is missing or invalid:
        - Write symbol, with failure reason, UTC timestamp, and provider, to `screener_blocklist.txt`.
        - Do **not** write this symbol to any universe file.
        - Continue to next symbol.
     d. If all required data present:
        - Write symbol (with all fields, including passthrough such as exchange, sector, volume, etc.) to `symbol_universe.unfiltered.json`.
        - Immediately apply all filter criteria using **only** the centralized helpers in `screener_filter.py`:
           - If the symbol passes the filter: write to `symbol_universe.partial.json`.
           - If the symbol fails the filter: do **not** write to `partial.json` (but always write to `unfiltered.json`).
   - **Intermediate file format support:** `unfiltered.json` and `partial.json` may be written as **NDJSON (one JSON object per line)** _or_ as a **single JSON array**. Both formats are fully supported by the re-filter step and publisher.
   - **Final publish:** The orchestrator reads the filtered set, injects `build_timestamp_utc`, and **atomically publishes** `symbol_universe.json` using temp → flush/fsync → `os.replace` (best-effort directory fsync).

2. **Zero providers enabled for “Universe Build” (waiting state):**
   - The orchestrator **writes the waiting status payload** shown in Section 1 and exits successfully; screeners treat this as an empty universe. An audit entry is written.

3. **Blocklist Maintenance:**
   - Blocklist (`screener_blocklist.txt`) is updated **only** during the nightly build step when a symbol fails data/validation.
   - Blocklist is **not** used or updated by the manual **re-filter** step.
   - Scheduled recovery polling (e.g., weekends) may re-check blocklisted symbols; recovered symbols may be unblocked for the next build (audit-logged).

4. **Atomic file policy (enforced):**
   - All writes to universe and blocklist files are atomic (temp write → fsync → atomic replace). No partial build overwrites a valid file.


--------------------------------------------------------------------------------
Section 3: File/Script Layout & Responsibilities
--------------------------------------------------------------------------------

- `symbol_universe.unfiltered.json`  
  **Format:** NDJSON **or** JSON array.  
  Contains all successfully fetched symbols with full metadata from enabled provider(s). Never includes entries with missing/invalid required fields. Written before filtering; blocklisted symbols are excluded up front.

- `symbol_universe.partial.json`:  
  The filtered universe file.  
  Every symbol that passes all filter criteria (symbol present, last close and market cap present and within config bounds; all other fields are passthrough) is appended here immediately after filtering.  
  No exchange filtering; deduplication is enforced.

- `symbol_universe.json`:  
  FINAL atomic production symbol universe.  
  Upon build/re-filter completion, `symbol_universe.partial.json` is atomically copied or renamed to `symbol_universe.json`.  
  This file is the *only* source for all screeners, strategies, and runtime operations for the trading day.  
  **Consumers must accept either of the following schemas:**
  - **Normal (filtered symbols present):**
    ```json
    {
      "symbols": [ /* filtered symbol objects */ ],
      "build_timestamp_utc": "YYYY-MM-DDTHH:MM:SSZ"
    }
    ```
  - **Waiting state (no providers enabled):**
    ```json
    {
      "status": "waiting_for_credentials",
      "counts": { "raw": 0, "unfiltered": 0, "partial": 0, "final": 0 },
      "build_timestamp_utc": "YYYY-MM-DDTHH:MM:SSZ"
    }
    ```


- `screener_blocklist.txt`:  
  Master blocklist file (TXT, one line per entry, pipe-delimited):  
  `SYMBOL|reason|UTC timestamp|provider`.  
  Any symbol rejected (due to missing data, failed API fetch, parse error, invalid field, etc.) is written here immediately.  
  Blocklist is **checked before any provider fetch** during nightly universe build; symbols present are skipped entirely.  
  Blocklist is *not* checked or updated during re-filter.

- `universe_ops.log`:  
  Audit log (UTF-8, line-oriented, JSON or plaintext) with a UTC timestamp for every significant action:  
  start/end of build, each provider fetch, symbol processed, symbol rejected, blocklist addition, error, resume event, completion, file rotation.  
  Used for detailed auditing, debugging, and crash diagnostics.

---

- `tbot_bot/screeners/universe_orchestrator.py`:  
  **Main entry-point orchestration script.**  
  Runs and coordinates the full symbol universe build process, including initialization, provider adapter setup based on UI flags, build progress tracking, and triggering `symbol_enrichment.py`.  
  Ensures correct execution order and crash-safe orchestration.
  Publishes `symbol_universe.json` atomically with `build_timestamp_utc`. If zero providers are enabled for **Universe Build**, publishes the **waiting state** payload and exits successfully (audit-logged).


- `tbot_bot/screeners/symbol_source_loader.py`:  
  **Symbol candidate loader and source selector.**  
  Loads all symbol candidates directly from the provider adapters **enabled for Universe Build** (never from TXT/CSV).  
  Handles provider selection logic, credential loading, error handling, normalization, and batch/stream interface to enrichment step.

- `tbot_bot/screeners/provider_registry.py`:  
  **Provider registry/dispatcher.**  
  Maps provider string (e.g., FINNHUB, IBKR, YAHOO) to the correct Python provider adapter class.  
  Handles dynamic dispatch and supports multi-provider/fallback operation.

- `tbot_bot/screeners/symbol_enrichment.py`:  
  **Universe enrichment and build module.**  
  For each provider symbol (from source loader):  
    - Checks blocklist before every fetch.  
    - Fetches full symbol metadata via the **enabled** provider API(s).  
    - On success, writes full symbol data to `unfiltered.json`.  
    - Immediately applies centralized filter logic (from `screener_filter.py`):  
      - If symbol passes, writes to `partial.json`.  
      - If fails, skips writing to `partial.json`.  
    - On data/fetch failure, writes symbol with reason/timestamp to `screener_blocklist.txt`.  
    - All file writes are atomic.  
    - Fully resumable.

- `tbot_bot/screeners/universe_refilter.py`:  
  **Universe re-filter script.**  
  - Reads ONLY from `symbol_universe.unfiltered.json`.  
  - NO API calls; NO blocklist usage.  
  - Applies *identical* filtering logic (from `screener_filter.py`), writing passing symbols to `partial.json`.  
  - At end, atomically copies `partial.json` to `symbol_universe.json`.  
  - No other files updated.

- `tbot_bot/screeners/screener_filter.py`:  
  **All filter/normalization logic.**  
  - Provides the ONLY source for symbol normalization and filtering.  
  - NO I/O, NO script entrypoint.  
  - Used by both build and re-filter scripts (always imported).

- `tbot_bot/screeners/screener_utils.py`:  
  **Utility module.**  
  Provides atomic file operations (append/merge), blocklist load/save helpers, deduplication, schema validation, drift detection, and JSON/text helpers.  
  Used by all build/runtime modules to guarantee file integrity/spec compliance.

- `tbot_bot/screeners/blocklist_manager.py`:  
  **Blocklist management and audit.**  
  Manages all blocklist CRUD operations (add/remove/update), archival/rotation, audit logging, and scheduled/manual blocklist recovery.  
  Maintains blocklist consistency across rebuilds.

- `tbot_bot/reporting/universe_logger.py`:  
  **Dedicated UTC logger (WORKER).**  
  Writes structured logs for all universe/blocklist/file ops, user actions, and errors. Launched by `main.py` only.

- `tbot_bot/screeners/universe_archiver.py`:  
  Automated archival, retention, restore, and rollback for all universes/blocklists.

- `tbot_bot/screeners/universe_diff.py`:  
  Diff/compare utility for any two universe/blocklist files (drift, audit, rollback, UI/API).

- `tbot_bot/screeners/universe_rebuild_cli.py`:  
  CLI tool to trigger universe/blocklist rebuild, validation, archival, manual recovery.

- `tbot_bot/screeners/universe_validation.py`:  
  Comprehensive validation/QA utility for schema, deduplication, field presence, and file integrity.

**PROVIDER INTERFACES AND ADAPTERS:**  
- `tbot_bot/screeners/provider_base.py`:  
  **Abstract base for all provider adapters:**  
  All adapters must implement `fetch_symbols` and `fetch_quotes`, be blocklist- and error-aware, and support credential injection.
- `tbot_bot/screeners/provider_registry.py`:  
  **Provider registry.**  
  Maps provider strings to adapter classes for dynamic selection.
- `tbot_bot/screeners/providers/`:  
  **Adapter implementations (API-only, enabled via UI checkboxes):**  
  - `finnhub_provider.py`  
  - `ibkr_provider.py`  
  - `yahoo_provider.py`  
  - `nasdaq_provider.py`  
  - `nyse_provider.py`

**CREDENTIALS AND SECRETS MANAGEMENT:**  
- `tbot_bot/support/secrets_manager.py`:  
  **Central, encrypted credential management.**  
  Handles atomic, audit-logged, secure credential load/save.

**WEB INTERFACE MODULES:**  
- `tbot_web/py/universe_web.py`:  
  **Web UI API endpoints/routes:**  
  Displays universe/blocklist status, triggers force rebuild and re-filter (by script only, never inline logic), manual blocklist update, audit log, and progress UI.

**FILE LOCATIONS/POLICY:**  
- All universe, blocklist, and ops files: `tbot_bot/output/screeners/`
- All provider/loader/build modules: `tbot_bot/screeners/` (adapters in `providers/`)
- All credentials: `tbot_bot/storage/secrets/screener_api.json.enc` (encrypted)
- Audit logs: `tbot_bot/output/screeners/universe_ops.log`, `tbot_bot/output/logs/screener_credentials_audit.log`

--------------------------------------------------------------------------------
Section 4: Web UI and User Actions
--------------------------------------------------------------------------------

1. **Web UI `/universe` displays:**
   - The `/universe` page must detect and display the **waiting state** of `symbol_universe.json` (i.e., `status == "waiting_for_credentials"`) with clear guidance to enable at least one provider for **Universe Build** in `/screener_credentials`. Screeners must treat this as an empty universe without triggering any runtime fetches.
   - Live, real-time counts and build status for all universe and blocklist files:  
     - `symbol_universe.unfiltered.json`
     - `symbol_universe.partial.json`
     - `symbol_universe.json`
     - `screener_blocklist.txt`
   - Four side-by-side, infinitely scrollable, sortable tables:  
     - **Unfiltered Universe**: all successfully fetched symbols with full metadata (before filtering)  
     - **Partial Universe**: all symbols currently passing filter (real-time build state)  
     - **Final Universe**: the production universe for next trading day (atomic copy of partial)  
     - **Blocklist**: all symbols excluded, with reason, UTC timestamp, and provider
   - Global search/filter box instantly searches across all tables and highlights matches
   - Inline display of checksums/hashes and record counts for every file for integrity verification
   - Prominent “Force Rebuild Universe”, “Re-filter”, and “Update Blocklist” buttons;  
     - **Force Rebuild**: triggers the backend universe build process (`symbol_enrichment.py`)  
     - **Re-filter**: triggers the backend re-filter process (`universe_refilter.py`) (NO inline filtering logic in UI or routes)  
     - **Update Blocklist**: triggers backend blocklist recovery/check
   - Each button shows real-time progress and error feedback (step-by-step log output from `universe_ops.log`)
   - Live heartbeat/progress logs (from `universe_ops.log`) auto-scroll in the UI, with pause/scroll features
   - Status banners/warnings for stale, incomplete, or corrupt files, with diagnostic links to audit logs
   - Modal dialogs for error review, progress, and confirmation of manual actions
   - File drag-and-drop/upload (admin only) for manual offline override/import with full audit trail

2. **Manual 'Re-filter' Action:**
   - When the “Re-filter” button is clicked, it triggers ONLY the backend script `tbot_bot/screeners/universe_refilter.py`
   - **No filtering logic is executed in the UI, Flask route, or blueprint**
   - The script reads `symbol_universe.unfiltered.json`, applies current filter parameters (via imported `screener_filter.py`), and produces a new `symbol_universe.partial.json`, then atomically replaces `symbol_universe.json`
   - Deduplication and field validation are enforced by the filtering helpers
   - Each re-filter action is audit-logged: user, UTC timestamp, parameters used, before/after file hashes, and symbol counts

3. **Manual 'Update Blocklist' Action:**
   - Initiates a blocklist recovery pass: re-checks every blocklisted symbol using any provider(s) **enabled for recovery** in the credentials UI (typically free/delayed sources)
   - If a symbol now passes criteria, it is removed from the blocklist and eligible for next build
   - All blocklist changes are audit-logged: user, UTC timestamp, old/new status, and action source
   - Supports “dry-run” and “full update” modes; dry-run previews actions without changing files

4. **Manual Add/Remove to Blocklist via UI:**
   - Admin users may add/remove symbols to/from the blocklist via the UI with an enforced reason/comment
   - Each manual change triggers atomic write, immediate blocklist update, and full audit log entry: user, UTC timestamp, symbol, action, justification, and source IP
   - UI visually marks manually blocklisted/unblocklisted symbols with a badge and audit log link

5. **Exporting Universe and Blocklist Files:**
   - All universe and blocklist files are exportable from the UI (CSV, JSON, TXT as appropriate)
   - Exported files include hash/checksum and file generation UTC timestamp in metadata
   - All export/download events are audit-logged: user, UTC timestamp, and destination (download, email, etc)

--------------------------------------------------------------------------------
Section 5: Validation & Maintenance
--------------------------------------------------------------------------------

1. **Validation of all universe and blocklist files prior to use:**
   - Every entry in `symbol_universe.unfiltered.json`, `symbol_universe.partial.json`, and `symbol_universe.json` must include all required fields: `symbol`, `exchange`, `lastClose`, and `marketCap`. No entry may be missing or have a null/empty required field.
   - Strict deduplication is enforced at every save/write operation; no symbol may appear more than once per file.
   - All universe and blocklist files must be valid, well-formed UTF-8 encoded JSON (for universe files) or plain UTF-8 text (for blocklist), with no placeholders, empty stubs, or null values.
   - Blocklist entries (in `screener_blocklist.txt`) must include: symbol, UTC timestamp, data source/provider, reason for blocklisting, and audit/action flags indicating automated/manual/blocklist recovery source.
   - Every file is validated before use; all validation errors, missing fields, bad encodings, deduplication failures, or anomalies are logged in `universe_ops.log` with full UTC timestamp, file path, error details, and recommended recovery steps.

2. **Automated test and QA utility scripts:**
   - Scripts and utilities validate schema compliance, record-level data integrity, filter correctness, deduplication, and credential completeness before any universe is used for trading.
   - Validation/test scripts run on-demand via CLI or as required preflight steps in all CI/CD and deployment pipelines.
   - Universe build fails immediately with clear logs if any required credential, data field, or configuration is missing, malformed, or does not meet the spec.

3. **Atomic save policy:**
   - All writes to `symbol_universe.unfiltered.json`, `symbol_universe.partial.json`, `symbol_universe.json`, and `screener_blocklist.txt` are atomic:
      - New/updated files are written to a temporary file first.
      - Upon successful write and validation, the temporary file is atomically renamed into place, replacing the old version.
      - No universe or blocklist file is ever overwritten or deleted on a failed write or validation.
      - All atomic file replace events are logged in `universe_ops.log` with timestamp, action, user (if via UI), and file hashes before/after.

4. **Update cadence and runtime immutability:**
   - Universe and blocklist files are only updated after market close, during designated maintenance windows, or via explicit manual triggers in the Web UI by authorized users.
   - Once trading has begun for the day, all runtime systems and strategies use only the fixed, validated `symbol_universe.json` for the session; **no runtime fetching or universe rebuilding is allowed** until the next scheduled overnight update or manual action.
   - Any attempt to update or rebuild the universe during active trading hours is blocked, logged, and raises an explicit alert in the Web UI.
   - All universe and blocklist file update events, including manual or automated triggers, are recorded in the audit log with timestamp, user/action, and before/after file stats.

5. **Final file schema check:**  
   `symbol_universe.json` must be one of:
   - An object with a `symbols` array and `build_timestamp_utc` string (normal case), **or**
   - An object with `status:"waiting_for_credentials"`, a `counts` object, and `build_timestamp_utc` string (waiting state).

6. **Intermediate format tolerance:**  
   Validators must accept **NDJSON or JSON array** for `unfiltered.json` and `partial.json`. Deduplication and required-field checks still apply.

--------------------------------------------------------------------------------
Section 6: API, Quota, and Performance Considerations
--------------------------------------------------------------------------------

1. **API keys, tokens, and secrets are always loaded exclusively from the central, encrypted credentials store (`tbot_bot/storage/secrets/screener_api.json.enc`).**
   - No API key, secret, or credential may ever be hardcoded, committed to source control, stored in environment variables, or written to plaintext disk at any time.
   - All credential access is logged with timestamp, user, and operation (never including secret values).

2. **Provider enablement/priority is UI-driven—no defaults:**  
   - The operator explicitly enables providers for Universe/Enrichment/Trading via checkboxes and sets priority order (when multiple are enabled).  
   - The system does not assume any default or implicit ordering.

3. **API calls for all providers are staged, throttled, and modular:**
   - Each provider specifies its own throttle interval to comply with published rate limits.
   - Batch calls are supported where available, otherwise looped, with full error handling for 429/503 and transient failures.
   - The entire universe build process is resumable: interrupted batches, incomplete files, or in-progress writes can safely resume without wasted quota or duplicate records.

4. **Atomic and incremental disk writes:**
   - All writes to universe and blocklist files are done incrementally, atomically, and in small batches to minimize data loss on crash or quota hit.
   - Resume on next build is always possible from any valid partial/unfiltered file, with no loss of previous progress.

5. **Blocklist recovery polling and routine refresh:**
   - Recovery of blocklisted tickers is performed only with provider(s) explicitly enabled for recovery in the UI (typically free/delayed sources to minimize cost).
   - All recovery actions are audit-logged, and recovered symbols are immediately queued for universe enrichment.

6. **Comprehensive error, quota, and performance logging:**
   - All API call failures, rate limit hits, quota exhaustions, unexpected provider responses, and recovery events are logged in detail to `universe_ops.log` with UTC timestamps, ticker context, batch, and error codes/messages.
   - Logs are used for audit, recovery, and QA validation.

7. **Modular and operator-configurable provider/data source priority:**
   - The priority/order of providers is configured via the UI.  
   - Providers can be swapped, disabled, or reordered without code changes or redeployment.

8. **Build interruption, recovery, and fallback:**
   - If all enabled sources fail or become unavailable, the system immediately falls back to the last fully validated universe build and halts further writes until recovery, logging detailed alerts and error context.

9. **Credential loading failures and fail-fast policy:**
   - Any failure to load or validate required credentials will abort the build step immediately with sanitized errors and audit entries.

10. **Centralized credential access and audit:**
    - All modules must use the single credential loader; no alternate sources are permitted.

11. **Performance best practices:**
    - Incremental progress, resumption, and batch error recovery must minimize risk of rate limit lockout or lost build progress.  
    - Tuning and throttle values are set per-provider and may be adjusted in the UI or config as needed.

--------------------------------------------------------------------------------
Section 7: Error Handling, Logging, and Recovery
--------------------------------------------------------------------------------

1. **All failures, API errors, provider exceptions, data anomalies, and quota issues are logged in full detail to `tbot_bot/output/screeners/universe_ops.log`.**
2. **No failed, partial, or incomplete universe or blocklist build ever overwrites existing valid files.**
3. **Manual and automated review, audit, and export of all universe, blocklist, and operational logs are fully supported through the Web UI.**
4. **Automated and planned notifications:** future enhancements for alerts/webhooks are logged and auditable.
5. **Audit logging of all critical and user actions:** all actions are tracked with user, UTC timestamp, reason, and context.
6. **All mutating operations from the Web UI perform atomic writes and record user/action context.**
7. **Credential failures abort immediately with sanitized errors and audit entries.**

--------------------------------------------------------------------------------
Section 8: Extensibility and Future-Proofing
--------------------------------------------------------------------------------

1. **Architecture supports:** multi-broker operation, plug-and-play adapters for free/paid/delayed/broker-native feeds, dynamic tradability/fractional checks, append-only audit history, and versioned schemas.
2. **Deployment/upgrade:** universes and blocklists are portable, snapshot-able, and exportable; credential management and schema evolution are versioned and secure.
3. **Provider-agnostic longevity:** the design is provider-agnostic (e.g., Finnhub-only today, IBKR feeds later) with hot-swappable adapters and no assumed defaults.  
   Failover preserves last-known-good universes without overwriting.

--------------------------------------------------------------------------------
Section 9: Dedicated Screener Source Credential Management
--------------------------------------------------------------------------------

**Purpose:**  
Centralize and strictly control all API keys, tokens, usernames, and passwords required for universe and screener symbol source providers (Finnhub, IBKR, Polygon, Yahoo, etc.) using a *dedicated, auditable, secure admin UI* and a single, encrypted secrets file.  
All provider credentials and usage flags are managed here—no credentials are allowed in environment variables, .env files, or plaintext anywhere in the system.  
Credential management is tightly integrated with atomic updates, complete audit trails, strict role-based access, and real-time compliance validation.

**Specification:**

1. **Centralized Encrypted Credential File**  
   - Path: `tbot_bot/storage/secrets/screener_api.json.enc`
   - Contains all API keys, tokens, usernames, passwords, and provider usage flags for *all* symbol data sources, indexed using generic, incrementing keys (e.g. `PROVIDER_01`, `SCREENER_API_KEY_01`, ...), plus per-provider usage flags:  
     - `UNIVERSE_ENABLED_XX`, `ENRICHMENT_ENABLED_XX`, `TRADING_ENABLED_XX`
     - Optional `PRIORITY_XX` for ordering when multiple providers are enabled
   - File must be present and valid before any universe build, screener operation, or provider API call.  
   - No module, adapter, or loader may fetch credentials from environment, .env, or main config.

2. **Credential Management Admin UI**  
   - Route: `/screener_credentials` (admin only; strict RBAC enforced)
   - Operators **explicitly enable/disable** providers via checkboxes for Universe/Enrichment/Trading and may set priority order.  
   - All edits are validated and audit-logged; values are masked by default.

3. **Atomic Persistence, Encryption, and Backup**  
   - All changes are atomically written to `screener_api.json.enc` with encrypted, timestamped backups for rollback.  
   - No secret is ever written or transmitted unencrypted.

4. **Backend & Frontend Implementation**  
   - Backend: `tbot_web/py/screener_credentials_web.py`, `tbot_bot/support/secrets_manager.py` (+ audit logs).  
   - Frontend: `screener_credentials.html` + `screener_credentials.js` + `screener_credentials.css`.

5. **API Endpoints (Strict RBAC, Audit, and Security)**  
   - `GET /api/screener_credentials`, `POST /api/screener_credentials`, `DELETE /api/screener_credentials/<provider>`.

6. **Integration/Usage in Universe Build & Providers**  
   - All builders/adapters load credentials and role flags exclusively from the secure loader; build aborts if required roles lack enabled providers.

7. **Audit Logging, Compliance, and Recovery**  
   - All credential operations are audit-logged; encrypted backups maintain full rollback history.

8. **Deployment, Migration, and Onboarding**  
   - Encrypted example file is provided for onboarding; never commit secrets to VCS.

9. **Robustness and Security Best Practices**  
   - No plaintext secrets; RBAC required; rotation and backups are atomic and audited.

10. **No Deviation Policy**  
    - *No module may use credentials from any source except the secure loader and UI controls.*  
    - *No implicit defaults are assumed anywhere in this system.*

--------------------------------------------------------------------------------
Section 10: Credential Usage Best Practices, Security, and Maintenance
--------------------------------------------------------------------------------

1. **Fail-Fast and Sanitized Error Handling:**  
   - All screener, universe build, and provider modules must immediately abort operation and log a sanitized error message (never revealing secret values) if required credentials are missing, invalid, incomplete, or expired, to prevent silent failures or partial/corrupted universe builds.
   - Any credential loading or validation failure results in a hard stop and audit log entry with context, reason, and sanitized error.

2. **Testing and QA Integration:**  
   - Universe validation scripts and screener test utilities must verify the presence, validity, and completeness of all required credentials prior to any build, API call, or universe processing step.
   - Automated CI/CD tests must enforce credential completeness for all configured providers and usage flags, and must fail with clear, sanitized errors if any credential is missing or malformed.

3. **Credential Rotation and Expiration:**  
   - The credential management UI allows credential rotation for any provider and key, with automatic backup and archival of old credentials stamped with UTC timestamp for compliance and rollback.
   - Expiration dates and reminders should be tracked in the UI and audit log for each credential, and warnings displayed for credentials approaching or past expiration, minimizing risk of API downtime.

4. **Role-Based Access Control (RBAC):**  
   - Only users with explicit admin role (RBAC enforced) may access, add, edit, rotate, or delete screener credentials via the UI or API endpoints.
   - All credential management endpoints require strict authentication and RBAC authorization, with all user actions recorded in the audit log.

5. **Versioning and Schema Evolution:**  
   - The encrypted credential file is versioned, and schema migrations are supported to allow seamless upgrades, new provider fields, or format changes with zero data loss or downtime.
   - Schema-only example and migration utilities are maintained for onboarding, upgrades, and compliance.

6. **Automated Encrypted Backups and Recovery:**  
   - Every credential add/edit/delete/rotate operation triggers an automatic, encrypted backup of the previous credential file, stored with UTC timestamp and never exposing plaintext secrets.
   - Backups are stored in a secure location (`tbot_bot/storage/secrets/` or designated backup path) for audit, compliance, and full rollback capability in case of corruption, deletion, or credential loss.

7. **Audit Trail and Operational Transparency:**  
   - All credential operations (add, edit, delete, rotate, read, or failure) are fully audit logged with user, UTC timestamp, provider name, action type, and relevant context (never including the secret value itself).
   - The audit log is append-only and tamper-evident, stored at `tbot_bot/output/logs/screener_credentials_audit.log` and accessible for compliance and review by authorized personnel.

8. **Security Compliance and Best Practices:**  
   - API keys, secrets, passwords, and other sensitive data are never stored, transmitted, or logged in plaintext at any stage of the system, including during backups, exports, or validation.
   - All credential management processes and workflows strictly comply with organizational security policy, industry best practices, and all relevant regulatory requirements (such as GDPR, SOC2, etc.).
   - No credential may be committed to source control or exported unencrypted; all deployments require secure credential onboarding and validation before operation.
----------------------------------------------------------------------
Appendix A (xref): Trailing Stops (for clarity only, no screener change)
----------------------------------------------------------------------
Trailing stop logic is centralized in the trading layer (see **Document 030 – “Centralized Trailing Stop Logic (v2)”**).  
Screeners and the symbol-universe pipeline **do not implement or influence** trailing stops. No changes required here beyond this clarification.
