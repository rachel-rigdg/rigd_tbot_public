Document 02-rigd_tbot_Build Instructions_V023.txt


Please read and internalize all content in this thread. Acknowledge that you fully understand the Objective, System Instructions, and complete architecture of the system before proceeding. This session is part of an active build process and requires strict adherence to the documented structure and rules.


==============================
Objective (UPDATED)
==============================

TradeBot executes bi-directional trades using long equity for bullish signals and inverse ETFs or long puts for bearish signals, depending on SHORT_TYPE_* values in .env_bot. Brokers must support long equity and at least one bearish instrument (long put or inverse ETF).

The system runs intraday strategies in real time with fully automated, risk-weighted execution, operates headlessly without web/UI dependencies, and enforces all risk via .env_bot parameters (DAILY_LOSS_LIMIT, MAX_RISK_PER_TRADE, TOTAL_ALLOCATION, MAX_OPEN_POSITIONS, etc). All trade output is logged immutably to OFX-compliant SQLite ledgers.

The accounting system initializes the bot by injecting an entity-scoped ledger, bot-specific COA, encrypted config (.env_bot.enc decrypted with env.key), and broker/float/weight/override metadata. TradeBot does not manage float; all injections, reserves, and transfers are controlled externally by the accounting system.

Execution is toggled via ALPACA_ENABLED, IBKR_ENABLED, etc., and strategy toggles (STRAT_OPEN_ENABLED, STRAT_MID_ENABLED, STRAT_CLOSE_ENABLED). All trades must write to {ENTITY_CODE}_{JURISDICTION_CODE}_{account_name}_{BROKER_CODE}_{BOT_ID}_BOT_ledger.db, with ledger paths injected by the accounting system — never hardcoded or inferred by the bot.

PnL, float tracking, and revenue movements are recorded via the accounting ingestion system. TEST_MODE is deprecated; testing is done via tbot_bot/test/ modules only.

==============================
System Instructions 
==============================

These instructions apply to all TradeBot build and debugging sessions. This section excludes directives already enforced by the global 8-step procedure.

1. All environment-specific values must be sourced from `.env`, `.env_enc`, `.env_bot`, or `.env_bot.enc`.
   - No hardcoded API keys, thresholds, credentials, toggles, file paths, or mode flags.
   - `DISABLED ≠ OMITTED` — all conditional logic must explicitly evaluate suppressed states.

2. Inline comments are mandatory in all generated code.
   - All logic branches, `.env_bot` references, and condition paths must be explained clearly.

3. All file paths must be relative and platform-agnostic.
   - Code must run unmodified across macOS, Linux, and production servers (e.g., DigitalOcean).

4. Ledger routing:
   - All trade activity must write to the accounting system’s OFX-compliant, entity-scoped SQLite ledger.
   - Ledger filenames must follow:
     `{ENTITY_CODE}_{JURISDICTION_CODE}_{account_name}_{BROKER_CODE}_{BOT_ID}_BOT_ledger.db`
   - Ledger path is injected by the accounting system — the bot must never determine it independently.
   - All ledger writes are preceded by a backup.
   - Test modules under `tbot_bot/test/` may simulate trade placement but **must never** alter or bypass production ledger logic.

5. No re-ingestion of `.csv` or `.json` logs is permitted.
   - These are external audit artifacts only — not transactional inputs.

6. Every strategy module must implement a `.self_check()` method.
   - `main.py` must halt execution if any `.self_check()` fails.
   - Failures must log: strategy, reason, and error context with UTC timestamp.

7. `env_bot.py` must validate all required keys from `.env_bot.enc`.
   - Decryption must use `storage/keys/env.key`.
   - Missing or malformed keys must raise a fatal, human-readable startup error.

8. Logs and ledger outputs must include:
   - `timestamp`, `strategy_name`, `ticker`, `side`, `size`
   - `entry_price`, `exit_price`, `PnL`
   - `broker`, `error_code` (if applicable)
   - All logs must follow the global `LOG_FORMAT` (CSV or JSON) from `.env_bot`.

9. `VERSION.md` is mandatory.
   - Must include version tag, structural changes, logic differences, and behavior deltas.

10. All modules must remain fully executable on their own.
    - Core logic (`tbot_bot/`) must never import from Flask or `tbot_web/`.
    - The web UI is optional and must not affect trading logic or risk behavior.

11. Strategy routing and broker enablement must be toggled exclusively via `.env_bot`:
    - `ALPACA_ENABLED`, `IBKR_ENABLED`
    - `STRAT_OPEN_ENABLED`, `STRAT_MID_ENABLED`, `STRAT_CLOSE_ENABLED`

12. Improvisation is forbidden.
    - Clarify ambiguities before code generation or modification.
    - Strictly enforce deterministic, auditable logic paths.



# ==============================
# .env / .env_enc – Top-Level Environment Configuration
# ==============================
# This file is parsed by tbot_bot/, tbot_web/, and related utility scripts.
# It references secure decryption keys only — no raw credentials are stored here.

# -----------------------------
# Core Environment Settings
# -----------------------------
ENVIRONMENT="production"             # production or development mode
LOCAL="true"                         # If running in local dev environment
CONTROL_DIR="control"
ENV_BOT_PATH=".env_bot"

# -----------------------------
# Server IP Binding (Moved to Encrypted Secrets)
# -----------------------------
# LOCAL_IP / REMOTE_IP / PORT values have been relocated to:
# storage/secrets/network_config.json.enc (decrypted at runtime)

# -----------------------------
# Encrypted Credential Keys
# -----------------------------
ENV_KEY_PATH="storage/keys/env.key"                     # Decrypts general bot config (.env_bot.enc)
LOGIN_KEY_PATH="storage/keys/login.key"                 # Decrypts hashed passwords, session tokens
BROKER_KEY_PATH="storage/keys/broker.key"               # Decrypts broker_credentials.json.enc
SMTP_KEY_PATH="storage/keys/smtp.key"                   # Decrypts smtp_credentials.json.enc
SCREENER_API_KEY_PATH="storage/keys/screener_api.key"   # Decrypts screener_api.json.enc
ACCT_API_KEY_PATH="storage/keys/acct_api.key"           # Decrypts acct_api_credentials.json.enc

# -----------------------------
# Encrypted Secrets (Resolved at Runtime)
# -----------------------------
BROKER_CREDENTIALS_PATH="storage/secrets/broker_credentials.json.enc"
SMTP_CREDENTIALS_PATH="storage/secrets/smtp_credentials.json.enc"
SCREENER_API_PATH="storage/secrets/screener_api.json.enc"
ACCT_API_CREDENTIALS_PATH="storage/secrets/acct_api_credentials.json.enc"
NETWORK_CONFIG_PATH="storage/secrets/network_config.json.enc"   # Decrypted to load IP/PORT values
ALERT_CHANNELS_PATH=storage/secrets/alert_channels.json.enc
ALERT_KEY_PATH=storage/keys/alert.key


# -----------------------------
# Session / Login Controls
# -----------------------------
SESSION_TIMEOUT="3000"               # Default: 3000 seconds (50 minutes)
LOGIN_ATTEMPT_LIMIT=10               # Max failed login attempts before lockout
LOGIN_LOCKOUT_MINUTES=15             # Lockout duration in minutes
SESSION_TIMEOUT_MINUTES=120          # Session expiration duration (minutes)

# -----------------------------
# Accounting Bot Key Reference (Deprecated)
# -----------------------------
# ENV_BOT_KEY is deprecated — replaced by ENV_KEY_PATH above
# ENV_BOT_KEY="..."




================================================================================
# .env_bot / env_bot.enc – Trading Bot Configuration File
================================================================================
# .env_bot – TradeBot Configuration v1.0.0+
# All strategy logic, broker routing, and runtime behavior are driven by this file.
# Time values are specified in UTC. Comments indicate usage and system impact.



# -----------------------------------------
# General & Debugging
# -----------------------------------------

# Version tag (must match VERSION.md)
VERSION_TAG=v1.0.0

# debug or release – sets internal behavior and logging verbosity
BUILD_MODE=release

# Master kill switch to block all trading activity
DISABLE_ALL_TRADES=false

# Logging level: quiet, info, or verbose
DEBUG_LOG_LEVEL=verbose

# Enable writing log files to /logs and /backups
ENABLE_LOGGING=true

# json (structured) or csv (flat) log output format
LOG_FORMAT=json

# -----------------------------------------
# Trade Execution & Risk Controls
# -----------------------------------------

# If true, bot will wait for manual confirmation before sending trades
TRADE_CONFIRMATION_REQUIRED=false

# Number of times to retry failed broker API calls      
API_RETRY_LIMIT=3

# how many seconds before timeout 
API_TIMEOUT=30

# Allow fractional shares (broker must support)
FRACTIONAL=true

# Total capital allocated per strategy session (e.g., 2% of account)
TOTAL_ALLOCATION=0.02

# Max number of trades allowed per strategy window
MAX_TRADES=4

# Trade weight percentages based on number of triggered trades
WEIGHTS=0.4,0.2,0.2,0.2

# Absolute loss limit (e.g., 5% of capital); triggers shutdown
DAILY_LOSS_LIMIT=0.05

# Maximum allocation per trade based on account value (2.5%)
MAX_RISK_PER_TRADE=0.025

# Cap on total simultaneous positions across all strategies
MAX_OPEN_POSITIONS=5                   

# -----------------------------------------
# Price & Volume Filters
# -----------------------------------------

# Minimum price allowed per trade
MIN_PRICE=5

# Maximum price allowed per trade
MAX_PRICE=100

# Minimum volume filter 
MIN_VOLUME_THRESHOLD=1000000       

# Finnhub Guard filter 
ENABLE_FUNNHUB_FUNDAMENTALS_FILTER=true

MAX_PE_RATIO=50

MAX_DEBT_EQUITY=2.5



# -----------------------------------------
# Strategy Routing & Broker Mode
# -----------------------------------------


# Broker Name (Options: ALPACA, IBKR, TRADIER, etc.)
BROKER_NAME="ALPACA"  


# Strategy run order; values: open, mid, close
STRATEGY_SEQUENCE=open,mid,close

# Optional: override normal order and run only one strategy
STRATEGY_OVERRIDE=

# -----------------------------------------
# Automated Rebalance Triggers
# -----------------------------------------

# Master toggle for automated rebalancing
REBALANCE_ENABLED=true     

# Trigger threshold (fractional, e.g., 0.10 = 10% deviation)              
REBALANCE_THRESHOLD=0.10     

# Check interval in seconds (default: 3600s = 1 hour)            
REBALANCE_CHECK_INTERVAL=3600           


# -----------------------------------------
# Failover Broker Routing
# -----------------------------------------

# Master toggle for failover routing
FAILOVER_ENABLED=true  
                  
# Tag applied to rerouted trades in logs/ledgers
FAILOVER_LOG_TAG=FAILOVER_ACTIVE         



# -----------------------------------------
# Global Time & Polling
# -----------------------------------------

# Days allowed for trading (UTC-based control logic)
TRADING_DAYS=mon,tue,wed,thu,fri

# Interval between polling cycles for runtime monitoring
SLEEP_TIME=1s

# -----------------------------------------
# OPEN Strategy Configuration (20 min trading)
# -----------------------------------------


# Maximum gap allowed from open to current price (used in screener)
MAX_GAP_PCT_OPEN=0.1

# Minimum and maximum market cap allowed for OPEN strategy candidates
MIN_MARKET_CAP_OPEN=2000000000
MAX_MARKET_CAP_OPEN=10000000000

# Enable or disable OPEN strategy
STRAT_OPEN_ENABLED=true

# UTC start time (market open = 9:30 AM EST)
START_TIME_OPEN=14:30

# Minutes to track high/low range before breakout
OPEN_ANALYSIS_TIME=20

# Minutes to for breakout to happen
OPEN_BREAKOUT_TIME=10

# Minutes to monitor active positions
OPEN_MONITORING_TIME=30

# Breakout threshold above high/low range (e.g., 2%)
STRAT_OPEN_BUFFER=0.02

# Shorting method: InverseETF, disabled, ShortSell, LongPut,
SHORT_TYPE_OPEN= InverseETF               

# -----------------------------------------
# MID Strategy Configuration (VWAP Reversion)
# -----------------------------------------

# Maximum gap allowed from open to current price (used in screener)
MAX_GAP_PCT_MID=0.1

# Minimum and maximum market cap allowed for MID strategy candidates
MIN_MARKET_CAP_MID=2000000000
MAX_MARKET_CAP_MID=10000000000


# Enable or disable MID strategy
STRAT_MID_ENABLED=true

# UTC start time (10:30 AM EST)
START_TIME_MID=15:30

# Minutes before trade signal is evaluated
MID_ANALYSIS_TIME=15

# Minutes to for breakout to happen
MID_BREAKOUT_TIME=10

# Maximum hold time after entry
MID_MONITORING_TIME=30

# VWAP deviation required to enter trade
STRAT_MID_VWAP_THRESHOLD=0.02

# Shorting method: InverseETF, ShortSell, LongPut,  or disabled
SHORT_TYPE_MID= InverseETF              

# -----------------------------------------
# CLOSE Strategy Configuration (EOD Momentum/Fade)
# -----------------------------------------

# Maximum gap allowed from open to current price (used in screener)
MAX_GAP_PCT_CLOSE=0.1

# Minimum and maximum market cap allowed for CLOSE strategy candidates
MIN_MARKET_CAP_CLOSE=2000000000
MAX_MARKET_CAP_CLOSE=10000000000


# Enable or disable CLOSE strategy
STRAT_CLOSE_ENABLED=true

# UTC start time (2:30 PM EST)
START_TIME_CLOSE=19:30

# Minutes to detect signal
CLOSE_ANALYSIS_TIME=5

# Minutes to for breakout to happen
CLOSE_BREAKOUT_TIME=5

# Duration to manage position after entry
CLOSE_MONITORING_TIME=25

# Min VIX level required to allow entry
STRAT_CLOSE_VIX_THRESHOLD=15

# Shorting method: InverseETF, ShortSell, LongPut, or disabled
SHORT_TYPE_CLOSE= InverseETF               

# -----------------------------------------
# Notifications
# -----------------------------------------

# Send email alert on trade entry
NOTIFY_ON_FILL=true

# Send email alert on trade exit
NOTIFY_ON_EXIT=true                    

# -----------------------------------------
# Reporting & Ledger Export
# -----------------------------------------

# auto = export after each trade, off = no export
LEDGER_EXPORT_MODE=auto


# -----------------------------------------
# Defense Mode (Disaster Risk Reduction)
# -----------------------------------------

# Set true if Disaster Protocol triggers; resets to false on recovery
DEFENSE_MODE_ACTIVE=false

# Percentage of normal MAX_CONCURRENT_TRADES allowed (rounded down)
DEFENSE_MODE_TRADE_LIMIT_PCT=66

# Maximum session allocation allowed during Defense Mode (e.g., 1%)
DEFENSE_MODE_TOTAL_ALLOCATION=0.01

# -----------------------------------------
# ENHANCEMENT MODULE TOGGLES 
# -----------------------------------------

# --- Rebalance Notification ---
ENABLE_REBALANCE_NOTIFIER=true
REBALANCE_TRIGGER_PCT=10                         # Notify accounting if float deviates ±10% from target

# --- Role-Based Web Access ---
RBAC_ENABLED=true                                # Enable multi-user roles in web dashboard
DEFAULT_USER_ROLE=viewer                         # Default role for new users

# --- Strategy Optimizer ---
ENABLE_STRATEGY_OPTIMIZER=true
OPTIMIZER_BACKTEST_LOOKBACK_DAYS=30              # Historical days for parameter tuning
OPTIMIZER_ALGORITHM=grid_search                  # Options: grid_search, bayesian, genetic
OPTIMIZER_OUTPUT_DIR=backtest_results/strategy_tuning/

# --- Real-Time Alerts ---
NOTIFY_ON_FILL=true
NOTIFY_ON_EXIT=true
NOTIFY_ON_FAILURE=true
CRITICAL_ALERT_CHANNEL=pagerduty                 # Options: email, slack, sms, pagerduty
ROUTINE_ALERT_CHANNEL=email                      # Options: email, slack

# --- Backtest Slippage Modeling ---
ENABLE_SLIPPAGE_MODEL=true
SLIPPAGE_SIMULATION_TYPE=randomized              # Options: none, rule_based, randomized
SLIPPAGE_MEAN_PCT=0.15                           # Average slippage %
SLIPPAGE_STDDEV_PCT=0.10                         # Standard deviation
SIMULATED_LATENCY_MS=500                         # Artificial delay (in milliseconds) per order



# --- black_scholes_filter Enhancements (if applicable) ---
ENABLE_BSM_FILTER=true
MAX_BSM_DEVIATION=0.15              # Reject if >15% over/under priced
RISK_FREE_RATE=0.045                # Used in BSM if not supplied dynamically
RISK_FREE_RATE_SOURCE=dynamic       # Options: static, dynamic — dynamic adjusts by JURISDICTION_CODE via bot_identity







================================================================================
Overall Directory Structure Diagram (Accounting-System Integrated)
================================================================================

rigd_tbot/
│
├── VERSION.md                       # Version change log for human or GPT reference
├── CHANGELOG.md                     # Technical commit-style change history (optional)
├── README.md                        # Project overview, architecture, and usage instructions
├── requirements.txt                 # Python package dependencies
├── .env                             # Global config (Flask port, encryption keys, login)
├── .env_bot                         # Decrypted bot settings (overwritten each run if using encrypted version)
├── .env_bot.template-test           # Example/test-mode config for cloning bots
├── .scpignore_env                   # Excludes only env/config
├── .scpignore_dev                   # Excludes test scripts, logs, debug files
├── .scpignore_enc                   # Used when deploying encrypted-only configs
├── .scpignore_prod_archive          # Used when deploying archive packages (no .env, no accounting ledgers, etc.)
│   │
├── tools/				# Encryption / Auth Tools
│   ├── encrypt_password.py          # AES-encrypts login password and updates .env
│   ├── encrypt_env_bot.py           # Encrypts .env_bot and saves it as env_bot.enc
│   │   └── sync_project.sh              # CLI interface for dev→live→prod folder syncs
│   │
├── backups/                         # Runtime Output / Audit Artifacts - Archived logs and reports (daily snapshots)
│   ├── logs_*.zip                   # Zipped logs (all modes)
│   │   └── summary_*.json               # JSON performance reports
│   │
├── logs/                            # Active logging folder (rotated or zipped by auto_backup)
│   ├── bot/
│   │   └── sessions/                # Logs per strategy and session
│   └── web/			 # Web authentication and access logs — supports multi-user login, audit trails
│       ├── access.log               # IP/timestamp of each login request
│       └── auth_failures.log        # Failed login attempts, lockout triggers
│    
├── support/				# Internal Documentation
│   ├── architecture.md              # System architecture and module breakdown
│   ├── API_reference.md             # CLI & internal API details (optional)
│   ├── security_notes.md            # Data handling, encryption key roles, etc.
│   │
│   └── scripts/			# Automation Scripts
│       ├── sync_to_accounting.py        # Pushes trade data to accounting system ledger ingestion module
│       ├── audit_log_parser.py          # CLI utility to review logs and summarize behavior
│       └── upload_backups_to_cloud.sh   # Syncs backups/ to external vault or S3
│
├── tbot_bot/                             # Core engine for execution, strategy logic, reporting, and control
│   ├── __init__.py
│   │   
│   ├── accounting/				# Accounting Integration
│   │   ├── account_transaction.py           # Generic transaction entry builder for accounting system ingestion
│   │   ├── accounting_api.py                # Routes trade output to accounting system ingestion pipeline
│   │   ├── accounting_config.py             # Controls ledger integration settings
│   │   ├── ledger_schema.py                 # Defines account hierarchy/types for ledger compliance (OFX-aligned)
│   │   └── tradebot_ledger_schema.sql	     # Reference schema — mirrors accounting system tables
│   │ 
│   ├── backtest/			# Backtesting & Research
│   │   ├── backtest_engine.py           # Core simulator to replay past trades
│   │   ├── load_historical_data.py      # Load from CSV, OHLCV, or tick sources
│   │   ├── performance_metrics.py       # Computes performance metrics (Sharpe, win %, drawdown)
│   │   └── plot_results.py              # Graphs equity curves, trades, and heatmaps
│   │
│   ├── broker/
│   │   ├── broker_api.py           # Unified interface: routes calls to selected broker adapter based on .env_bot
│   │   └── brokers/                # Broker-specific adapters, all conforming to the same interface contract
│   │       ├── __init__.py         # Enables package import and optional dynamic broker loading
│   │       ├── alpaca.py           # Alpaca implementation: REST/WebSocket order placement, account queries
│   │       ├── ibkr.py             # IBKR implementation: TWS/Gateway client with async fallback and reconnect
│   │       ├── tradier.py          # Tradier implementation: REST-only order flow with manual position sync
│   │       └── robinhood.py        # Robinhood implementation: unofficial API support (not for production)
│   │
│   ├── config/				# Configuration & Security
│   │   ├── env_bot.py                    # Validates and parses .env_bot
│   │   ├── error_handler.py             # Centralized exception manager and logging
│   │   ├── security_bot.py              # Encrypts/decrypts .env_bot to .env_bot.enc
│   │   └── settings_bot.py              # Programmatic editor for .env_bot values
│   │
│   ├── control/			# Control Signals (Web/CLI)
│   │   ├── control_start.txt            # Start flag file to trigger bot launch
│   │   └── control_stop.txt             # Stop flag file to trigger safe shutdown
│   │
│   ├── core/
│   │   ├── databases/
│   │   │   ├── LEDGER_STATUS.db                  	# Tracks system-wide ledger states (e.g., locked, open)
│   │   │   ├── PASSWORD_RESET_TOKENS.db           # Stores one-time password reset tokens and expiry timestamps
│   │   │   ├── SYSTEM.db                         	# Core system constants and bot-wide settings (independent of accounting system)
│   │   │   ├── SYSTEM_LOGS.db                    	# Centralized system event and audit logs
│   │   │   ├── SYSTEM_USERS.db  			# Sole source of truth for all login/authentication; replaces static user_identity
│   │   │   └── USER_ACTIVITY_MONITORING.db        # Maintains master list of user activity (IP, session, browser)
│   │   │
│   │   ├── schemas/
│   │   │   ├── ledger_status_schema.sql           # SQL schema for ledger status tracking table
│   │   │   ├── password_reset_schema.sql          # SQL schema for password reset token storage
│   │   │   ├── system_logs_schema.sql             # SQL schema for system logs table
│   │   │   ├── system_schema.sql                  # SQL schema for core system configuration
│   │   │   ├── system_users_schema.sql            # SQL schema for system users table
│   │   │   └── user_activity_monitoring_schema.sql # SQL schema for user activity monitoring (audit trail, access logs)
│   │   │
│   │   └── scripts/
│   │       ├── init_ledger_status.py              # Initializes ledger status database
│   │       ├── init_password_reset_tokens.py      # Initializes password reset token database
│   │       ├── init_system_logs.py                # Initializes system logs database
│   │       ├── init_system_users.py               # Initializes system users database
│   │       ├── init_system.py                     # Initializes core system configuration database
│   │       ├── init_user_activity_monitoring.py   # Initializes user activity monitoring database
│   │       └── verify_all_core_databases.py       # Connects to each core database, lists tables, and prints them to confirm initialization
│   │
│   ├── data/
│   │   └── cache/
│   │       └── fundamentals_{date}.json          # stored ephemeral runtime artifacts and daily snapshots, such as: API response caches, Screener prefilter output, Temporary metadata from tuning_tracker.py
│   │ 
│   ├── enhancements/				# Enhancements (Optional Guards & Filters)
│   │   ├── adx_filter.py                	# Blocks trades during trending ADX
│   │   ├── finnhub_fundamental_guard.py	Blocks trades if company fundamentals fail configured thresholds (e.g. P/E, debt/equity)
│   │   ├── black_scholes_filter.py     	# Enhancement: Validates put/call option pricing using Black-Scholes-Merton model Globalized for multi-jurisdiction trading via {JURISDICTION_CODE}
│   │   ├── bollinger_confluence.py      	# Confirms entries with Bollinger alignment
│   │   ├── build_check.py               	# Validates pre-launch config and file integrity
│   │   ├── imbalance_scanner_ibkr.py    	# IBKR imbalance feed for close strategy gating
│   │   ├── ticker_blocklist.py          	# Blocks duplicate ticker usage in one session
│   │   ├── tuning_tracker.py			# Tracks and evaluates past strategy performance for tuning guidance
│   │   └── vix_gatekeeper.py            	# VIX-based gating logic
│   │
│   ├── output/										 # Output Artifacts
│   │   └── {ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}/                	# ← Scoped per bot ID - Entire directory mirrored to Accounting system
│   │       ├── logs/                           					# Unified strategy logs (one per phase or failure mode)
│   │       │   ├── open.log								# Log of all trades and decisions during open strategy window
│   │       │   ├── mid.log								# Log of trades during midday session (position management, adjustments)
│   │       │   ├── close.log								# Log of closeout phase decisions and trade executions
│   │       │   ├── unresolved_orders.log						# Captures failed, rejected, or stale orders not resolved during session
│   │       │   └── error_tracebacks.log						# Full Python tracebacks for all uncaught exceptions (with timestamps)
│   │       │
│   │       ├── ledgers/  
│   │       │   ├── {ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_COA.db       		# COA for bot ledger (per broker)
│   │       │   ├── {ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_ledger.db    		# OFX-compliant ledger for live trading data per broker
│   │       │   └── {ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_FLOAT_ledger.db         # Dedicated float ledger: tracks injections, limits, drain points per bot
│   │       │
│   │       ├── summaries/
│   │       │   └── {ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_daily_summary.json		# JSON performance summary for session (PnL, latency, counts, risk triggers)
│   │       │
│   │       └── trades/
│   │           ├── {ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_trade_history.csv		# All trade data for session (raw, human-readable)
│   │           └── {ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_trade_history.json		# Structured trade records for ingestion, reconciliation, and audit
│   │
│   ├── reporting/				# Reporting & Logging
│   │   ├── auto_backup.py               	# Compresses and archives /output after session
│   │   ├── daily_summary.py            	# Builds trade summary stats and outcomes
│   │   ├── log_rotation.py             	# Cleans output folder after N days
│   │   ├── notify_rebalance_requirements.py	#  Monitors current float for this bot then notify accounting system to initiate manual or automated rebalance.
│   │   ├── report_router.py            	# Routes finalized trade output to loggers and accounting
│   │   ├── session_report.py           	# Session wrap-up summary writer
│   │   ├── status_logger.py            	# Syncs bot state to UI (optional)
│   │   └── trade_logger.py             	# Records trade data to output/trades
│   │
│   ├── runtime/			# Session Lifecycle
│   │   ├── __init__.py
│   │   ├── main.py                      # Master controller (boot → trade → shutdown)
│   │   ├── start_bot.py                 # CLI entry point
│   │   ├── status_bot.py                # Tracks session state and health
│   │   ├── stop_bot.py                  # Graceful session shutdown
│   │   ├── tbot_runner_supervisor.py   # Oversees full lifecycle and watchdogs
│   │   └── watchdog_bot.py              # Broker connection monitor
│   │
│   ├── screeners/			# Screener & Symbol Selection
│   │   └── finnhub_screener.py          # Symbol scanner via Finnhub API
│   │
│   ├── storage/
│   │   ├── backups/                             # Daily ledger backups (UTC timestamped snapshots)
│   │   │   └── {date}/
│   │   ├── exports/                             # Daily export snapshots
│   │   │   └── {date}/
│   │   ├── keys/                                # Encryption keys (excluded from deployments for security)
│   │   │   ├── .keep                            # Placeholder to retain keys folder in version control
│   │   │   ├── acct_api.key                     # Used to call secure endpoints in accounting system
│   │   │   ├── broker.key                       # Fernet key for encrypting/decrypting broker credentials (Alpaca, IBKR, etc.)
│   │   │   ├── env.key                          # Decrypts general bot config
│   │   │   ├── login.key                        # bcrypt/Fernet keys for passwords, reset tokens, and non-password use cases
│   │   │   ├── screener_api.key                 # Fernet key for decrypting Finnhub or other screener API keys
│   │   │   └── smtp.key                         # Fernet key for decrypting SMTP login and host data
│   │   │
│   │   ├── secrets/						# Encrypted configuration files for credentials and tokens
│   │   │   ├── alert_channels.json.enc                             		
│   │   │   ├── network_config.json.enc   			# contains LOCAL_IP, LOCAL_PORT, REMOTE_IP, REMOTE_PORT
│   │   │   ├── bot_identity.json.enc				# contains values for {ENTITY_CODE} {JURISDICTION_CODE} {BROKER_CODE} {BOT_ID}
│   │   │   ├── acct_api_credentials.json.enc     		# contains Token or credentials to call accounting system endpoints
│   │   │   ├── broker_credentials.json.enc       		# Contains ALPACA + IBKR credentials (API keys, usernames, passwords, URLs)
│   │   │   ├── smtp_credentials.json.enc         		# contains SMTP_USER, PASS, HOST, PORT
│   │   │   └── screener_api.json.enc             		# contains FINNHUB_API_KEY or other screener access tokens
│   │   │
│   │   └── migration_archives/                              
│   │
│   ├── strategy/			# Strategy Logic
│   │   ├── strategy_close.py            # End-of-day logic (momentum/fade)
│   │   ├── strategy_meta.py             # Thresholds and constants
│   │   ├── strategy_mid.py              # VWAP-based logic
│   │   ├── strategy_open.py             # Opening range breakout
│   │   └── strategy_router.py           # Directs execution based on time/config
│   │
│   ├── support/			 # Support
│   │   ├── .env_bot.enc                 # Encrypted runtime config
│   │   ├── decrypt_secrets.py             # Loads and decrypts .json.enc files using corresponding Fernet keys
│   │   ├── utils_bot.py                 # Shared helpers
│   │   ├── path_resolver.py		# Resolves dynamic paths for TradeBot modules based on identity and file category.
│   │   └── service_bot.py               # Optional daemon listener (e.g. systemd)
│   │
│   ├── test/					# Test Suite
│   │   ├── integration_test_runner.py         # Simulates a full bot session from init to shutdown 
│   │   ├── test_backtest_engine.py            # Validates backtest results against known metrics and equity curves
│   │   ├── test_env_bot.py                    # Verifies .env_bot structure, required fields, and parsing logic
│   │   ├── test_logging_format.py             # Ensures all log entries follow required format and completeness
│   │   ├── test_main_bot.py                   # Tests session lifecycle logic and file triggers (start/stop)
│   │   ├── test_strategy_selfcheck.py         # Asserts that all strategy modules pass .self_check() requirements - Required for CI before deployment
│   │   ├── test_screener_random.py            # Runs screener logic with randomized symbols to confirm filtering and eligibility logic
│   │   ├── test_broker_trade_stub.py          # Sends randomized micro-trades to broker in to validate order flow, response, and logging
│   │   └── test_strategy_tuner.py             # Executes strategy modules in isolation with test tickers to validate signal logic, threshold configs, and entry/exit paths
│   │
│   └── trading/			# Trade Execution
│       ├── kill_switch.py               # Triggers shutdown on loss violation
│       ├── logs_bot.py                  # Runtime logging of trade ops
│       ├── notifier_bot.py              # Email/Slack alerts
│       ├── orders_bot.py                # Order submission logic
│       ├── reporting_bot.py             # Pushes trades to accounting system
│       └── risk_bot.py                  # Risk enforcement engine
│   
└── tbot_web/                             # Web dashboard for monitoring, logs, and control
    ├── assets/                           # Static frontend resources
    │   ├── fnt/                          # Embedded fonts used in the interface
    │   └── css/
    │       ├── main.css                  # Core layout and UI styling rules
    │       └── theme.css                 # Optional theme layer (e.g. light/dark modes)
    │
    ├── favicon.ico / favicon.gif         # Site icon for browser tab
    │
    ├── py/                               # Flask backend for web UI and bot interaction
    │   ├── __init__.py                   # Registers Flask blueprints for all routes
    │   ├── auth_web.py                   # AES decryption for login password validation
    │   ├── login_web.py                  # Login/logout route handling with rate limit enforcement
    │   ├── logs_web.py                   # Displays latest bot log output to the web UI
    │   ├── main_web.py                   # Web router and load shell for dashboard interface
    │   ├── portal_web.py                 # Flask app factory for app + static + template setup
    │   ├── run_web.py                    # Webserver launcher for local or remote access
    │   ├── settings_web.py               # Updates .env_bot config via web interface (no trading logic)
    │   ├── start_stop_web.py             # Writes control_start.txt / control_stop.txt to signal bot lifecycle
    │   └── status_web.py                 # Displays bot state from status.json (read-only)
    │
    ├── robots.txt                        # Blocks bots and search engine indexing (security)
    │
    └── templates/                        # HTML UI templates rendered with Jinja2
        ├── index.html                    # Login screen rendered via Jinja2
        ├── main.html                     # Dashboard shell with embedded strategy/log/status panels
        ├── logs.html                     # Real-time log display (read-only)
        ├── settings.html                 # Web form for updating bot config (.env_bot)
        └── status.html                   # Bot health and strategy state view from status.json



================================================================================
Deployment Notes (Updated)
================================================================================


- All paths must be relative and cross-platform compatible (macOS, Linux, cloud).
- `tbot_bot/` must run independently of `tbot_web/`; core trading must continue if web UI is disabled.
- Logs, ledger exports, and backup behavior remain active regardless of web interface state.
- Only one broker should be enabled at first (`ALPACA_ENABLED=true`, etc.).
- Broker API keys from `.env` must validate at startup—failure causes immediate shutdown.
- Strategy toggles: `STRAT_OPEN_ENABLED`, `STRAT_MID_ENABLED`, `STRAT_CLOSE_ENABLED`.
- Pre-trade validation includes:
  - Market spread ≤ 1.5% of entry price
  - Volume ≥ `MIN_VOLUME_THRESHOLD`
  - No violations of `MAX_RISK_PER_TRADE` or `DAILY_LOSS_LIMIT`
- Auto-shutdown triggers:
  - Broker API failure (`watchdog_bot.py`)
  - Critical runtime error (`error_handler.py`)
  - Loss breach (`kill_switch.py`)
- Ledger write format: `entities/{ENTITY}_{JURIS}_{account}_{BROKER}_{BOT_ID}_BOT_ledger.db`
- Each ledger write is preceded by a timestamped backup (`backup_ledgers.py`): `entities/{ENTITY}_{JURIS}/backups/`
- OFX exports are generated only by `/export/generate_ofx.py`
- Log files: `/output/logs/open.log`, `/mid.log`, `/close.log`, `/unresolved_orders.log`
- Post-session logs may be zipped/archived (`auto_backup.py`)
- Optional cloud sync: `scripts/upload_backups_to_cloud.sh`
- Backups must not block live ledger writes; all archives are timestamped
- Session timing: `.env_bot` defines `START_TIME_*`, `[STRAT]_ANALYSIS_TIME`, `[STRAT]_MONITORING_TIME`
- Respect `TRADING_DAYS`—block execution on weekends/holidays


================================================================================
Current Platforms (Updated for Single Broker + Accounting System)
================================================================================


Current Platforms (Updated for Single Broker + Accounting System)

Development:
- Local dev on macOS 15.2, Python 3.11+
- macOS/Linux compatible only (no platform-specific code)
- Use VS Code, Black/Ruff for linting/formatting
- Scripts run via terminal or cron, not GUI
- Test logs/export saved to `logs/bot/sessions/`, `backups/`

Production:
- Runs on Ubuntu 22.04 LTS (DigitalOcean)
- Deployed via SCP/SFTP or `git pull` to prod branch
- Run modes:
  - `start_bot.py` (manual/cron)
  - `service_bot.py` (systemd optional)
- Logs:
  - `output/logs/*.log` – strategy + unresolved
  - `output/summaries/` – session summaries
  - `output/trades/` – CSV/JSON

Brokers:
- One active broker per bot
- Injected via accounting system `.env_bot`
- Modular integrations:
  - Alpaca (default equities)
  - IBKR (ETFs, puts)
  - Tradier/Webull (test only)
- Each must pass `.self_check()`

Market Data:
- Finnhub API via `screeners/finnhub_screener.py`
- Pre/intraday/afterhours scan modes
- Filters: volume, float, price, gap via `.env_bot`

Accounting:
- All trades routed through `accounting_api.py`
- Ledger format: `{ENTITY}_{JURIS}_{BROKER}_{BOT_ID}_BOT_ledger.db`
- Structure in `ledger_schema.py`, OFX-compliant
- OFX exports only via `generate_ofx.py`
- TradeBot does not emit CSV for ledgers

Web Interface:
- `tbot_web/` Flask dashboard
- Features:
  - AES login (key in `.env`)
  - Config UI
  - Logs/status via `status.json`
  - Start/Stop: `control_start.txt`, `control_stop.txt`

Alerts:
- Optional SMTP email via `.env`:
  - `NOTIFY_ON_FILL=true`, `NOTIFY_ON_EXIT=true`
- SMTP creds from DreamHost/etc. in `.env`

Security:
- `.env_bot` encrypted → `.env_bot.enc` via `tools/encrypt_env_bot.py`
- AES key in `.env` as `ENV_BOT_KEY`
- All encrypted files ignored via `.scpignore_*`

Backup:
- Logs + ledgers archived via `auto_backup.py`
- Stored under `backups/`, upload via `upload_backups_to_cloud.sh`
- Secondary replication recommended (FTP/S3/ProtonVault)

Deployment Verification:
- Dry-run test required pre-live
- Must confirm:
  - Broker API up
  - Trade logs written
  - Ledger writes
  - Strategy triggers
  - Alerts (if configured)

Recovery:
- Backups must be timestamped + encrypted
- Mirror logs/ledgers to vault at EOD
- Regular integrity checks on `backups/` for audit/failure recovery



================================================================================
Time Zone Standards
================================================================================

Overview:
To ensure consistency, accuracy, and interoperability across development, testing, and production environments, all time-related variables in TradeBot are defined and logged in UTC (Coordinated Universal Time).

Usage:
- All strategy start times (`START_TIME_OPEN`, `START_TIME_MID`, `START_TIME_CLOSE`) are set in UTC
- Log timestamps, strategy triggers, ledger entries, and alerts must all use UTC
- All ledger entries written into `entities/TB_ledger.db` must record `DTPOSTED` and all OFX-required timestamps in UTC
- Internal time comparisons in `strategy_router.py` and `status_bot.py` must convert local system time to UTC before logic execution

Reasoning:
- UTC avoids ambiguity across time zones, daylight saving time shifts, or server environments (macOS, Linux, cloud)
- Ensures OFX export compliance and accurate cross-entity reconciliation across ledgers
- Allows reliable scheduling when hosting in geographically distributed environments (e.g., DigitalOcean, AWS)
- Compatible with broker API timestamps and log analysis pipelines

Example Mapping:
- 14:30 UTC → 9:30 AM EST (Market Open)
- 15:30 UTC → 10:30 AM EST (Midday Strategy)
- 19:30 UTC → 2:30 PM EST (Close Strategy)

Implementation Tip:
If debugging locally in EST or PST, always convert timestamps before interpreting logs or database entries.

Best Practice:
Add a helper function in `utils_bot.py`:
```python
def utc_now():
    return datetime.utcnow().replace(tzinfo=timezone.utc)


================================================================================
RIGD Trading Bot – Infrastructure and Deployment Overhaul Instructions (UPDATED)
================================================================================


RIGD Trading Bot – Infrastructure and Deployment Overhaul (UPDATED)

OBJECTIVE: Deploy RIGD Trading Bot on DigitalOcean droplet with:
- Shared CPU (Premium AMD), Ubuntu 22.04 LTS
- systemd-based architecture
- Secure, hardened setup

PHASE 1: DROPLET PROVISIONING (COMPLETE)
- Region: nyc3; Plan: 2 vCPU, 4GB RAM, 80GB NVMe
- OS: Ubuntu 22.04 LTS; Tags: rigd, tb, nyc3, systemd, primary
- SSH Key: id_ed25519 (renamed from rigd_tbot_key)
- Status: SSH, DNS, firewall active
- Backups disabled (handled via systemd timers)

PHASE 2: SERVER HARDENING (COMPLETE)
- User: tbot; Root SSH and password login disabled
- Installed: fail2ban, UFW, auto-security updates
- TZ: UTC; Packages: Python 3.10+, pip, venv, sqlite3, rsync, curl, git
- Directory: ~/rigdtb/tbot; Venv: ~/rigdtb/venv

PHASE 3: SYSTEMD UNIT DEPLOYMENT (IN PROGRESS)
Create in /etc/systemd/system/:
- tbot.target
- tbot-open.service (9:30–9:50 UTC)
- tbot-mid.service (12:00–12:30 UTC)
- tbot-close.service (15:45–16:00 UTC)
- tbot-monitor.service (~30 min trailing stop)
- tbot-backup.service + tbot-backup.timer (daily)
- tbot-sync.service + optional tbot-sync.timer

Requirements:
- User: tbot; Restart=on-failure
- WorkingDirectory=/home/tbot/rigdtb/tbot
- ExecStart launches strategy script
- Log to journald; Optionally use /etc/tbot.env
- Timers: OnCalendar=..., Persistent=true

PHASE 4: LOGGING, BACKUPS, AND INTEGRATION (NEXT)
- Create ~/rigdtb/scripts/backup_bot_to_iceland.sh:
  - Bundle: logs, SQLite ledgers, config snapshots
  - Compress and rsync to Iceland server
  - Auto-delete backups > 7 days old
- Optionally mirror ledgers/logs to /mnt/shared or DR target
- Validate with journalctl and systemctl

PHASE 5: VALIDATION AND LIVE-CHECK
- Use systemctl list-timers to confirm timers
- systemctl status tbot.target for system status
- Simulate trade and trailing-stop trigger
- Confirm backup runs post-close
- Test resilience: kill + auto-restart tbot-monitor.service

CRITICAL RULES
- Only systemd controls services — no manual runs
- No cron — remove if installed
- No root SSH access
- divergence must be explicitly flagged


=============================================================================================================================================
RIGD GROUP LLC — Unified Capital Risk Controls and Dynamic Broker Float Allocation 
=============================================================================================================================================

Overview: RIGD Group LLC (RGL) enforces dynamic float allocation and strict per-session risk controls (OPEN, MID, CLOSE). All thresholds are sourced from `.env_bot`. No hardcoded limits allowed.

Risk per Strategy Session (TOTAL_ALLOCATION):
Each strategy session risks no more than `broker_current_float * TOTAL_ALLOCATION`. Allocation per trade follows `WEIGHTS`.

Example Allocations:
1 signal → 100%
2 signals → 60%, 40%
3 signals → 40%, 30%, 30%
4 signals → 40%, 20%, 20%, 20%

Assuming Broker Float = $2,500, TOTAL_ALLOCATION = 0.02 → Session cap = $50

MAX_OPEN_POSITIONS / MAX_TRADES:
- `MAX_TRADES` limits per-session entries
- `MAX_OPEN_POSITIONS` enforces system-wide cap

WEIGHTS:
- Must match max `MAX_TRADES` slots
- Sourced from `.env_bot`

DAILY_LOSS_LIMIT:
Each broker halts trading if `realized_loss > broker_current_float * DAILY_LOSS_LIMIT`
- Loss-based shutdown is broker-specific

Ledger/Accounting Integration:
- Bot reads float only (`broker_current_float`)
- Float changes routed through accounting ledgers
- All float movements (ACH, etc.) must be:
  - Ingested by accounting system
  - Logged with OFX-compliant entries
  - Double-entry reconciled
  - Validated post-transfer

Automated Mercury pulls (if supported) verify accounting float sync

Rebalancing:
- Accounting system manages all rebalancing logic
- Bot uses float at session start; no rebalancing logic in bot
- Rebalancing triggered if float deviates >10%

Scaling/Compounding:
- Risk caps and trade sizes auto-scale with float/capital
- Manual overrides prohibited unless reflected in `.env_bot`

Enforcement Modules:
- risk_bot.py: Enforces `TOTAL_ALLOCATION`, `WEIGHTS`, `MAX_TRADES`, `MAX_OPEN_POSITIONS`, PnL caps
- kill_switch.py: Halts trading on `DAILY_LOSS_LIMIT` breach
- watchdog_bot.py: Suspends trading on API/infrastructure failure

All controls apply equally in test/live modes. No manual overrides without `.env_bot` update authorization.



=============================================================================================================================================
TradeBot Strategy Logic Spec v1.1 (Updated for Accounting System Integration)
=============================================================================================================================================

Overview:
TradeBot executes intraday breakout and reversion strategies using a unified logic pipeline. All entries are directional and follow structured risk, time, and allocation parameters.

Supported Instruments:
- Long equity (common stocks or ETFs)
- Inverse ETFs (e.g., SH, SQQQ)
- Long puts (IBKR only)

Trade Direction Rules:
- Long trades = supported on all brokers
- Bearish trades = only executed if `SHORT_TYPE_*` is not `disabled`
- Puts = only used if broker = IBKR and `SHORT_TYPE_*` = LongPut
- Inverse ETFs = fallback for non-options brokers when `SHORT_TYPE_*` = InverseETF

Supported Brokers:
- Alpaca: long equity, inverse ETFs
- IBKR: long equity, inverse ETFs, long puts
- Tradier: long equity, inverse ETFs

Execution Framework:
- Strategy execution is controlled via `STRATEGY_SEQUENCE` in `.env_bot`
- Each strategy module is loaded independently by `strategy_router.py`
- Runtime logic respects UTC windows and `.env_bot` timing variables


Ledger and Accounting Integration:
- All trade activities, allocations, and PnL updates must be written directly into:
    - `entities/TBL_ledger.db` 

- All ledger entries follow the OFX-compliant schema with:
    - `TRNTYPE`, `DTPOSTED`, `FITID`, broker, strategy, ticker, side, size, entry price, exit price, PnL, and audit references.
- No `.manager` or external accounting files are used; all reporting and reconciliation flow through the accounting system’s ingestion modules.

Active Strategies:

---------------------------------------------------------
Strategy: strategy_open.py – Opening Range Breakout
---------------------------------------------------------
- Time Window:
  - Start: `START_TIME_OPEN` (14:30 UTC = 9:30 AM EST)
  - Analysis phase: `OPEN_ANALYSIS_TIME` minutes
  - Breakout phase: `OPEN_BREAKOUT_TIME` minutes
  - Trade management: `OPEN_MONITORING_TIME` minutes
- Trade Direction: Long by default; short only if `SHORT_TYPE_OPEN` ≠ `disabled`
- Entry Logic:
  - Track high/low during analysis
  - Enter if price > high * (1 + `STRAT_OPEN_BUFFER`) or < low * (1 - `STRAT_OPEN_BUFFER`)
  - Must occur within breakout window
- Exit Logic:
  - 2% trailing stop or monitoring timeout
- Shorting:
  - Controlled via `SHORT_TYPE_OPEN`: InverseETF, LongPut, ShortSell, or disabled
- Logging:
  - Logs: `open.log
  - Ledger: `entities/TB_ledger.db`
  - Trade History: `trade_history_*.csv/json`

-----------------------------------------
Strategy: strategy_mid.py – VWAP Mean Reversion
-----------------------------------------
- Time Window:
  - Start: `START_TIME_MID` (15:30 UTC = 10:30 AM EST)
  - Analysis phase: `MID_ANALYSIS_TIME` minutes
  - Breakout phase: `MID_BREAKOUT_TIME` minutes
  - Trade management: `MID_MONITORING_TIME` minutes
- Trade Direction: Long or Bearish
- Entry Logic:
  - Enter on deviation from VWAP ±`STRAT_MID_VWAP_THRESHOLD`
  - Confirm via ADX and Bollinger filters
  - Entry must be within breakout window
- Exit Logic:
  - VWAP touch, 1.5% stop loss, or timeout
- Shorting:
  - Controlled via `SHORT_TYPE_MID`: InverseETF, LongPut, ShortSell, or disabled
- Enhancements:
  - `adx_filter.py`, `bollinger_confluence.py`
- Logging:
  - Logs: `mid.log` 
  - Ledger: `entities/TB_ledger.db` 
  - Trade History: `trade_history_*.csv/json`
-----------------------------------------
Strategy: strategy_close.py – End-of-Day Momentum / Fade
-----------------------------------------
- Time Window:
  - Start: `START_TIME_CLOSE` (19:30 UTC = 2:30 PM EST)
  - Analysis phase: `CLOSE_ANALYSIS_TIME` minutes
  - Breakout phase: `CLOSE_BREAKOUT_TIME` minutes
  - Trade management: `CLOSE_MONITORING_TIME` minutes
- Trade Direction: Long or Bearish
- Entry Logic:
  - Enter on momentum continuation or spike reversal
  - Requires VIX > `STRAT_CLOSE_VIX_THRESHOLD`
  - Must occur within breakout window
- Exit Logic:
  - 2% stop loss or hard exit at session end
- Shorting:
  - Controlled via `SHORT_TYPE_CLOSE`: InverseETF, LongPut, ShortSell, or disabled
- Enhancements:
  - `vix_gatekeeper.py`, `imbalance_scanner_ibkr.py`, `ticker_blocklist.py`
- Logging:
  - Logs: `close.log` 
  - Ledger: `entities/TB_ledger.db` 
  - Trade History: `trade_history_*.csv/json`

-----------------------------------------
Strategy Failover Logic
-----------------------------------------
- Any `.self_check()` failure skips the strategy
- If `STRATEGY_OVERRIDE` is set (e.g., `mid`), only that strategy runs
- All execution respects global constraints:
  - `DISABLE_ALL_TRADES`
  - `DAILY_LOSS_LIMIT`
  - `MAX_OPEN_POSITIONS`
  - `TOTAL_ALLOCATION` and `WEIGHTS`
  - Broker status, float, and account restrictions



=============================================================================================================================================
InverseETF Integration Specification (Final v1.0)
=============================================================================================================================================

Overview:
TradeBot supports directional short positions using Inverse ETFs as a fallback mechanism for bearish trades when the broker does not support long puts or short selling. Inverse ETFs are eligible for all strategy modules and must follow strict screening, liquidity, and execution logic enforced by `.env_bot` and strategy-level constraints.

------------------------------------------------------------------------------------------------------------------------
Configuration & Controls
------------------------------------------------------------------------------------------------------------------------

- All bearish logic is gated by:
  - SHORT_TYPE_OPEN=InverseETF
  - SHORT_TYPE_MID=InverseETF
  - SHORT_TYPE_CLOSE=InverseETF

- The universe of inverse ETFs is predefined and must be explicitly whitelisted in `finnhub_screener.py`:
  INVERSE_ETF_TOP20 = [
      "SQQQ", "SPXU", "UVXY", "SDOW", "SRTY", "SH", "PSQ", "DOG", "TBF", "TBT",
      "TMV", "FAZ", "ERY", "REK", "DRIP", "YANG", "MYY", "RWM", "QID", "DXD"
  ]

- Screening filters applied before execution:
  - MIN_VOLUME_THRESHOLD (e.g., 1,000,000)
  - MIN_PRICE, MAX_PRICE
  - Spread check: abort if spread > 1.5% of current price
  - Strategy-specific logic (VWAP deviation, breakout threshold, etc.)

- Execution Limitations:
  - Inverse ETFs must not be used outside strategy windows
  - No after-hours or pre-market trading allowed
  - Only 1 trade per symbol per session (enforced by `ticker_blocklist.py`)
  - Each inverse ETF trade must be logged with full audit metadata

------------------------------------------------------------------------------------------------------------------------
Runtime Integration
------------------------------------------------------------------------------------------------------------------------

- ETF pool per strategy is dynamically filtered from INVERSE_ETF_TOP20
- Strategy modules use:

    from tbot_bot.strategy.strategy_meta import ETF_POOLS

    if SHORT_TYPE == "InverseETF":
        candidates = scan_etfs(ETF_POOLS["mid"])  # for example
        for etf in candidates:
            if passes_filters(etf):
                submit_trade(etf, side="short")

- ETF pool may be strategy-specific:

    ETF_POOLS = {
    "open": [
        "SH", "PSQ", "DOG",        # Conservative -1x ETFs
        "SPXU", "SQQQ", "SDOW",    # High liquidity index shorts
        "RWM", "MYY"               # Small- and mid-cap inverse
    ],
    "mid": [
        "SQQQ", "SPXU", "SDOW",    # Tech, S&P, Dow (-3x)
        "SRTY", "QID", "DXD",      # Small/mid/large blends (-2x)
        "RWM", "MYY",              # Non-leveraged variants
        "FAZ"                      # Financials
    ],
    "close": [
        "SPXU", "SQQQ", "UVXY",    # Momentum/volatility plays
        "TMV", "TBT", "TBF",       # Treasury bear curve (-1x/-2x/-3x)
        "ERY", "DRIP",             # Energy and Oil & Gas
        "REK", "YANG"              # Real Estate, China - volatility/geohedge
    ]
}


------------------------------------------------------------------------------------------------------------------------
Logging & Ledger Compliance
------------------------------------------------------------------------------------------------------------------------

- All inverse ETF trades must write to:
  - output/trades/trade_history.json
  - output/logs/{strategy}.log
  - entities/{ENTITY}_{JURIS}_{BROKER}_{BOT_ID}_BOT_ledger.db

- Required ledger fields:
  - TRNTYPE=SELL
  - ticker, side=short, entry_price, exit_price, PnL, broker, strategy, FITID, DTPOSTED
  - TAG=InverseETF, LEVERAGE_MULTIPLIER if known

------------------------------------------------------------------------------------------------------------------------
Summary
------------------------------------------------------------------------------------------------------------------------

- Inverse ETFs provide safe, broker-compatible short exposure without requiring margin or options.
- TradeBot enforces strict entry criteria to avoid decayed or illiquid instruments.
- ETF list is version-controlled and may only be updated via internal review.
- Use is toggled per-strategy via `.env_bot` using SHORT_TYPE_* = InverseETF


=============================================================================================================================================
Enhancement Module Activation
=============================================================================================================================================


Overview: TradeBot includes modular enhancements in /tbot_bot/enhancements/ to refine signal quality, block trades under poor conditions, or perform diagnostics. Enhancements are plug-ins activated via strategy context or .env_bot.

All enhancements are independently testable, and auto-invoked from strategy_router.py or individual strategies. Each returns a boolean (True=allow, False=block). Failures log warnings but default to core logic unless fatal. Outcomes are logged to strategy logs and summaries, not accounting ledgers.

Enhancements:

1. adx_filter.py – Blocks mean reversion trades if ADX > 25 (trend detection); used in strategy_mid.py; always-on (future toggle: ADX_FILTER_ENABLED=true).

2. bollinger_confluence.py – Requires price to breach ±2σ Bollinger Band; used in strategy_mid.py; inline triggered; reduces false positives in low-volatility regimes.

3. vix_gatekeeper.py – Blocks trades if VIX < STRAT_CLOSE_VIX_THRESHOLD (.env_bot); applies to strategy_close.py; used to avoid low-volatility EOD signals.

4. imbalance_scanner_ibkr.py – Reads IBKR imbalance data from 20:30–21:00 UTC; blocks trades during strong opposing pressure; applies to strategy_close.py when BROKER=ibkr.

5. ticker_blocklist.py – Prevents repeat trades per ticker per session; applies to all strategies; always-on; tracks traded tickers in memory/temp.

6. build_check.py – Startup validation tool; called by main_bot.py or CLI; checks for .env/.env_bot/.env_bot.enc, writable paths, log availability, and placeholder files. Bot halts on failure.

7. black_scholes_filter.py – Validates options premiums against theoretical Black-Scholes-Merton pricing; used to block overpriced or misquoted calls/puts. 
   - Dynamically adjusts `risk_free_rate` by `JURISDICTION_CODE` from `bot_identity.json.enc`
   - Enabled via `.env_bot` toggle: `ENABLE_BSM_FILTER=true`
   - Rejects if deviation > `MAX_BSM_DEVIATION` (default: 15%)
   - Logs detailed context for each rejection

8. finnhub_fundamental_guard.py – Blocks trades if company fundamentals fail configured valuation thresholds.
   - Pulls data via `FINNHUB_API_KEY` (loaded from `screener_api.json.enc`)
   - Cached to `data/cache/fundamentals_{date}.json` to minimize API overhead
   - Enforced metrics:
     - `peNormalizedAnnual` must be ≤ `MAX_PE_RATIO` (default: 50)
     - `totalDebt/totalEquityAnnual` must be ≤ `MAX_DEBT_EQUITY` (default: 2.5)
     - `marketCapitalization` must be ≥ `MIN_MARKET_CAP_FUNDAMENTAL` (default: 2B)
   - Logs full rejection context to strategy logs for audit and tuning

Best Practices:
- Keep enhancements decoupled from core logic
- Use toggles in .env_bot only if dynamic enable/disable needed
- Enhance trade quality; do not generate signals
- Only executed trades are recorded in ledgers; all blocks/skips are logged to operational logs and summaries only

2. Core Safety Systems:

2.1 kill_switch.py
- Halts trading on `DAILY_LOSS_LIMIT` breach
- Logs shutdown + attempts to close trades

2.2 watchdog_bot.py
- Monitors API and data feeds
- Broker failure: suspend trading, cancel orders
- Market outage: full shutdown

2.3 risk_bot.py
- Enforces: `MAX_RISK_PER_TRADE`, `TOTAL_ALLOCATION`, `MAX_TRADES`, `MAX_OPEN_POSITIONS`
- Applies adjusted Defense Mode limits
- Validates pre-execution

2.4 error_handler.py
- Captures: `NetworkError`, `BrokerError`, `LogicError`, `ConfigError`
- Logs with timestamp, severity
- Triggers shutdown if severe

2.5 security_bot.py
- Validates `.env_bot.enc` decryption via `ENCRYPTION_KEY`
- Blocks plaintext use in prod

3. Emergency Shutdown:
| Event                         | Scope   | Action                      |
|------------------------------|---------|-----------------------------|
| DAILY_LOSS_LIMIT breach      | Global  | Immediate halt              |
| Broker API failure           | Global  | Trading suspended           |
| Market data failure          | Global  | Full system shutdown        |
| Critical exception           | Global  | Full shutdown               |
| Manual override              | Scoped  | Controlled shutdown/reset   |
- All actions logged and audited

4. Self-Check System:
- `*.self_check()` required for:
  - kill_switch.py, watchdog_bot.py, risk_bot.py, error_handler.py, security_bot.py
- Confirms `.env_bot` integrity, Defense Mode vars, broker access, threshold presence
- Launch blocked on failure, cause logged



=============================================================================================================================================
INTEGRATION MODULE – TBOT + ACCOUNTING SYSTEM ALIGNMENT
=============================================================================================================================================

Purpose:
This section mandates integration alignment between the tbot execution system and the forensic-grade accounting system currently under modular build.

Scope:
These rules apply to:
- All tbot trading actions (test or live mode)
- All float injections, float returns, broker cash movements
- All profit/loss logging, reconciliation, and reporting

----------------------------------------------------------------------
KEY INTEGRATION RULES
----------------------------------------------------------------------

1. LEDGER ISOLATION PER ENTITY + BOT
   - All tbot activities must write to the correct ledger for its assigned bot instance:
     - `{ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_ledger.db`
   - No other ledgers (e.g., RGL, RHL, or shared simulation files) may be written by the bot.
   - Float movements between bots or entities must use cross-entity sync and ingestion within the accounting system.

2. MULTI-CURRENCY READINESS
   - All ledger entries must carry an explicit currency code (`currency_code`), even if currently single-currency.
   - The accounting schema supports multi-currency by default; tbot must pass accurate currency codes with each ledger entry.

3. INGESTION PIPELINE COMPLIANCE
   - All broker fills and executed trades must be routed through the accounting system’s ingestion modules.
   - No direct write to final ledger tables is permitted outside of approved ingestion paths.

4. DOUBLE-ENTRY ENFORCEMENT
   - Every tbot-generated ledger entry must obey double-entry constraints (sum of debits = sum of credits).
   - Trade execution, PnL, float movement, and fee posting must balance using system-defined accounts.

5. AUDIT LOGGING
   - All ledger-triggering actions by the bot must create a corresponding audit log in the `logs` table.
   - Any manual correction or backfill must be flagged, source-tracked, and reviewed.

6. OFX EXPORT READINESS
   - Ledger entries must be OFX-aligned and compatible with `generate_ofx.py`:
     - `TRNTYPE`, `DTPOSTED`, `FITID`, broker code, strategy, symbol, size, PnL

7. SYSTEM INDEPENDENCE
   - Tbot must never bypass the accounting system’s validation or export layers.
   - Even in test mode, all simulated trades must flow through ingestion logic and appear in correct ledgers.

----------------------------------------------------------------------
MANDATORY DEPENDENCY MODULES (FROM ACCOUNTING BUILD)
----------------------------------------------------------------------
For tbot-to-ledger integration to function properly, the following accounting modules must be in place:

- Phase 0: Core Framework (`/config.py`, `/utils/db_connection.py`, `/entities/init_db.py`)
- Phase 1: Ingestion Pipeline (`/ingestion/*`, `/processing/normalize.py`, `/logs/logger.py`)
- Phase 4: OFX Export Generator (`/export/generate_ofx.py`)

----------------------------------------------------------------------
RISKS IF IGNORED
----------------------------------------------------------------------
- Ledger corruption and unbalanced entries
- Cross-entity capital contamination
- Regulatory compliance failure (OFX, IRS, SEC)
- Compromised audit integrity
- OFX export failure or tax filing errors
- Inability to distinguish test vs. real trading activity

=============================================================================================================================================
Logging & Reporting Format (Final – Aligned with Single-Broker Architecture)
=============================================================================================================================================

Overview:
Each bot instance writes structured session outputs to support audit trails, dashboards, compliance reports, and downstream ingestion. Log outputs and ledgers are scoped **exclusively to the assigned broker, entity, and bot ID**, with no runtime mode switching.

All filenames and outputs are governed by `.env_bot` and `accounting_config.py`.

Output Scope:
- Logs, trade history, summaries, and unresolved order events
- All files include the bot ID, strategy name, and timestamp when applicable
- Files are separated by type: strategy logs, trade logs, daily summaries

--------------------------------------------------------------------------------
Primary Output Directories
--------------------------------------------------------------------------------

- `output/logs/`          → strategy execution logs, error traces, broker-level issues  
- `output/trades/`        → per-session trade history logs (`csv` or `json`)  
- `output/summaries/`     → final summaries of strategy performance and PnL  
- `backups/`              → auto-archived versions of logs and ledgers (rotated)

--------------------------------------------------------------------------------
Filename Structure
--------------------------------------------------------------------------------

| Type                  | Example Filename Format                                     | Notes                                       |
|-----------------------|-------------------------------------------------------------|---------------------------------------------|
| Strategy Logs         | `open.log`, `mid.log`, `close.log`                          | One per strategy, scoped to bot session     |
| Trade History         | `trade_history.csv`, `trade_history.json`                  | Includes all executed trades                |
| Unresolved Orders     | `unresolved_orders.log`                                     | Captures rejects, partial fills, etc.       |
| Daily Summary         | `daily_summary.json`                                        | One per session, includes PnL, stats        |

All filenames are stored relative to the executing bot’s `output/` subdirectories.

--------------------------------------------------------------------------------
Log Format Configuration
--------------------------------------------------------------------------------

Set via `.env_bot`:

- `LOG_FORMAT=csv` → human-readable output  
- `LOG_FORMAT=json` → structured output for parsing, dashboards, ingestion

Only one format is written per session based on this variable.

--------------------------------------------------------------------------------
Required Fields – `trade_history.json`
--------------------------------------------------------------------------------

Each entry must include:

- `timestamp`          → ISO 8601 UTC timestamp  
- `strategy_name`      → open, mid, or close  
- `ticker`             → equity or ETF symbol  
- `side`               → long or short  
- `size`               → share or contract count  
- `entry_price`        → float  
- `exit_price`         → float  
- `PnL`                → float (realized only)  
- `broker`             → string from `.env_bot`  
- `error_code`         → if applicable (e.g., rejection, partial)

--------------------------------------------------------------------------------
Ledger Routing – Single-Broker Enforcement
--------------------------------------------------------------------------------

All trades are routed to the correct ledger using:

- Bot-assigned entity code  
- Jurisdiction code  
- Broker code  
- Bot ID  
- Ledger name suffix: `_BOT_ledger.db`




**Ledger path format:*
output/ledgers/{ENTITY_CODE}{JURISDICTION_CODE}/ledgers/bot/{ENTITY_CODE}{JURISDICTION_CODE}{BROKER_CODE}_{BOT_ID}_BOT_ledger.db

Example:

output/ledgers/TEST_USA_ALPACA_01_TB.db 

This is enforced by the accounting system. The bot **never selects its own ledger path**.

--------------------------------------------------------------------------------
Export + Archive Flow
--------------------------------------------------------------------------------

1. `reporting_bot.py` collects trade logs post-session  
2. `accounting_api.py` submits all entries to ingestion pipeline  
3. `accounting_config.py` resolves final ledger and export destinations  
4. `generate_ofx.py` emits OFX 1.x/2.x output  
5. `auto_backup.py` archives all logs and ledgers (timestamped)

--------------------------------------------------------------------------------
Key Principles
--------------------------------------------------------------------------------

- Logs are **parallel audit artifacts** — never re-imported into ledgers  
- No separation of live vs paper trades — bot operates on one ledger only  
- Accounting system handles test/live classification **externally** via assigned ledgers  
- All outputs must be fully deterministic, timestamped, and account-mapped

--------------------------------------------------------------------------------
Use Cases
--------------------------------------------------------------------------------

- Daily PnL reports  
- Internal audit and compliance verification  
- Real-time dashboard ingestion  
- Historical trade analysis  
- Export to regulatory or tax systems via OFX



=============================================================================================================================================
Ledger Chart of Accounts (Final – Single-Broker TBot Architecture)
=============================================================================================================================================

This chart of accounts defines the structure for all TBot-generated SQLite ledgers, which are OFX-compliant and maintained under the accounting system’s `entities/{ENTITY_CODE}_{JURISDICTION_CODE}/ledgers/bot/` directory.

Each bot instance writes only to its assigned ledger file:
`output/ledgers/{ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_ledger.db`

------------------------------------------------------------------------------------------
TBot Execution Ledger – Chart of Accounts (BOT-Only Scope) pre-determined prefix
------------------------------------------------------------------------------------------

1000 Bank and Cash Accounts [Cash & Cash Equivalents]  
├── 1010 Float Injection – From Parent  
├── 1020 Float Returned – To Parent  
├── 1030 Broker Cash Balance  

1100 Assets [Broker Holdings]  
├── 1110 Brokerage Account – Equities  
├── 1120 Brokerage Account – Options (if used)  

2000 Liabilities [Operating Activities]  
├── 2010 Broker Payables (Accrued Fees)  
├── 2020 Market Data Payables  

3000 Equity [Capital Structure]  
├── 3010 Capital Float Ledger  
├── 3020 Float Allocation History  
├── 3030 Opening Balance  
├── 3040 Accumulated Profit  

4000 Income [Realized PnL]  
├── 4010 Realized Gains – Equities  
├── 4020 Realized Gains – Options  
├── 4030 Qualified Dividends  
├── 4040 Short-Term Gains  
├── 4050 Long-Term Gains  

5000 Expenses [Execution Overhead]  
├── 5010 Broker Fees  
├── 5020 Slippage / Execution Loss  
├── 5030 API / Market Data Penalties  
├── 5040 Bot Infrastructure  

9100 Exports [Session Export Control]  
├── 9110 Daily PnL Export – OFX  
├── 9120 Trade Log Export (CSV/JSON)  
├── 9130 Ledger Backup Archive  
├── 9140 Confirm Archive (PDFs)  
├── 9150 End-of-Day Snapshot  

9200 Execution Meta [Trade Attribution + Logging]  
├── 9210 Trade UUID  
├── 9220 Confirm #  
├── 9230 Strategy Tag  
├── 9240 Source Tag  
├── 9250 Sync Confirmation Flag  
├── 9260 Reconciliation Success Flag  

9300 System Integrity [Ledger Health Flags]  
├── 9310 Rejects and Order Failures  
├── 9320 Manual Adjustments  
├── 9330 Ledger Lock Flag  
├── 9340 Ledger Status (ACTIVE / DECOMMISSIONED)  
├── 9350 Final Timestamp Written  
├── 9360 Debug / Signal Annotations  

------------------------------------------------------------------------------------------
Export Constraints and System Enforcement
------------------------------------------------------------------------------------------

- All `.csv` or `.json` logs are **external audit artifacts** and never parsed into the ledger  
- Only validated, reconciled trade data is written to the ledger after each strategy session  
- Each ledger must pass integrity validation before export  
- If ledger fails schema or double-entry validation, export process will abort  
- Export system relies on:
  - `/config.py`  
  - `/utils/db_connection.py`  
  - `/entities/init_db.py`  
  - `/ingestion/` modules  
  - `/processing/normalize.py`  
  - `/logs/logger.py`  
  - `/export/generate_ofx.py`  

All ledger structures must comply with OFX alignment to ensure downstream export, tax prep, and inter-system reconciliation.





=============================================================================================================================================
Secure Environment Variables
=============================================================================================================================================

Overview: TradeBot separates its runtime configuration into two environment files: .env contains broker credentials, API keys, encryption keys, and SMTP credentials. .env_bot defines trading logic, timing, strategy settings, and risk controls.

Security Goals: Never expose .env_bot contents in plaintext on shared systems. Ensure only validated and decrypted variables are loaded during runtime. Allow encrypted deployment on remote servers (e.g., DigitalOcean) without exposing raw configuration.

Encryption System: .env_bot is encrypted using AES-256 via the cryptography module. The encrypted version is saved as .env_bot.enc. Decryption Key: Defined in the global .env file under ENCRYPTION_KEY="your-256-bit-key"

Required Files: encrypt_env_bot.py: Handles encryption and decryption of the .env_bot file, and writes the encryption key to the .env file. encrypt_password.py: CLI tool to encrypt login credentials for the web interface and write the encryption keys to the .env file.

Encryption Workflow:
Create .env_bot: Start with a plaintext .env_bot file and populate it with all necessary variables.

Encrypt .env_bot: Run encrypt_env_bot.py to generate .env_bot.enc and store the ENCRYPTION_KEY securely inside .env.

Runtime Decryption: During runtime, env_bot.py will: Load and decrypt .env_bot.enc using the key from .env. Validate all keys, and raise readable errors if any are missing or malformed.

Manual Encryption Example: To manually encrypt the .env_bot file, use: python3 encrypt_env_bot.py

Security Notes: Never include .env_bot or .env_bot.enc in version control or build packages. Use .scpignore and .gitignore to ensure these files are excluded from commits. Encrypted files should only be decrypted in-memory or on secure systems. Ensure that access to .env and .env_bot.enc is restricted on production environments.

Best Practices: Test decryption and validation in a staging environment before deploying to production. Rotate encryption keys regularly, especially if deployment environments or personnel change. Log any failed decryptions or missing variables to unresolved_orders_*.log files for auditing.

Recovery: If .env_bot.enc is corrupted or decryption key is lost: Retrieve the latest .env_bot backup from /backups/. Re-encrypt using encrypt_env_bot.py.



=============================
Modular Strategy Reporting & Audit Output Specification
=============================


Objective:
Support robust, per-strategy reporting for live audit, optimization, and real-time validation of TradeBot behavior.


1. Ensure separate logs and summaries per strategy
Each strategy must write:
- `open.log`, `mid.log`, `close.log`
- `trade_history.json`, `trade_history.csv`
- `daily_summary.json`

Required fields in all logs and trade records:
- strategy_name
- signal trigger time
- entry and exit timestamps
- trade side (long/short)
- entry/exit price
- size, PnL
- broker
- exit reason (e.g., stop_loss, timeout)

2. Daily summary metrics
Ensure `daily_summary.json` includes:
- win rate per strategy
- total trades
- average PnL per trade
- max gain/loss
- trade count vs. signals triggered
- average holding time
- most profitable + worst tickers

3. Optional UI reporting via `tbot_web`
Expose core metrics via Flask dashboard:
- Win rate, PnL, trade count (open/mid/close)
- JSON log stats to `status.html`
- Optional: chart overlays for PnL/trade count trends

4. Runtime validation
In `env_bot.py`, enforce that these keys are present:
- `ENABLE_LOGGING=true`
- `LOG_FORMAT=json` or `csv`

Raise a fatal error if any are missing.

- `tuning_tracker.py`
  - Load and compare strategy logs over time
  - Recommend optimized values for STRAT_*_BUFFER, VWAP thresholds
  - Export table with:
    - buffer → win%, avg PnL, trade duration
    - rejection counts
    - ticker frequency


=============================================================================================================================================
Centralized Error Management
=============================================================================================================================================

Overview:
- TradeBot uses `error_handler.py` to capture runtime exceptions, prevent silent failures, and manage system stability.

Emergency Event Matrix:

| Event | Detection Module | Scope | System Response | Reboot |
|-------|------------------|-------|------------------|--------|
| PnL Loss > DAILY_LOSS_LIMIT | kill_switch.py | Broker | Halt broker trades, log shutdown | No |
| Broker API Down | watchdog_bot.py | Broker | Suspend broker until recovery | No |
| Market Data Feed Down | watchdog_bot.py | All | Trigger stop_bot.py | Yes |
| .env_bot Decryption Fail | security_bot.py | All | Block launch, log | Yes |
| Logic Error | error_handler.py | Varies | Escalate if critical | Yes (if escalated) |
| Defense Mode On | risk_bot.py + .env_bot | All | Compress risk, limit trades | No |
| Validation Fail | risk_bot.py | Broker | Block trade, log silently | No |
| Manual Shutdown | control_stop.txt | Any | Immediate safe shutdown | Yes |
| System File Fail | build_check.py | All | Abort launch, log | Yes |

error_handler.py:

Captures exceptions from:
- strategy, broker, utility modules

Classifies:
- NetworkError (API issues)
- BrokerError (order rejects, margin)
- LogicError (bad runtime logic)
- ConfigError (.env_bot issues)

Logs to:
- `unresolved_orders.log` in JSON/CSV
- Fields: timestamp, strategy, broker, error_type, error_code, raw_exception

Retry Logic:
- Exponential backoff
- Escalation after `API_RETRY_LIMIT`

Notifications:
- Triggers notifier_bot.py on critical events
- SMTP-configured alerts with context

Kill Switch Integration:
- Calls kill_switch.py on unrecoverable error
- Logs shutdown reason

Optional Dashboard:
- Can integrate with status_web/logs_web (read-only)
- Fully headless by default

Usage:
- Imported in `main_bot.py`
- Exceptions passed to `error_handler.handle()` for classification, logging, audit

Ensures transparent tracking of failed/skipped trades
Backtest Engine (backtest_engine.py)

Purpose:
Simulates historical trades to test and validate strategy logic pre-deployment.

Core:
- Uses same logic from strategy_open.py, strategy_mid.py, strategy_close.py
- Loads minute-level OHLCV from load_historical_data.py
- No broker API interaction; simulation is internal
- Output formats: CSV or JSON to backtest_results/

Runtime:
- Pulls all config from .env_bot
- Toggle filters (volume, price) for sensitivity testing
- Strategies must expose .simulate() method

Supported Strategies:
open, mid, close (must be listed in STRATEGY_SEQUENCE)

Command:
python backtest/backtest_engine.py --strategy=open --start=2023-01-01 --end=2023-12-31 --data_source=./historical_data/open_ohlcv.csv

Args:
--strategy: open/mid/close
--start/--end: date range
--data_source: CSV data path

Performance Metrics (performance_metrics.py):
- Win Rate (%)
- Max Drawdown
- Avg Trade Duration
- Avg PnL per trade
- Sharpe Ratio

Charts:
Generated using plot_results.py to visualize equity curve, drawdown, entry/exit

Ledger Output:
- trade_history_backtest.csv/json
- daily_summary_backtest.json
- No SQLite ledger writes or OFX generation
- Strictly isolated from accounting exports

Logging:
- Follows live format:
  timestamp, strategy_name, ticker, side, size, entry_price, exit_price, PnL, mode=backtest

CI:
- Compatible with GitHub Actions, GitLab CI
- Can load custom .env_bot.test files
- CLI and headless; no UI or web interface required

Requirements:
- Python 3.11+
- pytest, pydantic, and all requirements.txt packages

Notes:
- Stateless, safe for dry-runs
- Backtesting required before new strategy deployment


Does not depend on tbot_api/ or tbot_web/ — fully independent from web interface or broker APIs



=============================================================================================================================================
Testing and Validation Suite
=============================================================================================================================================

Overview:
A robust testing framework ensures that all TradeBot logic executes as expected across strategies, environments, and runtime modes. The following tools, test files, and logic gates are implemented to support validation prior to any live deployment.

Testing Directory Structure:
Located in: `tbot_bot/tests/`

Files:
- `test_main_bot.py` – Verifies lifecycle loop, strategy routing, and logger integrity.
- `test_env_bot.py` – Confirms full variable coverage, validation errors, and defaults in `.env_bot`.
- `test_backtest_engine.py` – Runs simulated trades on sample historical data and verifies consistency with execution rules.
- `test_strategy_selfcheck.py` – Confirms that `.self_check()` returns True across all strategies.
- `test_logging_format.py` – Validates that the log format matches the JSON structure schema.
- `test_broker_trade_stub.py` – Sends randomized micro-trades to broker in to validate order flow, response, and logging.
- `test_screener_random.py` – Runs screener logic with randomized symbols to confirm filtering and eligibility logic.
- `test_strategy_tuner.py` – Executes strategy modules in isolation with test tickers to validate signal logic, threshold configs, and entry/exit paths.
- `integration_test_runner.py` – Launches end-to-end simulation of a trading session 

Planned:
- `test_broker.py` – **Manual test to place one live trade and close it immediately (used for broker readiness validation).** Not yet implemented.

Framework:
- All tests use `pytest` and must be runnable via CLI or CI/CD pipeline.
- Tests are modular and can be run individually or in batches.
- Output formats are compatible with `--junitxml` and CI test reporters.

Example Test Command:
```bash
pytest tbot_bot/tests/


Integration Test Workflow:
- Loads a simulated `.env_bot.test` config.
- Launches `main_bot.py`
- Injects historical price data using mocks or patched inputs.
- Runs `start_bot.py` in dry-run mode.
- Verifies the following:
  - Strategy execution order (based on `STRATEGY_SEQUENCE`)
  - Log generation to the correct files
  - Proper handling of signals, triggers, and errors
  - Trade integrity and structure of all logs and exports

CI Compatibility:
- Compatible with GitHub Actions, GitLab CI, or local test runners.
- All test scripts and outputs are headless (no GUI, web UI, or API calls required).
- Custom `.env_bot.test` config files may be loaded during CI runs with overrides.

Requirements:
- Python 3.11+
- `pytest`, `pydantic`, and all packages listed in `requirements.txt`

Test-Mode Enforcement:
- `integration_test_runner.py` MUST only run with `TEST_MODE=true`.
- All trade outputs are written to logs.
- Test failures are captured and printed to `stdout`/`stderr` immediately.

Version Compliance:
- `test_env_bot.py` must validate that `.env_bot["VERSION_TAG"]` matches `VERSION.md`.
- Build is considered invalid if the version tags are mismatched.



=============================================================================================================================================
Real-Time Monitoring Dashboard
=============================================================================================================================================

The `tbot_web/` dashboard provides live monitoring of bot status, positions, and runtime metrics via background tasks and API polling. It operates independently of trading logic and supports read-only observation without affecting execution.

Displayed metrics include: current active strategy (`strategy_open.py`, `strategy_mid.py`, or `strategy_close.py`), scheduled/actual UTC start times (`.env_bot`), trade counts (signaled, entered, exited), real-time per-position and cumulative PnL, and active position details (ticker, side, size, entry/exit price, unrealized PnL, strategy). Broker/API health is monitored via `watchdog_bot.py`.

Additional metrics: system state (idle, analyzing, trading, shutdown), API retry/error counts, and a test mode indicator.

Frontend pages:
- `status.html`: live bot status (from `output/status.json`)
- `logs.html`: log/alert/error streaming
- `main.html`: dashboard container
- `index.html`: login portal (uses `auth_web.py` AES validation)

Backend modules:
- `status_web.py`: relays `status_bot.py` data
- `logs_web.py`: exposes recent logs
- `start_stop_web.py`: optional session control
- `main_web.py`: Flask route handler
- `login_web.py`: manages encrypted user authentication

Data is served via JSON endpoints with Flask-based polling. Login uses `.env` credentials and AES session encryption. The system supports secure read-only mode with no trade control exposure.

Security: Login attempts are rate-limited (`SlowAPI`). All auth activity is logged to `logs/web/access.log` and `auth_failures.log`.

The dashboard is optional. All bot logic runs independently of `tbot_web/` and remains fully functional if the dashboard is disabled. It is accessible from any device and works in low-bandwidth environments.


=============================================================================================================================================
RIGD GROUP LLC — TradeBot-001 Runtime Flow (Final Full Version)
=============================================================================================================================================

Phase 0: Pre-Session (Preparation)

[ MANUAL ACTION ]
    ↓
- Configure .env_bot (.env if needed)
- Decrypt env_bot.enc using security_bot.py
- Ensure .env includes ENCRYPTION_KEY
- Launch control_start.txt or Web UI portal
    ↓

Phase 1: System Boot Validation

BOOT SEQUENCE INITIATED
    ↓
security_bot.py → Decrypts and loads .env_bot using ENCRYPTION_KEY
    ↓
env_bot.py → Validates all required environment variables
    ↓
self_check() validation for:
    - risk_bot.py
    - kill_switch.py
    - watchdog_bot.py
    - error_handler.py
    - strategy_router.py
    ↓
IF any self_check fails → Abort launch and log to output/logs/error_tracebacks.log
ELSE → Proceed to session initialization
    ↓

Phase 2: Session Initialization

SESSION START
    ↓
float_bot.py → Pull broker float values from accounting system
    ↓
Load runtime parameters from .env_bot:
    - MAX_TRADES, MAX_OPEN_POSITIONS
    - TOTAL_ALLOCATION, WEIGHTS
    - Defense Mode overrides if DEFENSE_MODE_ACTIVE=true
    ↓
status_bot.py → Write initial status to output/status.json
    ↓
BEGIN STRATEGY CYCLE
Phase 3: Strategy Cycle (Open → Mid → Close)

[ At each STRATEGY_UTC_START_TIME ]
    ↓
strategy_router.py → Loads and runs active strategy
    ↓
Strategy-level self_check():
    - Validates timing, broker access, float presence
    ↓
finnhub_screener.py → Load symbol candidates
    ↓
For each eligible symbol:
    - Calculate risk allocation using WEIGHTS
    - Validate risk caps (MAX_RISK_PER_TRADE, MAX_TRADES)
    ↓
If validation passes:
    → broker_api.py → send order via broker adapter (e.g., alpaca.py, ibkr.py)
    → trade_logger.py → log trade to output/trades/
Else:
    → Log to output/logs/unresolved_orders.log
    ↓
Monitor:
    - Trailing stops, VWAP exits, VIX filters
    - API health via watchdog_bot.py
    - PnL via kill_switch.py
    ↓
Strategy phase ends after monitoring window

Phase 4: Risk and Fault Monitoring (Continuous)

During execution:
    ↓
- risk_bot.py enforces ALL caps and Defense Mode overrides
- kill_switch.py watches per-broker DAILY_LOSS_LIMIT
- watchdog_bot.py tracks API connectivity
- error_handler.py logs stack traces to error_tracebacks.log
    ↓
If triggered:
    - kill_switch.py → halt broker trading
    - watchdog_bot.py → suspend broker or halt system
    - All trades tagged if DEFENSE_MODE_ACTIVE=true
    - All events logged to disaster_mode.log and unresolved_orders.log

Phase 5: Session Termination

END OF STRATEGY WINDOWS
    ↓
stop_bot.py closes any remaining positions
    ↓
reporting_bot.py writes:
    - trade_history.csv/json
    - open.log, mid.log, close.log
    - daily_summary.json
    - disaster_mode.log if applicable
    ↓
accounting_api.py → Ingests trades into assigned ledger:
    → entities/{ENTITY}_{JURIS}/ledgers/bot/{ENTITY}{JURIS}{BROKER}_{BOT_ID}_BOT_ledger.db
    ↓
auto_backup.py → Archives logs and ledgers to backups/
    ↓
status_bot.py → Marks session status as "CLOSED"
    ↓
SESSION COMPLETE

Phase 6: Manual Review and Rebalancing (Post-Session)

- Review logs, trade history, daily summary
- Reconcile float via accounting system
- Run generate_ofx.py if export needed
- If DEFENSE_MODE was triggered, adjust .env_bot flag and document recovery plan

=============================================================================================================================================
Key Design Confirmations
=============================================================================================================================================

Key Design Confirmations:
- All trades execute through a single assigned broker per bot instance, with float, risk, and PnL enforced via the accounting system.
- System-wide shutdowns occur only for critical failures (global market data outage, broker API unresponsive, core logic errors).
- Defense Mode activates automatically on drawdown or win-rate triggers and enforces:
  - Reduced TOTAL_ALLOCATION
  - Scaled-down MAX_TRADES
  - Stricter filters (VWAP, ADX, Bollinger)
- Full audit trail is maintained across:
  - Structured logs (`output/logs/`)
  - Trade history (`output/trades/`)
  - Daily summary (`output/summaries/`)
  - Ledger ingestion and OFX exports (`entities/{ENTITY}_{JURIS}/ledgers/bot/`)
- The Web Dashboard (`status.html`, `status_web.py`) reflects real-time strategy state, float usage, broker health, and session metrics.


=============================================================================================================================================
TradeBot Master Build Enhancements
=============================================================================================================================================
TradeBot Master Build Enhancements (post-stabilization) include:

1. Automated Rebalance Triggers:
- Define float deviation thresholds in `.env_bot` (e.g., >10% triggers).
- `rebalance_notifier.py` compares actual vs. target float via accounting API and sends POST notification (`acct_api_credentials.json.enc`).
- Accounting system handles ACH, ledger sync; bot only issues trigger.
- Events logged to `rebalance_request.log` and must generate OFX-aligned audit entries.
- Integrates with `risk_bot.py` and `kill_switch.py` for trade pausing or halt.

2. Multi-User Access Roles (RBAC):
- Extend `tbot_web/` to support roles: `admin`, `operator`, `auditor`, `viewer`.
- Secure login via bcrypt; user roles stored in `SYSTEM_USERS.db`.
- Access logs: `logs/web/access.log`, `auth_failures.log`.

3. Strategy Optimization:
- `strategy_optimizer.py` runs periodic backtests (past N days).
- Uses grid search, genetic, or Bayesian methods to tune entry/exit buffers and VWAP thresholds.
- Results saved in `backtest_results/strategy_tuning/`; configs versioned under `env_bot.versioned/`.
- Human approval required before use—no auto-activation.

4. Real-Time Alerting:
- `notifier_bot.py` supports Slack, PagerDuty, SMS.
- `.env_bot` configures: `CRITICAL_ALERT_CHANNEL`, `NOTIFY_ON_FILL`, `NOTIFY_ON_EXIT`, `NOTIFY_ON_FAILURE`.
- Alerts include timestamp, strategy, ticker, PnL, and root trigger.

5. Slippage & Latency Simulation:
- `backtest_engine.py` supports latency (e.g., 500ms) and slippage modeling:
  - Rule-based (fixed %)
  - Randomized (historical distribution)
- Config via `.env_bot.test`; output to `backtest_slippage_comparison.json`.

Implementation:
- All enhancements must include `.self_check()`, be modular/toggled via `.env_bot`, and log to their own files.
- Must not interfere with live logic if disabled.
- Priority: safety, scalability, auditability, and runtime integrity for both single- and multi-broker models.

=============================================================================================================================================
Final Build Checklist 
=============================================================================================================================================

Configuration:
- `.env`: includes `ENCRYPTION_KEY`, SMTP, IP/PORT, login toggles.
- `.env_bot`: loaded or decrypted from `.env_bot.enc`; must include all strategy/risk/logging vars; `VERSION_TAG` matches `VERSION.md`.

Environment Validation:
- `env_bot.py` validates structure/keys.
- `.env_bot.template-test` must be complete with inline comments.

Strategy Logic:
- `main.py` loads `STRATEGY_SEQUENCE`.
- `strategy_*.py` modules implement/pass `.self_check()`.
- All constraints enforced (volume, slippage, spread, blocklist).

Logging:
- Logs routed via `accounting_config.py`; entries include timestamp, ticker, size, prices, strategy, float source.
- Output:
  - `output/logs/` — strategy + error logs
  - `output/trades/` — trade history
  - `output/summaries/` — session summary
- Archived via `auto_backup.py`; `LOG_FORMAT` from `.env_bot`.

Ledger & Accounting:
- `reporting_bot.py` gathers trade logs.
- `accounting_api.py` routes exports to ingestion.
- Output path: `entities/{ENTITY}_{JURIS}/ledgers/bot/{ENTITY}{JURIS}{BROKER}_{BOT_ID}_BOT_ledger.db`
- Validated schema (`ledger_schema.py`), OFX-compliant, double-entry, currency-tagged.
- `generate_ofx.py` handles export; backups go to `/backups/`.

Broker Routing:
- `broker_api.py` dispatches to one assigned broker.
- `watchdog_bot.py` monitors broker connection and order health.

Risk/Shutdown:
- `kill_switch.py`: stops on `DAILY_LOSS_LIMIT`.
- `risk_bot.py`: enforces session limits, trade sizing, strategy constraints.
- `error_handler.py`: logs uncaught errors.
- `stop_bot.py`: closes open trades, marks status/logs shutdown reason.

Notifications:
- `notifier_bot.py` sends alerts if enabled (`.env` SMTP + `.env_bot` toggles).
- Suppresses non-critical alerts if configured.

Testing & QA:
- Dry run validated using actual ledgers.
- All `pytest` tests in `tbot_bot/tests/` pass.
- `integration_test_runner.py` simulates full bot lifecycle.
- `test_broker.py` executes real trade manually.
- No references to deprecated modes; all backtests are sandboxed.

Web Interface:
- Flask app uses encrypted login (`encrypt_password.py`, `ENCRYPTED_PASSWORD`).
- Start/stop via `control/control_start.txt` and `control/control_stop.txt`.
- UI routes (`/status`, `/logs`, `/settings`) reflect session; RBAC enforced.

Deployment:
- Paths are relative, cross-platform.
- Flask and bot run as separate processes: `start_bot.py`, `service_bot.py`.
- Sensitive files excluded via `.scpignore_*`.
- `.env_bot` version matches `VERSION.md`.
- Final outputs backed up; no temp/test files in repo.

Post-Session Rebalance:
- If float deviation > `REBALANCE_THRESHOLD`, notify accounting.
- `rebalance_bot.py` emits signal; accounting system handles transfers.
- All triggers are logged and timestamped.




































