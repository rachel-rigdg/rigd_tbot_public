Document 02-rigd_tbot_Build Instructions_V038.txt


Please read and internalize all content in this thread. Acknowledge that you fully understand the Objective, System Instructions, and complete architecture of the system before proceeding. This session is part of an active build process and requires strict adherence to the documented structure and rules.


==============================
Objective (UPDATED)
==============================

TradeBot (TBot) executes bi-directional trades using long equity for bullish signals and inverse ETFs or long puts for bearish signals, strictly determined by SHORT_TYPE_* values in .env_bot. Brokers must support long equity and at least one approved bearish instrument (long put or inverse ETF) per assignment.

The system operates intraday strategies in real time with fully automated, risk-weighted execution. All risk controls are enforced exclusively via .env_bot parameters (DAILY_LOSS_LIMIT, MAX_RISK_PER_TRADE, TOTAL_ALLOCATION, MAX_OPEN_POSITIONS, etc.). **All trade output is logged immutably to OFX-compliant, entity-scoped SQLite ledgers with double-entry enforcement and UTC timestamps.**

**Bot bootstrap is initiated solely through a required Web UI submission (`configuration.html`), which invokes `configuration_web.py` and the required init scripts.** This is the exclusive entry point for creating users, credentials, system logs, identity metadata, and initial Chart of Accounts (COA)—CLI-based initialization is explicitly forbidden.

**COA Management and Editing:**
- The bot's Chart of Accounts (COA) is self-contained and managed entirely within the bot instance.
- **All COA creation, updates, and human-readable exports are performed via a dedicated COA Management page in the tbot_web UI.**
- The default COA is generated on initial bootstrap and can be viewed or modified only through the Web UI. CLI or accounting system pushes are not permitted.
- COA metadata is stored in the `coa_metadata` table with all required versioning and extensibility fields.

**The accounting system is responsible for providing:**
- The entity-scoped ledger path,
- Broker/float/weight/override metadata,
- Encrypted config (.env_bot.enc, decrypted only with `storage/keys/env.key`),
- All float injections, reserves, and transfers (TradeBot does not manage float or account linkage directly).

**Ledger and trade routing rules:**
- All execution toggles are set via `.env_bot` (`ALPACA_ENABLED`, `IBKR_ENABLED`, etc.), with per-strategy toggles (`STRAT_OPEN_ENABLED`, `STRAT_MID_ENABLED`, `STRAT_CLOSE_ENABLED`).
- **All trades and PnL activity must write to `{ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_ledger.db`**, with all ledger paths resolved and injected by the accounting system at runtime—never hardcoded, inferred, or guessed by the bot.
- **The bot may not read, manage, or calculate float directly; all float, injection, reserve, and allocation events originate from and are logged by the accounting system.**

PnL, float tracking, and revenue movements are ingested, reconciled, and logged only via the accounting system. TEST_MODE is deprecated and fully removed; all test routines are executed strictly via tbot_bot/test/ modules only.


==============================
System Instructions 
==============================

1. All environment-specific values MUST be sourced ONLY from `.env`, `.env_enc`, `.env_bot`, `.env_bot.enc`. No hardcoded API keys, thresholds, credentials, toggles, file paths, or mode flags. `DISABLED ≠ OMITTED`: All logic must explicitly evaluate suppressed (disabled) states.

2. Inline comments REQUIRED in all generated code: logic branches, `.env_bot` references, and all condition paths must be clearly explained.

3. All file paths must be relative and platform-agnostic. Code must run unmodified on macOS, Linux, and all prod servers.

4. Ledger routing: All trade activity writes to accounting system’s OFX-compliant, entity-scoped SQLite ledger. Ledger filename: `{ENTITY_CODE}_{JURISDICTION_CODE}_{account_name}_{BROKER_CODE}_{BOT_ID}_BOT_ledger.db` (account_name = lowercase ledger tag). **Ledger path is injected by the accounting system; the bot NEVER determines it.** All ledger writes must be preceded by a backup. Test modules under `tbot_bot/test/` may simulate trade placement but **must NEVER alter or bypass production ledger logic**.

5. NO re-ingestion of `.csv` or `.json` logs permitted: external audit artifacts only.

6. Every strategy module must implement `.self_check()`. `main.py` must halt if any `.self_check()` fails. Failures must log strategy, reason, error context, with UTC timestamp.

7. `env_bot.py` must validate all required keys from `.env_bot.enc`, decrypted using `storage/keys/env.key`. Missing/malformed keys must raise a fatal, human-readable startup error.

8. Logs and ledger outputs must include: `timestamp`, `strategy_name`, `ticker`, `side`, `size`, `entry_price`, `exit_price`, `PnL`, `broker`, `error_code` (if applicable). Logs must use global `LOG_FORMAT` (CSV/JSON) from `.env_bot`.

9. `VERSION.md` is mandatory: must include version tag, structural changes, logic differences, and behavior deltas.

10. All modules must remain executable independently. Core logic (`tbot_bot/`) must NEVER import from Flask or `tbot_web/`. Web UI is independent and must not affect trading logic or risk controls. **Bootstrap scripts (`init_system_users.py`, `init_system_logs.py`, etc.) are executed ONLY via the Web UI upon `configuration.html` form submission, triggered by `configuration_web.py`. CLI-based bootstrap of user/credential/log systems is no longer supported.**

11. Strategy routing and broker enablement must be toggled ONLY via `.env_bot`: `ALPACA_ENABLED`, `IBKR_ENABLED`, `STRAT_OPEN_ENABLED`, `STRAT_MID_ENABLED`, `STRAT_CLOSE_ENABLED`.

12. **The Chart of Accounts (COA) for the bot is fully self-contained and managed solely through a dedicated COA Management page in the tbot_web UI. All creation, modification, and export of the COA must occur via the Web UI. No CLI utilities, accounting system pushes, or external edits are permitted. The COA must be versioned, validated at runtime, and stored as both a JSON structure and a SQLite metadata table.**

13. Improvisation is FORBIDDEN. Clarify ambiguities before code changes. STRICT deterministic, auditable logic only.


============================================================
 .env / .env_enc – Top-Level Environment Configuration
============================================================

# This file is parsed by tbot_bot/, tbot_web/, and related utility scripts.
# It references secure decryption keys only — no raw credentials are stored here.

# Core Environment Settings
ENVIRONMENT=production
CONTROL_DIR=control
ENV_BOT_PATH=.env_bot

# Encrypted Credential Keys
ENV_KEY_PATH=storage/keys/env.key
LOGIN_KEY_PATH=storage/keys/login.key
BROKER_KEY_PATH=storage/keys/broker.key
SMTP_KEY_PATH=storage/keys/smtp.key
SCREENER_API_KEY_PATH=storage/keys/screener_api.key
ACCT_API_KEY_PATH=storage/keys/acct_api.key

# Encrypted Secrets (Resolved at Runtime)
BROKER_CREDENTIALS_PATH=storage/secrets/broker_credentials.json.enc
SMTP_CREDENTIALS_PATH=storage/secrets/smtp_credentials.json.enc
SCREENER_API_PATH=storage/secrets/screener_api.json.enc
ACCT_API_CREDENTIALS_PATH=storage/secrets/acct_api_credentials.json.enc
NETWORK_CONFIG_PATH=storage/secrets/network_config.json.enc
ALERT_CHANNELS_PATH=storage/secrets/alert_channels.json.enc
ALERT_KEY_PATH=storage/keys/alert.key

# Session / Login Controls
SESSION_TIMEOUT=3000
LOGIN_ATTEMPT_LIMIT=10
LOGIN_LOCKOUT_MINUTES=15
SESSION_TIMEOUT_MINUTES=120



================================================================================
 .env_bot / env_bot.enc – Trading Bot Configuration File
================================================================================

# .env_bot – TradeBot Configuration v1.0.0+
# All strategy logic, broker routing, and runtime behavior are driven by this file.
# Time values are specified in UTC. Comments indicate usage and system impact.
# -----------------------------------------
# General & Debugging
# -----------------------------------------
# Version tag (must match VERSION.md)
VERSION_TAG=v1.0.0
# debug or release – sets internal behavior and logging verbosity
BUILD_MODE=release
# Master kill switch to block all trading activity
DISABLE_ALL_TRADES=false
# Logging level: quiet, info, or verbose
DEBUG_LOG_LEVEL=verbose
# Enable writing log files to /logs and /backups
ENABLE_LOGGING=true
# json (structured) or csv (flat) log output format
LOG_FORMAT=json
# -----------------------------------------
# Trade Execution & Risk Controls
# -----------------------------------------
# If true, bot will wait for manual confirmation before sending trades
TRADE_CONFIRMATION_REQUIRED=false
# Number of times to retry failed broker API calls      
API_RETRY_LIMIT=3
# how many seconds before timeout 
API_TIMEOUT=30
# Allow fractional shares (broker must support)
FRACTIONAL=true
# Total capital allocated per strategy session (e.g., 2% of account)
TOTAL_ALLOCATION=0.02
# Max number of trades allowed per strategy window
MAX_TRADES=4
# Trade weight percentages based on number of triggered trades
WEIGHTS=0.4,0.2,0.2,0.2
# Absolute loss limit (e.g., 5% of capital); triggers shutdown
DAILY_LOSS_LIMIT=0.05
# Maximum allocation per trade based on account value (2.5%)
MAX_RISK_PER_TRADE=0.025
# Cap on total simultaneous positions across all strategies
MAX_OPEN_POSITIONS=5                   
# -----------------------------------------
# Price & Volume Filters
# -----------------------------------------
# Minimum price allowed per trade
MIN_PRICE=5
# Maximum price allowed per trade
MAX_PRICE=100
# Minimum volume filter 
MIN_VOLUME_THRESHOLD=1000000       
# Finnhub Guard filter 
ENABLE_FUNNHUB_FUNDAMENTALS_FILTER=true
MAX_PE_RATIO=50
MAX_DEBT_EQUITY=2.5
# -----------------------------------------
# Strategy Routing & Broker Mode
# -----------------------------------------
# Broker Name (Options: ALPACA, IBKR, TRADIER, etc.)
BROKER_NAME="ALPACA"  
# Strategy run order; values: open, mid, close
STRATEGY_SEQUENCE=open,mid,close
# Optional: override normal order and run only one strategy
STRATEGY_OVERRIDE=
# -----------------------------------------
# Automated Rebalance Triggers
# -----------------------------------------
# Master toggle for automated rebalancing
REBALANCE_ENABLED=true     
# Trigger threshold (fractional, e.g., 0.10 = 10% deviation)              
REBALANCE_THRESHOLD=0.10     
# Check interval in seconds (default: 3600s = 1 hour)            
REBALANCE_CHECK_INTERVAL=3600           
# -----------------------------------------
# Failover Broker Routing
# -----------------------------------------
# Master toggle for failover routing
FAILOVER_ENABLED=true                
# Tag applied to rerouted trades in logs/ledgers
FAILOVER_LOG_TAG=FAILOVER_ACTIVE         
# -----------------------------------------
# Global Time & Polling
# -----------------------------------------
# Days allowed for trading (UTC-based control logic)
TRADING_DAYS=mon,tue,wed,thu,fri
# Interval between polling cycles for runtime monitoring
SLEEP_TIME=1s
# -----------------------------------------
# OPEN Strategy Configuration (20 min trading)
# -----------------------------------------
# Maximum gap allowed from open to current price (used in screener)
MAX_GAP_PCT_OPEN=0.1
# Minimum and maximum market cap allowed for OPEN strategy candidates
MIN_MARKET_CAP_OPEN=2000000000
MAX_MARKET_CAP_OPEN=10000000000
# Enable or disable OPEN strategy
STRAT_OPEN_ENABLED=true
# UTC start time (market open = 9:30 AM EST)
START_TIME_OPEN=14:30
# Minutes to track high/low range before breakout
OPEN_ANALYSIS_TIME=20
# Minutes to for breakout to happen
OPEN_BREAKOUT_TIME=10
# Minutes to monitor active positions
OPEN_MONITORING_TIME=30
# Breakout threshold above high/low range (e.g., 2%)
STRAT_OPEN_BUFFER=0.02
# Shorting method: InverseETF, disabled, ShortSell, LongPut,
SHORT_TYPE_OPEN= InverseETF               
# -----------------------------------------
# MID Strategy Configuration (VWAP Reversion)
# -----------------------------------------
# Maximum gap allowed from open to current price (used in screener)
MAX_GAP_PCT_MID=0.1
# Minimum and maximum market cap allowed for MID strategy candidates
MIN_MARKET_CAP_MID=2000000000
MAX_MARKET_CAP_MID=10000000000
# Enable or disable MID strategy
STRAT_MID_ENABLED=true
# UTC start time (10:30 AM EST)
START_TIME_MID=15:30
# Minutes before trade signal is evaluated
MID_ANALYSIS_TIME=15
# Minutes to for breakout to happen
MID_BREAKOUT_TIME=10
# Maximum hold time after entry
MID_MONITORING_TIME=30
# VWAP deviation required to enter trade
STRAT_MID_VWAP_THRESHOLD=0.02
# Shorting method: InverseETF, ShortSell, LongPut,  or disabled
SHORT_TYPE_MID= InverseETF              
# -----------------------------------------
# CLOSE Strategy Configuration (EOD Momentum/Fade)
# -----------------------------------------
# Maximum gap allowed from open to current price (used in screener)
MAX_GAP_PCT_CLOSE=0.1
# Minimum and maximum market cap allowed for CLOSE strategy candidates
MIN_MARKET_CAP_CLOSE=2000000000
MAX_MARKET_CAP_CLOSE=10000000000
# Enable or disable CLOSE strategy
STRAT_CLOSE_ENABLED=true
# UTC start time (2:30 PM EST)
START_TIME_CLOSE=19:30
# Minutes to detect signal
CLOSE_ANALYSIS_TIME=5
# Minutes to for breakout to happen
CLOSE_BREAKOUT_TIME=5
# Duration to manage position after entry
CLOSE_MONITORING_TIME=25
# Min VIX level required to allow entry
STRAT_CLOSE_VIX_THRESHOLD=15
# Shorting method: InverseETF, ShortSell, LongPut, or disabled
SHORT_TYPE_CLOSE= InverseETF               
# -----------------------------------------
# Notifications
# -----------------------------------------
# Send email alert on trade entry
NOTIFY_ON_FILL=true
# Send email alert on trade exit
NOTIFY_ON_EXIT=true                    
# -----------------------------------------
# Reporting & Ledger Export
# -----------------------------------------
# auto = export after each trade, off = no export
LEDGER_EXPORT_MODE=auto
# -----------------------------------------
# Defense Mode (Disaster Risk Reduction)
# -----------------------------------------
# Set true if Disaster Protocol triggers; resets to false on recovery
DEFENSE_MODE_ACTIVE=false
# Percentage of normal MAX_CONCURRENT_TRADES allowed (rounded down)
DEFENSE_MODE_TRADE_LIMIT_PCT=66
# Maximum session allocation allowed during Defense Mode (e.g., 1%)
DEFENSE_MODE_TOTAL_ALLOCATION=0.01
# -----------------------------------------
# ENHANCEMENT MODULE TOGGLES 
# -----------------------------------------
# --- Rebalance Notification ---
ENABLE_REBALANCE_NOTIFIER=true
# Notify accounting if float deviates ±10% from target
REBALANCE_TRIGGER_PCT=10                         
# --- Role-Based Web Access ---
# Enable multi-user roles in web dashboard
RBAC_ENABLED=true
# Default role for new users                                
DEFAULT_USER_ROLE=viewer
# --- Strategy Optimizer ---
ENABLE_STRATEGY_OPTIMIZER=true
# Historical days for parameter tuning
OPTIMIZER_BACKTEST_LOOKBACK_DAYS=30
# Options: grid_search, bayesian, genetic              
OPTIMIZER_ALGORITHM=grid_search                
OPTIMIZER_OUTPUT_DIR=backtest_results/strategy_tuning/
# --- Real-Time Alerts ---
NOTIFY_ON_FILL=true
NOTIFY_ON_EXIT=true
NOTIFY_ON_FAILURE=true
 # Options: email, slack, sms, pagerduty
CRITICAL_ALERT_CHANNEL=pagerduty
# Options: email, slack                
ROUTINE_ALERT_CHANNEL=email
# --- Backtest Slippage Modeling ---
ENABLE_SLIPPAGE_MODEL=true
# Options: none, rule_based, randomized
SLIPPAGE_SIMULATION_TYPE=randomized
 # Average slippage %              
SLIPPAGE_MEAN_PCT=0.15 
# Standard deviation                         
SLIPPAGE_STDDEV_PCT=0.10
 # Artificial delay (in milliseconds) per order                         
SIMULATED_LATENCY_MS=500                        
# --- black_scholes_filter Enhancements (if applicable) ---
ENABLE_BSM_FILTER=true
# Reject if >15% over/under priced
MAX_BSM_DEVIATION=0.15
# Used in BSM if not supplied dynamically              
RISK_FREE_RATE=0.045
# Options: static, dynamic — dynamic adjusts by JURISDICTION_CODE via bot_identity                
RISK_FREE_RATE_SOURCE=dynamic       





================================================================================
Overall Directory Structure Diagram (Accounting-System Integrated)
================================================================================

rigd_tbot/
│
├── VERSION.md                       # Version change log for human or GPT reference
├── CHANGELOG.md                     # Technical commit-style change history (optional)
├── README.md                        # Project overview, architecture, and usage instructions
├── requirements.txt                 # Python package dependencies
├── .env                             # plaintext Global config (Flask port, encryption keys, login)
├── .env_bot                         # plaintext Decrypted bot settings (overwritten each run if using encrypted version)
├── .env_bot.template-test           # Example/test-mode config for cloning bots
├── .scpignore_env                   # Excludes only env/config
├── .scpignore_dev                   # Excludes test scripts, logs, debug files
├── .scpignore_enc                   # Used when deploying encrypted-only configs
├── .scpignore_prod_archive          # Used when deploying archive packages (no .env, no accounting ledgers, etc.)
│   
├── tools/				# Encryption / Auth Tools
│   ├── encrypt_password.py          # AES-encrypts login password and updates .env
│   ├── encrypt_env_bot.py           # Encrypts .env_bot and saves it as env_bot.enc
│   └── sync_project.sh              # CLI interface for dev→live→prod folder syncs
│   
├── backups/                         # Runtime Output / Audit Artifacts - Archived logs and reports (daily snapshots)
│   └──  logs_*.zip                   # Zipped logs (all modes)
│       └── summary_*.json               # JSON performance reports
│    
├── logs/                            # Active logging folder (rotated or zipped by auto_backup)
│   ├── bot/
│   │   └── sessions/                # Logs per strategy and session
│   └── web/			 # Web authentication and access logs — supports multi-user login, audit trails
│       ├── access.log               # IP/timestamp of each login request
│       └── auth_failures.log        # Failed login attempts, lockout triggers
│    
├── support/				# Internal Documentation
│   ├── architecture.md              # System architecture and module breakdown
│   ├── API_reference.md             # CLI & internal API details (optional)
│   ├── security_notes.md            # Data handling, encryption key roles, etc.
│   │
│   └── scripts/			# Automation Scripts
│       ├── sync_to_accounting.py        # Pushes trade data to accounting system ledger ingestion module
│       ├── audit_log_parser.py          # CLI utility to review logs and summarize behavior
│       └── upload_backups_to_cloud.sh   # Syncs backups/ to external vault or S3
│
├── tbot_bot/                             # Core engine for execution, strategy logic, reporting, and control
│   ├── __init__.py
│   │   
│   ├── accounting/                          # Accounting Integration (OFX/COA/schema enforcement)
│   │   ├── account_transaction.py               # Generic transaction entry builder for accounting system ingestion
│   │   ├── accounting_api.py                    # Routes trade output to accounting system ingestion pipeline
│   │   ├── accounting_config.py                 # Controls ledger integration settings and COA/schema validation
│   │   ├── ledger_schema.py                     # Defines account hierarchy/types for ledger compliance (OFX-aligned)
│   │   ├── tbot_ledger_schema.sql               # Reference SQL schema for bot ledger initialization (OFX/double-entry/coa_metadata)
│   │   ├── tbot_ledger_coa.json                 # JSON structure: COA codes/names, event mapping, log reference (used by Web UI for COA editing/view)
│   │   ├── README_COA.md                        # Human-readable doc: COA, schema enforcement, update process, and UI-editing instructions
│   │   └── coa_utils.py                         # Utility functions for COA export, import, schema check, and integration with Web UI
│   │
│   │ 
│   ├── backtest/			# Backtesting & Research
│   │   ├── backtest_engine.py           # Core simulator to replay past trades
│   │   ├── load_historical_data.py      # Load from CSV, OHLCV, or tick sources
│   │   ├── performance_metrics.py       # Computes performance metrics (Sharpe, win %, drawdown)
│   │   └── plot_results.py              # Graphs equity curves, trades, and heatmaps
│   │
│   ├── broker/
│   │   ├── broker_api.py           # Unified interface: routes calls to selected broker adapter based on .env_bot
│   │   └── brokers/                # Broker-specific adapters, all conforming to the same interface contract
│   │       ├── __init__.py         # Enables package import and optional dynamic broker loading
│   │       ├── alpaca.py           # Alpaca implementation: REST/WebSocket order placement, account queries
│   │       ├── ibkr.py             # IBKR implementation: TWS/Gateway client with async fallback and reconnect
│   │       ├── tradier.py          # Tradier implementation: REST-only order flow with manual position sync
│   │       └── robinhood.py        # Robinhood implementation: unofficial API support (not for production)
│   │
│   ├── config/				# Configuration & Security
│   │   ├── env_bot.py                    # Validates and parses .env_bot
│   │   ├── error_handler.py             # Centralized exception manager and logging
│   │   ├── network_config.py		# Loads and decrypts network configuration from encrypted JSON secrets Provides getters for HOST_IP, PORT, and HOSTNAME for runtime usage
│   │   ├── security_bot.py              # Encrypts/decrypts .env_bot to .env_bot.enc
│   │   └── settings_bot.py              # Programmatic editor for .env_bot values
│   │
│   ├── control/			# Control Signals (Web/CLI)
│   │   ├── control_start.txt            # Start flag file to trigger bot launch
│   │   └── control_stop.txt             # Stop flag file to trigger safe shutdown
│   │
│   ├── core/
│   │   ├── databases/
│   │   │   ├── LEDGER_STATUS.db                     # Tracks system-wide ledger states (e.g., locked, open, versioned, migration status)
│   │   │   ├── PASSWORD_RESET_TOKENS.db             # Stores one-time password reset tokens and expiry timestamps
│   │   │   ├── SYSTEM.db                            # Core system constants and bot-wide settings (independent of accounting system)
│   │   │   ├── SYSTEM_LOGS.db                       # Centralized system event and audit logs
│   │   │   ├── SYSTEM_USERS.db                      # Sole source of truth for all login/authentication; replaces static user_identity
│   │   │   └── USER_ACTIVITY_MONITORING.db          # Maintains master list of user activity (IP, session, browser, RBAC role)
│   │   │
│   │   ├── schemas/
│   │   │   ├── ledger_status_schema.sql             # SQL schema for ledger status tracking table (supports versioning, migration flag)
│   │   │   ├── password_reset_schema.sql            # SQL schema for password reset token storage
│   │   │   ├── system_logs_schema.sql               # SQL schema for system logs table
│   │   │   ├── system_schema.sql                    # SQL schema for core system configuration
│   │   │   ├── system_users_schema.sql              # SQL schema for system users table (bcrypt hashes, roles)
│   │   │   └── user_activity_monitoring_schema.sql  # SQL schema for user activity monitoring (audit trail, access logs, RBAC changes)
│   │   │
│   │   └── scripts/
│   │       ├── init_ledger_status.py                # Bootstrap/re-bootstrap ledgers using tbot_ledger_schema.sql and tbot_ledger_coa.json; inserts metadata and COA version on init
│   │       ├── init_password_reset_tokens.py        # Initializes password reset token database
│   │       ├── init_system_logs.py                  # Initializes system logs database
│   │       ├── init_system_users.py                 # Initializes system users database with RBAC roles and bcrypt hashing
│   │       ├── init_system.py                       # Initializes core system configuration database
│   │       ├── init_user_activity_monitoring.py     # Initializes user activity monitoring database (tracks login, logout, privilege escalation)
│   │       └── verify_all_core_databases.py         # Connects to each core database, lists tables, prints summary; confirms initialization, prints COA version if present
│   │
│   ├── data/
│   │   └── cache/
│   │       └── fundamentals_{date}.json                # Stored ephemeral runtime artifacts and daily snapshots, such as: API response caches, Screener prefilter output, Temporary metadata from tuning_tracker.py
│   │ 
│   ├── enhancements/				        # Enhancements (Optional Guards & Filters)
│   │   ├── adx_filter.py                	        # Blocks trades during trending ADX
│   │   ├── black_scholes_filter.py     	        # Validates put/call option pricing using Black-Scholes-Merton model (multi-jurisdiction ready via {JURISDICTION_CODE})
│   │   ├── bollinger_confluence.py                  	# Confirms entries with Bollinger alignment
│   │   ├── build_check.py               	        # Validates pre-launch config, file integrity, COA/schema presence and alignment
│   │   ├── finnhub_fundamental_guard.py	        # Blocks trades if company fundamentals fail configured thresholds (e.g., P/E, debt/equity)
│   │   ├── imbalance_scanner_ibkr.py    	        # IBKR imbalance feed for close strategy gating
│   │   ├── ticker_blocklist.py                      	# Blocks duplicate ticker usage in one session
│   │   ├── tuning_tracker.py		                # Tracks and evaluates past strategy performance for tuning guidance
│   │   └── vix_gatekeeper.py                        	# VIX-based gating logic
│   │
│   ├── output/				                          					# Output Artifacts
│   │   └── {ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}/       				# ← Scoped per bot ID - Entire directory mirrored to Accounting system
│   │       ├── logs/                                							# Unified strategy logs (one per phase or failure mode)
│   │       │   ├── open.log			                					# Log of all trades and decisions during open strategy window
│   │       │   ├── mid.log			                					# Log of trades during midday session (position management, adjustments)
│   │       │   ├── close.log			            						# Log of closeout phase decisions and trade executions
│   │       │   ├── unresolved_orders.log	        						# Captures failed, rejected, or stale orders not resolved during session
│   │       │   └── error_tracebacks.log		        					# Full Python tracebacks for all uncaught exceptions (with timestamps)
│   │       │
│   │       ├── ledgers/  
│   │       │   ├── {ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_COA_v1.0.0.db    	# Chart of Accounts (COA) for bot ledger, schema version v1.0.0
│   │       │   ├── {ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_ledger.db        	# OFX-compliant ledger for live trading data per broker
│   │       │   └── {ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_FLOAT_ledger.db  	# Dedicated float ledger: tracks injections, limits, drain points per bot
│   │       │
│   │       ├── summaries/
│   │       │   └── {ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_daily_summary.json  	# JSON performance summary for session (PnL, latency, counts, risk triggers)
│   │       │
│   │       └── trades/
│   │           ├── {ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_trade_history.csv   	# All trade data for session (raw, human-readable)
│   │           └── {ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_trade_history.json  	# Structured trade records for ingestion, reconciliation, and audit
│   │
│   ├── reporting/				                # Reporting & Logging
│   │   ├── auto_backup.py               	    # Compresses and archives /output after session
│   │   ├── daily_summary.py            	    # Builds trade summary stats and outcomes
│   │   ├── log_rotation.py             	    # Cleans output folder after N days
│   │   ├── notify_rebalance_requirements.py	    # Monitors current float for this bot, then notifies accounting system to initiate manual or automated rebalance.
│   │   ├── report_router.py            	    # Routes finalized trade output to loggers and accounting
│   │   ├── session_report.py           	    # Session wrap-up summary writer
│   │   ├── status_logger.py            	    # Syncs bot state to UI (optional)
│   │   └── trade_logger.py             	    # Records trade data to output/trades
│   │
│   ├── runtime/			                # Session Lifecycle
│   │   ├── __init__.py
│   │   ├── main.py                      		# Master controller (boot → trade → shutdown)
│   │   ├── start_bot.py                 		# CLI entry point
│   │   ├── status_bot.py                		# Tracks session state and health
│   │   ├── stop_bot.py                  		# Graceful session shutdown
│   │   ├── tbot_runner_supervisor.py    		# Oversees full lifecycle and watchdogs
│   │   └── watchdog_bot.py              		# Broker connection monitor
│   │
│   ├── screeners/			            	# Screener & Symbol Selection
│   │   └── finnhub_screener.py          		# Symbol scanner via Finnhub API, filters symbols using fundamentals and real-time metrics
│   │
│   ├── storage/
│   │   ├── backups/                                 # Daily ledger backups (UTC timestamped snapshots)
│   │   │   └── {date}/
│   │   ├── exports/                                 # Daily export snapshots
│   │   │   └── {date}/
│   │   ├── keys/                                   # Encryption keys (excluded from deployments for security)
│   │   │   ├── .keep                               # Placeholder to retain keys folder in version control
│   │   │   ├── acct_api.key                        # Used to call secure endpoints in accounting system
│   │   │   ├── broker.key                          # Fernet key for encrypting/decrypting broker credentials (Alpaca, IBKR, etc.)
│   │   │   ├── env.key                             # Decrypts general bot config
│   │   │   ├── env_bot.key                         # Decrypts .env_bot config
│   │   │   ├── login.key                           # bcrypt/Fernet keys for passwords, reset tokens, and non-password use cases
│   │   │   ├── screener_api.key                    # Fernet key for decrypting Finnhub or other screener API keys
│   │   │   └── smtp.key                            # Fernet key for decrypting SMTP login and host data
│   │   │
│   │   ├── secrets/					             # Encrypted configuration files for credentials and tokens
│   │   │   ├── acct_api_credentials.json.enc        # Contains token or credentials to call accounting system endpoints
│   │   │   ├── alert_channels.json.enc             # Encrypted alert channel configuration (email, Slack, etc.)
│   │   │   ├── bot_identity.json.enc			     # Contains values for {ENTITY_CODE}, {JURISDICTION_CODE}, {BROKER_CODE}, {BOT_ID}
│   │   │   ├── broker_credentials.json.enc         # Contains ALPACA + IBKR credentials (API keys, usernames, passwords, URLs)
│   │   │   ├── network_config.json.enc   		     # Contains HOSTNAME, HOST_IP, PORT
│   │   │   ├── smtp_credentials.json.enc           # Contains SMTP_USER, PASS, HOST, PORT
│   │   │   └── screener_api.json.enc               # Contains FINNHUB_API_KEY or other screener access tokens
│   │   │
│   │   └── migration_archives/                     # Historical migration and backup artifacts

│   │
│   ├── strategy/			               # Strategy Logic
│   │   ├── strategy_close.py            # End-of-day logic (momentum/fade)
│   │   ├── strategy_meta.py             # Strategy thresholds and global constants
│   │   ├── strategy_mid.py              # VWAP-based mid-session logic
│   │   ├── strategy_open.py             # Opening range breakout logic
│   │   └── strategy_router.py           # Directs execution based on STRATEGY_SEQUENCE and .env_bot config
│   │
│   ├── support/			               # Support
│   │   ├── .env_bot.enc                          # Encrypted runtime config
│   │   ├── build_check.py                        # Self-check for schema/COA alignment at build/runtime startup; blocks on mismatch
│   │   ├── decrypt_secrets.py                    # Loads and decrypts .json.enc files using corresponding Fernet keys
│   │   ├── path_resolver.py                      # Resolves dynamic paths for tbot modules based on identity and file category
│   │   ├── service_bot.py                        # Optional daemon listener (e.g. systemd)
│   │   ├── utils_config.py                       # Loads and validates bot and environment configuration
│   │   ├── utils_etf.py                          # Resolves ETF and inverse ETF tickers for supported symbols
│   │   ├── utils_identity.py                     # Handles bot identity string and related metadata
│   │   ├── utils_log.py                          # Provides event logging and structured output utilities
│   │   ├── utils_time.py                         # Time utilities for UTC, timestamps, and scheduling
│   │   └── utils_coa.py                          # Loads, validates, and manages the bot’s Chart of Accounts (COA); interfaces with tbot_ledger_coa.json and provides COA to other modules

│   │
│   ├── test/				                # Test Suite
│   │   ├── integration_test_runner.py             # Simulates a full bot session from init to shutdown 
│   │   ├── test_backtest_engine.py                # Validates backtest results against known metrics and equity curves
│   │   ├── test_env_bot.py                        # Verifies .env_bot structure, required fields, and parsing logic
│   │   ├── test_ledger_schema.py                  # Tests that new ledgers match COA/schema and double-entry enforcement
│   │   ├── test_logging_format.py                 # Ensures all log entries follow required format and completeness
│   │   ├── test_main_bot.py                       # Tests session lifecycle logic and file triggers (start/stop)
│   │   ├── test_strategy_selfcheck.py             # Asserts all strategy modules pass .self_check() requirements (CI pre-deployment)
│   │   ├── test_screener_random.py                # Runs screener logic with randomized symbols to confirm filtering and eligibility logic
│   │   ├── test_broker_trade_stub.py              # Sends randomized micro-trades to broker to validate order flow, response, and logging
│   │   ├── test_strategy_tuner.py                 # Executes strategy modules in isolation with test tickers to validate signal logic, threshold configs, and entry/exit paths
│   │   └── test_coa_consistency.py                # Confirms the bot’s COA matches tbot_ledger_coa.json and schema; validates correct integration with utils_coa.py

│   │
│   └── trading/			                # Trade Execution
│       ├── kill_switch.py                   # Triggers shutdown on DAILY_LOSS_LIMIT or catastrophic loss violation
│       ├── logs_bot.py                      # Runtime logging of trade operations to output/logs
│       ├── notifier_bot.py                  # Sends alerts to configured channels (email/Slack/SMS/PagerDuty)
│       ├── orders_bot.py                    # Handles order submission, modifies/fills, and broker feedback
│       ├── reporting_bot.py                 # Pushes trades to accounting system; manages ledger output and COA compliance
│       ├── risk_bot.py                      # Enforces all risk constraints (caps, allocations, Defense Mode, open trades)
│       └── utils_coa.py                     # Loads, validates, and updates the bot COA; integrates with tbot_ledger_coa.json and supports Web UI editing

│   
└── tbot_web/                                   # Web dashboard for monitoring, logs, control, and COA management
    ├── static/                                 # Static frontend resources
    │   ├── fnt/                                # Embedded fonts used in the interface
    │   └── css/
    │       ├── main.css                        # Core layout and UI styling rules
    │       └── theme.css                       # Optional theme layer (e.g. light/dark modes)
    │
    ├── favicon.ico / favicon.gif               # Site icon for browser tab
    │
    ├── py/                                     # Flask backend for web UI and bot interaction
    │   ├── __init__.py                         # Registers Flask blueprints for all routes
    │   ├── auth_web.py                         # AES decryption for login password validation
    │   ├── configuration_web.py                # Manages user, email, API, and broker credential configuration via web UI
    │   ├── coa_web.py                          # NEW: Dedicated page and API endpoints for human-readable COA viewing/editing via Web UI
    │   ├── login_web.py                        # Login/logout route handling with rate limit enforcement
    │   ├── logs_web.py                         # Displays latest bot log output to the web UI
    │   ├── main_web.py                         # Web router and load shell for dashboard interface
    │   ├── portal_web.py                       # Flask app factory for app + static + template setup
    │   ├── run_web.py                          # Webserver launcher for access
    │   ├── settings_web.py                     # Manages all trading strategy and runtime config variables (open/mid/close timings, analysis, monitoring, etc.) via web UI; excludes credentials
    │   ├── start_stop_web.py                   # Writes control_start.txt / control_stop.txt to signal bot lifecycle
    │   └── status_web.py                       # Serves real-time bot/session status, strategy state, live PnL, win-rate, float status, risk/defense mode, and system health (data from status.json and supporting modules) to frontend.
    │
    ├── robots.txt                              # Blocks bots and search engine indexing (security)
    │
    └── templates/                              # HTML UI templates rendered with Jinja2
        ├── configuration.html                  # Web form for updating user, email, API, and broker credential configuration via web UI
        ├── coa.html                            # NEW: Human-readable web form/table for COA viewing and editing (editable if RBAC allows)
        ├── index.html                          # Login screen rendered via Jinja2
        ├── main.html                           # Dashboard shell with embedded strategy/log/status panels
        ├── logs.html                           # Real-time log display (read-only)
        ├── settings.html                       # Web form for updating bot trading strategy and runtime config variables
        └── status.html                        # Displays live bot health, active strategies, session state, PnL, win-rate, float deviation, risk/defense mode, and key runtime metrics (data from status.json).


================================================================================
Deployment Notes (Updated)
================================================================================

- All paths must be relative and cross-platform compatible (macOS, Linux, cloud).
- `tbot_bot/` must run independently of `tbot_web/`; core trading must continue if web UI is disabled.
- Logs, ledger exports, and backup behavior remain active regardless of web interface state.
- Only one broker should be enabled (`BROKER_NAME=ALPACA`, `ALPACA_ENABLED=true`, etc.).
- Broker API keys from `.env` must validate at startup—failure causes immediate shutdown.
- Strategy toggles: `STRAT_OPEN_ENABLED`, `STRAT_MID_ENABLED`, `STRAT_CLOSE_ENABLED`.
- Pre-trade validation includes:
  - Market spread ≤ 1.5% of entry price
  - Volume ≥ `MIN_VOLUME_THRESHOLD`
  - No violations of `MAX_RISK_PER_TRADE` or `DAILY_LOSS_LIMIT`
- Auto-shutdown triggers:
  - Broker API failure (`watchdog_bot.py`)
  - Critical runtime error (`error_handler.py`)
  - Loss breach (`kill_switch.py`)
- Ledger write format: `entities/{ENTITY}_{JURIS}_{account}_{BROKER}_{BOT_ID}_BOT_ledger.db`
- Each ledger write is preceded by a timestamped backup (`backup_ledgers.py`): `entities/{ENTITY}_{JURIS}/backups/`
- OFX exports are generated only by `/export/generate_ofx.py`
- Log files: `/output/logs/open.log`, `/mid.log`, `/close.log`, `/unresolved_orders.log`
- Post-session logs may be zipped/archived (`auto_backup.py`)
- Optional cloud sync: `scripts/upload_backups_to_cloud.sh`
- Backups must not block live ledger writes; all archives are timestamped
- Session timing: `.env_bot` defines `START_TIME_*`, `[STRAT]_ANALYSIS_TIME`, `[STRAT]_MONITORING_TIME`
- Respect `TRADING_DAYS`—block execution on weekends/holidays

--------------------------------------------------------------------------------
COA/Schema Enforcement (New)
--------------------------------------------------------------------------------

- All bot ledger files **must** match the schema defined in `tbot_bot/accounting/tbot_ledger_schema.sql` and the COA defined in `tbot_bot/accounting/tbot_ledger_coa.json`.
- The COA must be present in each bot ledger as a dedicated table (`coa_metadata`) containing: `currency_code`, `entity_code`, `jurisdiction_code`, `coa_version`, `created_at_utc`, `last_updated_utc`.
- Any schema or COA mismatch at runtime (detected by `build_check.py` or ledger init scripts) must block execution and log a fatal error.
- The bot’s COA is self-contained and managed exclusively via the tbot_web UI (`coa_web.py`, `coa.html`). All edits and exports are performed here; no external push/pull from accounting.
- Human-readable COA exports are generated by the web UI and stored in `/output/ledgers/` for reference/audit.
- On new ledger creation, the COA table is initialized from the internal COA (default or UI-edited version) and locked for double-entry enforcement.
- All account transactions are validated against the COA at time of entry.



=============================================================================================================================================
Secure Environment Variables (UPDATED – Ephemeral Encrypted Deployment)
=============================================================================================================================================

Overview:  
TradeBot separates its runtime configuration into two environment files.  
- `.env` contains only global config, API keys, encryption keys, and credential file paths—**never raw credentials**.
- `.env_bot` defines all trading logic, strategy settings, and risk controls—**never stored in version control**.

Security Goals:  
- Never expose `.env_bot` or decrypted config on shared systems or in production images.
- Only validated and decrypted variables are ever loaded at runtime.
- Enable fully encrypted deployment on remote servers (DigitalOcean, SFTP, container, etc.) with NO raw configuration files at rest.

Encryption System:  
- **`.env_bot` is encrypted using AES-256 (Fernet) via the `cryptography` module.**
- The encrypted file is named `.env_bot.enc`.
- The decryption key is stored separately as `ENV_KEY_PATH=storage/keys/env.key` and referenced by `.env`.
- `.env` itself may also be encrypted as `.env.enc` for ephemeral or cloud deployments, with its key stored securely in `storage/keys/env_enc.key`.

**Required Files:**  
- `encrypt_env_bot.py`: Handles encryption and decryption of `.env_bot`; writes/reads the encryption key from `env.key`.
- `encrypt_password.py`: CLI tool to encrypt web UI login credentials; manages keys in `.env`.
- `decrypt_secrets.py`: Loads and decrypts any `.json.enc` or `.env.enc` files using their corresponding keys.
- `.scpignore_*` and `.gitignore`: Ensure all decrypted secrets are excluded from commits and builds.

**Ephemeral .env.enc Support:**  
- For secure or containerized deployments, `.env` may be distributed as `.env.enc` (AES-256 encrypted).
- At process/container startup, `.env.enc` is decrypted into memory or to a secure temp file, **never left unprotected on disk**.
- The ephemeral `.env` is immediately overwritten or deleted after loading.  
- **Best Practice:** Overwrite any decrypted `.env` or `.env_bot` at the end of every session; do not persist outside memory.

Encryption/Decryption Workflow:  
1. **Create `.env_bot`**: Populate with all required trading logic, thresholds, and runtime config.
2. **Encrypt `.env_bot`**:  
   `python3 encrypt_env_bot.py`  
   → Generates `.env_bot.enc` using the key in `storage/keys/env.key`.
3. **(Optional) Encrypt `.env`**:  
   `python3 encrypt_env.py`  
   → Generates `.env.enc` using the key in `storage/keys/env_enc.key`.
4. **Deployment**:  
   - Upload `.env_bot.enc`, `.env.enc` (if used), and the required keys to `storage/keys/` (never to version control).
5. **Runtime Decryption**:  
   - `env_bot.py` and related modules will:  
     - Decrypt `.env_bot.enc` using `env.key`.  
     - If `.env.enc` is present, decrypt with `env_enc.key` (via `decrypt_secrets.py`).  
     - Validate all required keys; raise fatal errors for any missing/malformed fields.
   - All decrypted files are removed or overwritten post-load.

**Validation and Error Handling:**  
- Any decryption failure or missing variable triggers a fatal, human-readable startup error (no silent fallback).
- All decryption/validation errors are logged to `unresolved_orders_*.log` for audit/recovery.
- Access to all decryption keys must be restricted in production.

**Recovery:**  
- If `.env_bot.enc` or `.env.enc` is lost or corrupted:
  1. Restore the latest backup from `/backups/`.
  2. Re-encrypt using the latest valid plaintext config and correct key.
  3. Replace keys if a compromise is suspected.

**Best Practices:**  
- Test decryption/validation in a staging environment before production use.
- Rotate all keys regularly, especially after personnel changes or suspected exposure.
- Never persist decrypted secrets beyond process lifetime—implement secure memory/file handling.
- All encrypted files and keys are excluded from version control via `.scpignore`/`.gitignore`.
- Use only ephemeral decrypted configs (RAM or temp), especially in multi-tenant/cloud environments.

**Compliance/Verification:**  
- All deployment artifacts (backups, logs, configs) are checked by `build_check.py` prior to session start.
- All decrypted config reads and key usage are logged for auditability.

---
**Summary Table:**  
| File              | Type           | Storage                    | Deployment State         | Encryption Key Location             |
|-------------------|----------------|----------------------------|-------------------------|-------------------------------------|
| `.env`            | Global config  | project root               | Optional (plaintext)    | -                                   |
| `.env.enc`        | Global config  | project root               | Recommended (encrypted) | `storage/keys/env_enc.key`          |
| `.env_bot`        | Bot config     | project root (temp only)   | Forbidden (prod)        | -                                   |
| `.env_bot.enc`    | Bot config     | project root               | Required (encrypted)    | `storage/keys/env.key`              |

---

**NOTE:**  
- No decrypted `.env` or `.env_bot` should persist after the bot or web session ends—enforce deletion/overwrite at process exit.
- Decryption routines must not print or log plaintext secrets in error traces.






================================================================================
Current Platforms (Single Broker + Accounting System)
================================================================================

Development:
- Local dev on macOS 15.2, Python 3.11+
- macOS/Linux compatible only (no platform-specific code)
- Use VS Code, Black/Ruff for linting/formatting
- Scripts run via terminal or cron, not GUI
- Test logs/export saved to `logs/bot/sessions/`, `backups/`

Production:
- Runs on Ubuntu 22.04 LTS (DigitalOcean)
- Deployed via SCP/SFTP or `git pull` to prod branch
- Run modes:
  - `start_bot.py` (manual/cron)
  - `service_bot.py` (systemd optional)
- Logs:
  - `output/logs/*.log` – strategy + unresolved
  - `output/summaries/` – session summaries
  - `output/trades/` – CSV/JSON

Brokers:
- One active broker per bot
- Injected via accounting system `.env_bot`
- Modular integrations:
  - Alpaca (default equities)
  - IBKR (ETFs, puts)
  - Tradier/Webull (test only)
- Each must pass `.self_check()`

Market Data:
- Finnhub API via `screeners/finnhub_screener.py`
- Pre/intraday/afterhours scan modes
- Filters: volume, float, price, gap via `.env_bot`

Accounting:
- All trades routed through `accounting_api.py`
- Ledger format: `{ENTITY}_{JURIS}_{BROKER}_{BOT_ID}_BOT_ledger.db`
- Structure in `ledger_schema.py`, OFX-compliant
- **COA required:** Each ledger is initialized and validated against `tbot_ledger_schema.sql` and `tbot_ledger_coa.json`, with a `coa_metadata` table and account hierarchy included at creation.
- OFX exports only via `generate_ofx.py`
- TradeBot does not emit CSV for ledgers; all CSV/JSON outputs are for human audit only

Web Interface:
- `tbot_web/` Flask dashboard
- Features:
  - AES login (key in `.env`)
  - Config UI
  - Logs/status via `status.json`
  - Start/Stop: `control_start.txt`, `control_stop.txt`
  - **COA management:** COA can be viewed and edited exclusively through a dedicated tbot_web UI page. Human-readable COA export available for reference.

Alerts:
- Optional SMTP email via `.env`:
  - `NOTIFY_ON_FILL=true`, `NOTIFY_ON_EXIT=true`
- SMTP creds from DreamHost/etc. in `.env`

Security:
- `.env_bot` encrypted → `.env_bot.enc` via `tools/encrypt_env_bot.py`
- AES key in `.env` as `ENV_BOT_KEY`
- All encrypted files ignored via `.scpignore_*`
- All core configuration and COA management is handled exclusively through the Web UI; no CLI-based COA/credential initialization.

Backup:
- Logs + ledgers archived via `auto_backup.py`
- Stored under `backups/`, upload via `upload_backups_to_cloud.sh`
- Secondary replication recommended (FTP/S3/ProtonVault)

Deployment Verification:
- Dry-run test required pre-live
- Must confirm:
  - Broker API up
  - Trade logs written
  - Ledger writes (COA present and schema validated)
  - Strategy triggers
  - Alerts (if configured)

Recovery:
- Backups must be timestamped + encrypted
- Mirror logs/ledgers to vault at EOD
- Regular integrity checks on `backups/` for audit/failure recovery


================================================================================
Time Zone Standards
================================================================================

- All time variables, logs, strategy triggers, ledger entries, and alerts use **UTC (Coordinated Universal Time)**—this is enforced system-wide.
- Strategy start times in `.env_bot` (e.g., `START_TIME_OPEN`, `START_TIME_MID`, `START_TIME_CLOSE`) must be specified in UTC.
- Ledger writes (e.g., `entities/{ENTITY}_{JURIS}_{BROKER}_{BOT_ID}_BOT_ledger.db`) **must set `DTPOSTED` and all OFX timestamps in UTC**.
- All COA/ledger metadata tables (`coa_metadata`) include `created_at_utc` and `last_updated_utc` fields, set in UTC at creation/update.
- Internal comparisons in `strategy_router.py`, `status_bot.py`, and time utilities must always convert or standardize to UTC before decision logic or log writes.
- **Rationale:** UTC eliminates ambiguity from DST, local zones, or server environments; ensures OFX compliance, reliable cross-entity reconciliation, and robust scheduling for distributed deployments.
- **Example mapping:**
  - 14:30 UTC → 9:30 AM EST (Market Open)
  - 15:30 UTC → 10:30 AM EST (Midday)
  - 19:30 UTC → 2:30 PM EST (Close)
- **Local debugging:** Always convert between UTC and {JURIS} zone before interpreting logs or DB entries.
- **Best practice:** Implement and use in `utils_time.py` (not `utils_bot.py`):

```python
from datetime import datetime, timezone

def utc_now():
    return datetime.utcnow().replace(tzinfo=timezone.utc)



================================================================================
RIGD Trading Bot – Infrastructure and Deployment Overhaul Instructions 
================================================================================

- **Objective:** Deploy on DigitalOcean (Premium AMD, Ubuntu 22.04, systemd, secure).
- **PHASE 1:** Provisioned: nyc3, 2 vCPU, 4GB RAM, 80GB NVMe, Ubuntu 22.04, user `tbot`, SSH key, DNS/firewall active, no provider backups.
- **PHASE 2:** Hardened:
  - User: `tbot`
  - Root/SSH password disabled
  - fail2ban active
  - UFW (Uncomplicated Firewall) configured
  - Auto-updates enabled
  - System timezone set to UTC
  - Python 3.10+ (3.11+ preferred)
  - pip, venv, sqlite3, rsync, curl, git installed
  - All working directories and virtual environments set up
- **PHASE 3:** Systemd Integration:
  - `/etc/systemd/system/` contains:
    - `tbot.target` (parent target for coordinated lifecycle)
    - `tbot-open.service` (9:30–9:50 UTC)
    - `tbot-mid.service` (12:00–12:30 UTC)
    - `tbot-close.service` (15:45–16:00 UTC)
    - `tbot-monitor.service` (trailing stop, runtime health check)
    - `tbot-backup.service` + `.timer` (for scheduled backup/rotation)
    - `tbot-sync.service` + optional `.timer` (for accounting sync)
  - All systemd services run as `tbot` user
  - `Restart=on-failure` enforced
  - `WorkingDirectory` set to project root (e.g., `~/rigd_tbot`)
  - `ExecStart` points to appropriate session or utility script
  - Logs routed to journald and optionally to `/logs/` as per bot policy
  - `/etc/tbot.env` (optional) for non-secrets environment overrides
  - All timers use `OnCalendar=`, `Persistent=true` for guaranteed trigger
- **PHASE 4:** Logging/Backups:
  - Script: `~/rigdtb/scripts/backup_bot_to_iceland.sh` bundles all logs, SQLite ledgers, configs; compresses and rsyncs bundle to Iceland; prunes all archives older than 7 days.
  - (Optional) Mirror to `/mnt/shared` or secondary DR storage; verify archive consistency via `journalctl` and `systemctl status`
- **PHASE 5:** Validation:
  - Use `systemctl list-timers` to confirm all timers are active and correct
  - Use `systemctl status tbot.target` and each sub-service to confirm operational status
  - Simulate trade and trailing stop scenario; verify session logs and trailing stop triggers
  - Confirm backup script triggers post-close and all archives are present
  - Simulate monitor-triggered kill and auto-restart; validate end-to-end continuity
- **Critical:**
  - **All bot operations must be controlled exclusively via systemd**—no manual launches, no cron jobs, no root SSH.
  - Flag and log any operational divergence from the above (service, user, directory, timer, logs, or environment misalignments).
  - All log/backup/restore routines must be non-blocking and fail-safe.
  - All system clocks, logs, and ledgers must be strictly UTC-aligned.


=============================================================================================================================================
RIGD GROUP LLC — Unified Capital Risk Controls and Dynamic Broker Float Allocation 
=============================================================================================================================================

**Overview:**  
RIGD Group LLC (RGL) enforces dynamic float allocation and strict per-session risk controls for each trading window (OPEN, MID, CLOSE). All thresholds and limits are sourced exclusively from `.env_bot` — *no hardcoded limits are allowed*. All logic must validate the disabled (suppressed) state where applicable.

**Risk per Strategy Session (TOTAL_ALLOCATION):**  
- Each session’s maximum risk: `broker_current_float * TOTAL_ALLOCATION`
- Per-trade allocation is split according to `WEIGHTS` (must match max `MAX_TRADES` slots)

**Example Allocations:**  
- 1 signal → 100%  
- 2 signals → 60%, 40%  
- 3 signals → 40%, 30%, 30%  
- 4 signals → 40%, 20%, 20%, 20%  
- *(If Broker Float = $2,500, TOTAL_ALLOCATION = 0.02 → Session cap = $50)*

**MAX_OPEN_POSITIONS / MAX_TRADES:**  
- `MAX_TRADES`: limits per-session entry count  
- `MAX_OPEN_POSITIONS`: enforces system-wide cap (applies across all strategies)

**WEIGHTS:**  
- List/array, length must equal `MAX_TRADES`  
- Sourced from `.env_bot`, validated on startup

**DAILY_LOSS_LIMIT:**  
- Each broker halts trading if `realized_loss > broker_current_float * DAILY_LOSS_LIMIT`
- Loss-based shutdown is broker-specific (enforced in `kill_switch.py`)

**Ledger/Accounting Integration:**  
- The bot may *read* float (via `broker_current_float`), but does not manage or transfer float  
- All float changes (ACH, wires, etc.) must be routed and tracked through the accounting system’s ledgers
- Float movements are:
    - Ingested by the accounting system
    - Logged using OFX-compliant double-entry (debit/credit) journal entries
    - Reconciled and validated after every transfer

**Automated Mercury Pulls:**  
- (If supported) Accounting system performs Mercury/wise pull to verify broker float matches internal ledgers

**Rebalancing:**  
- All rebalancing logic is in the accounting system (not in the bot)
- The bot uses only the float available at session start; no in-session float sync/rebalancing logic
- A rebalance trigger (float deviation >10%) is raised to accounting via notification

**Scaling/Compounding:**  
- All risk caps and trade sizes auto-scale with current float
- Manual overrides or adjustments are **strictly prohibited** unless performed through `.env_bot` and appropriately logged

**Enforcement Modules:**  
- `risk_bot.py`: Enforces `TOTAL_ALLOCATION`, `WEIGHTS`, `MAX_TRADES`, `MAX_OPEN_POSITIONS`, and PnL caps per session
- `kill_switch.py`: Halts all trading activity for a broker upon `DAILY_LOSS_LIMIT` breach
- `watchdog_bot.py`: Suspends trading if broker API or infrastructure becomes unstable

**Test/Live Modes:**  
- *All controls apply identically in both test and live modes*
- **No manual overrides allowed except by updating and reloading `.env_bot` (Web UI only)**

=============================================================================================================================================
TradeBot Strategy Logic Spec v1.1 (Updated for Accounting System Integration)
=============================================================================================================================================

**Overview:**  
TBot executes intraday breakout and mean-reversion strategies using a unified logic pipeline. All trade entries are directional and follow structured risk, time, and allocation parameters as defined in `.env_bot`. All parameters, filters, and toggles must be dynamically sourced—no hardcoded logic.

**Supported Instruments:**  
- Long equity (common stocks or ETFs)
- Inverse ETFs (e.g., SH, SQQQ)
- Long puts (IBKR only)

**Trade Direction Rules:**  
- Long trades: Supported on all brokers
- Bearish trades: Executed only if corresponding `SHORT_TYPE_*` is not `disabled`
- Puts: Used only if broker is IBKR and `SHORT_TYPE_* = LongPut`
- Inverse ETFs: Used for non-options brokers when `SHORT_TYPE_* = InverseETF`

**Supported Brokers:**  
- Alpaca: long equity, inverse ETFs
- IBKR: long equity, inverse ETFs, long puts
- Tradier: long equity, inverse ETFs

**Execution Framework:**  
- Strategy execution is sequenced via `STRATEGY_SEQUENCE` in `.env_bot`
- Each strategy module (`strategy_open.py`, `strategy_mid.py`, `strategy_close.py`) is loaded independently by `strategy_router.py`
- Runtime logic strictly observes UTC windows and `.env_bot` timing/config variables

**Ledger and Accounting Integration:**  
- **All trade activities, allocations, and PnL updates are written directly to:**
    - `output/ledgers/{ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_ledger.db`
- **All ledger entries** must comply with OFX schema:
    - Required fields: `TRNTYPE`, `DTPOSTED` (UTC), `FITID`, broker, strategy, ticker, side, size, entry_price, exit_price, PnL, and audit references.
- `.csv` or `.json` trade histories are external audit artifacts and not parsed for ledger ingestion.
- All reporting and reconciliation flow through the accounting system’s ingestion modules.

---

**Active Strategies:**

---------------------------------------------------------
Strategy: strategy_open.py – Opening Range Breakout
---------------------------------------------------------
- **Time Window:**
  - Start: `START_TIME_OPEN` (14:30 UTC = 9:30 AM EST)
  - Analysis: `OPEN_ANALYSIS_TIME` (minutes)
  - Breakout: `OPEN_BREAKOUT_TIME` (minutes)
  - Monitoring: `OPEN_MONITORING_TIME` (minutes)
- **Trade Direction:** Long by default; short only if `SHORT_TYPE_OPEN` ≠ `disabled`
- **Entry Logic:**
  - Track high/low during analysis window
  - Enter if price > high * (1 + `STRAT_OPEN_BUFFER`) or < low * (1 - `STRAT_OPEN_BUFFER`)
  - Entry must occur within breakout window
- **Exit Logic:** 2% trailing stop or monitoring timeout
- **Shorting:** Controlled by `SHORT_TYPE_OPEN`: InverseETF, LongPut, ShortSell, or disabled
- **Logging:**
  - Logs: `open.log`
  - Ledger: `output/ledgers/{ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_ledger.db`
  - Trade History: `output/trades/{ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_trade_history.csv/json`

---------------------------------------------------------
Strategy: strategy_mid.py – VWAP Mean Reversion
---------------------------------------------------------
- **Time Window:**
  - Start: `START_TIME_MID` (15:30 UTC = 10:30 AM EST)
  - Analysis: `MID_ANALYSIS_TIME` (minutes)
  - Breakout: `MID_BREAKOUT_TIME` (minutes)
  - Monitoring: `MID_MONITORING_TIME` (minutes)
- **Trade Direction:** Long or Bearish
- **Entry Logic:**
  - Enter on price deviation from VWAP ±`STRAT_MID_VWAP_THRESHOLD`
  - Confirm with ADX and Bollinger filters
  - Entry must be within breakout window
- **Exit Logic:** VWAP touch, 1.5% stop loss, or timeout
- **Shorting:** Controlled by `SHORT_TYPE_MID`: InverseETF, LongPut, ShortSell, or disabled
- **Enhancements:** `adx_filter.py`, `bollinger_confluence.py`
- **Logging:**
  - Logs: `mid.log`
  - Ledger: `output/ledgers/{ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_ledger.db`
  - Trade History: `output/trades/{ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_trade_history.csv/json`

---------------------------------------------------------
Strategy: strategy_close.py – End-of-Day Momentum / Fade
---------------------------------------------------------
- **Time Window:**
  - Start: `START_TIME_CLOSE` (19:30 UTC = 2:30 PM EST)
  - Analysis: `CLOSE_ANALYSIS_TIME` (minutes)
  - Breakout: `CLOSE_BREAKOUT_TIME` (minutes)
  - Monitoring: `CLOSE_MONITORING_TIME` (minutes)
- **Trade Direction:** Long or Bearish
- **Entry Logic:**
  - Enter on momentum continuation or spike reversal
  - Requires VIX > `STRAT_CLOSE_VIX_THRESHOLD`
  - Entry must be within breakout window
- **Exit Logic:** 2% stop loss or hard exit at session end
- **Shorting:** Controlled by `SHORT_TYPE_CLOSE`: InverseETF, LongPut, ShortSell, or disabled
- **Enhancements:** `vix_gatekeeper.py`, `imbalance_scanner_ibkr.py`, `ticker_blocklist.py`
- **Logging:**
  - Logs: `close.log`
  - Ledger: `output/ledgers/{ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_ledger.db`
  - Trade History: `output/trades/{ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_trade_history.csv/json`

---

**Strategy Failover Logic**
- Any `.self_check()` failure skips that strategy; all failures logged with UTC timestamp
- If `STRATEGY_OVERRIDE` is set (e.g., `mid`), only the specified strategy executes
- All execution strictly enforces:
  - `DISABLE_ALL_TRADES`
  - `DAILY_LOSS_LIMIT`
  - `MAX_OPEN_POSITIONS`
  - `TOTAL_ALLOCATION` and `WEIGHTS`
  - Broker status, float, and account restrictions
- All risk and execution constraints sourced dynamically from `.env_bot` (never hardcoded or inferred)



=============================================================================================================================================
InverseETF Integration Specification (Final v1.0)
=============================================================================================================================================

Overview:  
TBot supports directional short positions using Inverse ETFs as a fallback mechanism for bearish trades when the broker does not support long puts or short selling. Inverse ETFs are eligible for all strategy modules and must follow strict screening, liquidity, and execution logic enforced by `.env_bot` and strategy-level constraints. **All eligibility, execution, and logging logic is enforced in compliance with the entity’s OFX-aligned ledger schema and audit standards.**

------------------------------------------------------------------------------------------------------------------------
Configuration & Controls
------------------------------------------------------------------------------------------------------------------------

- All bearish logic is gated by:
  - `SHORT_TYPE_OPEN=InverseETF`
  - `SHORT_TYPE_MID=InverseETF`
  - `SHORT_TYPE_CLOSE=InverseETF`

- The universe of inverse ETFs is predefined and must be explicitly whitelisted in `finnhub_screener.py` (and reflected in `tbot_bot/strategy/strategy_meta.py` for all pools):
  INVERSE_ETF_TOP20 = [
      "SQQQ", "SPXU", "UVXY", "SDOW", "SRTY", "SH", "PSQ", "DOG", "TBF", "TBT",
      "TMV", "FAZ", "ERY", "REK", "DRIP", "YANG", "MYY", "RWM", "QID", "DXD"
  ]

- Screening filters applied before execution:
  - `MIN_VOLUME_THRESHOLD` (e.g., 1,000,000) from `.env_bot`
  - `MIN_PRICE`, `MAX_PRICE` from `.env_bot`
  - **Spread check:** abort if spread > 1.5% of current price
  - Strategy-specific logic (VWAP deviation, breakout threshold, etc.)
  - **Eligibility enforcement:** Only allowed symbols and one trade per ETF per session (enforced by `ticker_blocklist.py`)

- Execution Limitations:
  - Inverse ETFs must **not** be used outside strategy windows
  - No after-hours or pre-market trading allowed
  - Only 1 trade per symbol per session (enforced by `ticker_blocklist.py`)
  - Each inverse ETF trade must be logged with full audit metadata (including UTC timestamp, `strategy_name`, `ticker`, `side`, `size`, `entry_price`, `exit_price`, `PnL`, `broker`, and `error_code` if applicable)

------------------------------------------------------------------------------------------------------------------------
Runtime Integration
------------------------------------------------------------------------------------------------------------------------

- **ETF pool per strategy** is dynamically filtered from `INVERSE_ETF_TOP20`, using `.env_bot` filters
- **Strategy modules use:**

    from tbot_bot.strategy.strategy_meta import ETF_POOLS

    if SHORT_TYPE == "InverseETF":
        candidates = scan_etfs(ETF_POOLS["mid"])  # Use the correct strategy context
        for etf in candidates:
            if passes_filters(etf):    # Apply volume, price, spread, etc.
                submit_trade(etf, side="short")

- **ETF pool may be strategy-specific:**

    ETF_POOLS = {
        "open": [
            "SH", "PSQ", "DOG",        # Conservative -1x ETFs
            "SPXU", "SQQQ", "SDOW",    # High liquidity index shorts
            "RWM", "MYY"               # Small- and mid-cap inverse
        ],
        "mid": [
            "SQQQ", "SPXU", "SDOW",    # Tech, S&P, Dow (-3x)
            "SRTY", "QID", "DXD",      # Small/mid/large blends (-2x)
            "RWM", "MYY",              # Non-leveraged variants
            "FAZ"                      # Financials
        ],
        "close": [
            "SPXU", "SQQQ", "UVXY",    # Momentum/volatility plays
            "TMV", "TBT", "TBF",       # Treasury bear curve (-1x/-2x/-3x)
            "ERY", "DRIP",             # Energy and Oil & Gas
            "REK", "YANG"              # Real Estate, China - volatility/geohedge
        ]
    }

- **Logging/Audit Requirements:**
  - All inverse ETF trades must be recorded to the ledger file (`output/ledgers/{ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_ledger.db`)
  - All external trade logs must be mirrored in `output/trades/` with strict 1:1 mapping to ledger entries
  - All fields and values must match those defined in `tbot_ledger_schema.sql` and referenced in the COA file

- **Enforcement:**
  - Any filter or eligibility violation must block trade and log a fatal error with context in `unresolved_orders.log`
  - Only ETFs present in the `ETF_POOLS` structure for the strategy may be used; any addition/removal must be recorded in `VERSION.md` and COA doc for audit

**OFX/Accounting Compliance:**  
- All inverse ETF trades are handled identically to long equity for journal/audit purposes
- All entries must pass double-entry, UTC timestamp, and schema validation before export


------------------------------------------------------------------------------------------------------------------------
Logging & Ledger Compliance
------------------------------------------------------------------------------------------------------------------------

- **All inverse ETF trades must write to:**
  - `output/trades/{ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_trade_history.json`      # Human-readable trade history for audit
  - `output/logs/{strategy}.log`                                                                       # Session-specific log file (e.g., open.log, mid.log, close.log)
  - `output/ledgers/{ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_ledger.db`            # OFX-compliant ledger (production, entity-scoped)

- **Required ledger fields for every inverse ETF trade:**
  - `TRNTYPE=SELL`
  - `ticker`
  - `side=short`
  - `entry_price`
  - `exit_price`
  - `PnL`
  - `broker`
  - `strategy`
  - `FITID` (unique transaction ID)
  - `DTPOSTED` (UTC datetime posted)
  - `TAG=InverseETF`
  - `LEVERAGE_MULTIPLIER` (if known; e.g., -1x, -2x, -3x)

- **All entries must match the schema and metadata required by `tbot_ledger_schema.sql` and the current COA version.**  
  Any mismatches must block ledger write and log an error in `unresolved_orders.log` and `error_tracebacks.log` for audit.

------------------------------------------------------------------------------------------------------------------------
Summary
------------------------------------------------------------------------------------------------------------------------

- Inverse ETFs provide safe, broker-compatible short exposure **without requiring margin or options**.
- TBot enforces strict entry criteria to avoid decayed or illiquid instruments, protecting against execution risk and poor fill quality.
- The ETF list (`INVERSE_ETF_TOP20` and `ETF_POOLS`) is **version-controlled**; additions/removals require internal review, update of COA documentation, and a `VERSION.md` entry.
- Usage is toggled **per-strategy** via `.env_bot` using `SHORT_TYPE_* = InverseETF` and validated at runtime before trade submission.


=============================================================================================================================================
Enhancement Module Activation (Comprehensive — All Modules Listed)
=============================================================================================================================================

**Overview:**  
TradeBot includes modular enhancements in `/tbot_bot/enhancements/` to refine signal quality, block trades under poor conditions, and perform diagnostics. Enhancements are plug-ins activated via strategy context or `.env_bot`.

All enhancements are independently testable and auto-invoked from `strategy_router.py` or individual strategies. Each returns a boolean (`True`=allow, `False`=block). Failures log warnings but default to core logic unless fatal. Outcomes are logged to strategy logs and summaries, not accounting ledgers.

---

**Enhancements Directory – All Modules:**

1. **adx_filter.py**  
   Blocks trades during trending ADX (typically ADX > 25); used in `strategy_mid.py`. Always-on (future toggle: `ADX_FILTER_ENABLED=true`).

2. **black_scholes_filter.py**  
   Validates put/call option pricing using Black-Scholes-Merton model (multi-jurisdiction ready via `{JURISDICTION_CODE}`).  
   - Dynamically adjusts `risk_free_rate` by `JURISDICTION_CODE` from `bot_identity.json.enc`
   - Enabled via `.env_bot` toggle: `ENABLE_BSM_FILTER=true`
   - Rejects if deviation > `MAX_BSM_DEVIATION` (default: 15%)
   - Logs detailed context for each rejection

3. **bollinger_confluence.py**  
   Confirms entries only if price breaches ±2σ Bollinger Band; used in `strategy_mid.py`. Inline trigger; reduces false positives in low-volatility regimes.

4. **build_check.py**  
   Validates pre-launch config and file integrity, COA/schema presence and alignment; called by `main_bot.py` or CLI. Bot halts on failure.

5. **finnhub_fundamental_guard.py**  
   Blocks trades if company fundamentals fail configured thresholds (e.g., P/E, debt/equity).
   - Pulls data via `FINNHUB_API_KEY` (loaded from `screener_api.json.enc`)
   - Cached to `data/cache/fundamentals_{date}.json`
   - Enforced metrics:
     - `peNormalizedAnnual` ≤ `MAX_PE_RATIO` (default: 50)
     - `totalDebt/totalEquityAnnual` ≤ `MAX_DEBT_EQUITY` (default: 2.5)
     - `marketCapitalization` ≥ `MIN_MARKET_CAP_FUNDAMENTAL` (default: 2B)
   - Logs full rejection context to strategy logs

6. **imbalance_scanner_ibkr.py**  
   IBKR imbalance feed for close strategy gating. Reads IBKR imbalance data from 20:30–21:00 UTC; blocks trades during strong opposing pressure. Applies to `strategy_close.py` when `BROKER=ibkr`.

7. **ticker_blocklist.py**  
   Blocks duplicate ticker usage in one session. Prevents repeat trades per ticker per session; always-on; tracks traded tickers in memory/temp.

8. **tuning_tracker.py**  
   Tracks and evaluates past strategy performance for tuning guidance. Records and summarizes statistical performance; enables tuning of thresholds or parameters in live/test modes.

9. **vix_gatekeeper.py**  
   VIX-based gating logic. Blocks trades if VIX < `STRAT_CLOSE_VIX_THRESHOLD` (`.env_bot`); applies to `strategy_close.py`. Used to avoid low-volatility EOD signals.

---

**Best Practices:**
- Keep enhancements decoupled from core logic.
- Use toggles in `.env_bot` only if dynamic enable/disable needed.
- Enhance trade quality; do not generate signals.
- Only executed trades are recorded in ledgers; all blocks/skips are logged to operational logs and summaries only.

---

**Core Safety Systems:**

- **kill_switch.py**: Halts trading on `DAILY_LOSS_LIMIT` breach; logs shutdown + attempts to close trades.
- **watchdog_bot.py**: Monitors API and data feeds; suspends/cancels trading on broker or market failure.
- **risk_bot.py**: Enforces all allocation and risk controls, validates pre-execution.
- **error_handler.py**: Centralized error capture/logging; triggers shutdown on fatal error.
- **security_bot.py**: Validates decryption of `.env_bot.enc`; blocks plaintext config in prod.

---

**Emergency Shutdown Table**

| Event                         | Scope   | Action                      |
|-------------------------------|---------|-----------------------------|
| DAILY_LOSS_LIMIT breach       | Global  | Immediate halt              |
| Broker API failure            | Global  | Trading suspended           |
| Market data failure           | Global  | Full system shutdown        |
| Critical exception            | Global  | Full shutdown               |
| Manual override               | Scoped  | Controlled shutdown/reset   |

- All actions logged and audited

---

**Self-Check System:**
- Every enhancement and safety module must implement `.self_check()` or equivalent on launch.  
- Launch blocked and cause logged on any failure.




=============================================================================================================================================
INTEGRATION MODULE – TBOT + ACCOUNTING SYSTEM ALIGNMENT
=============================================================================================================================================

**Purpose:**  
This section mandates integration alignment between the tbot execution system and the forensic-grade accounting system currently under modular build.

**Scope:**  
These rules apply to:
- All tbot trading actions (test or live mode)
- All float injections, float returns, broker cash movements
- All profit/loss logging, reconciliation, and reporting

----------------------------------------------------------------------
KEY INTEGRATION RULES
----------------------------------------------------------------------

1. **LEDGER ISOLATION PER ENTITY + BOT**
   - All tbot activities must write to the correct ledger for its assigned bot instance:
     - `{ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_ledger.db`
   - No other ledgers (e.g., RGL, RHL, or shared simulation files) may be written by the bot.
   - Float movements between bots or entities must use cross-entity sync and ingestion within the accounting system.

2. **MULTI-CURRENCY READINESS**
   - All ledger entries must carry an explicit currency code (`currency_code`), even if currently single-currency.
   - The accounting schema supports multi-currency by default; tbot must pass accurate currency codes with each ledger entry.

3. **INGESTION PIPELINE COMPLIANCE**
   - All broker fills and executed trades must be routed through the accounting system’s ingestion modules.
   - No direct write to final ledger tables is permitted outside of approved ingestion paths.

4. **DOUBLE-ENTRY ENFORCEMENT**
   - Every tbot-generated ledger entry must obey double-entry constraints (sum of debits = sum of credits).
   - Trade execution, PnL, float movement, and fee posting must balance using system-defined accounts.

5. **AUDIT LOGGING**
   - All ledger-triggering actions by the bot must create a corresponding audit log in the `logs` table.
   - Any manual correction or backfill must be flagged, source-tracked, and reviewed.

6. **OFX EXPORT READINESS**
   - Ledger entries must be OFX-aligned and compatible with `generate_ofx.py`:
     - `TRNTYPE`, `DTPOSTED`, `FITID`, broker code, strategy, symbol, size, PnL

7. **SYSTEM INDEPENDENCE**
   - Tbot must never bypass the accounting system’s validation or export layers.
   - Even in test mode, all simulated trades must flow through ingestion logic and appear in correct ledgers.

----------------------------------------------------------------------
MANDATORY DEPENDENCY MODULES (FROM ACCOUNTING BUILD)
----------------------------------------------------------------------
For tbot-to-ledger integration to function properly, the following accounting modules must be in place:

- Phase 0: Core Framework (`/config.py`, `/utils/db_connection.py`, `/entities/init_db.py`)
- Phase 1: Ingestion Pipeline (`/ingestion/*`, `/processing/normalize.py`, `/logs/logger.py`)
- Phase 4: OFX Export Generator (`/export/generate_ofx.py`)

----------------------------------------------------------------------
RISKS IF IGNORED
----------------------------------------------------------------------
- Ledger corruption and unbalanced entries
- Cross-entity capital contamination
- Regulatory compliance failure (OFX, IRS, SEC)
- Compromised audit integrity
- OFX export failure or tax filing errors
- Inability to distinguish test vs. real trading activity

----------------------------------------------------------------------
OFX/LEDGER FIELDS REQUIRED PER TRADE/ACTION
----------------------------------------------------------------------

Each tbot-originated ledger entry **must include** (at minimum):

- `TRNTYPE` (e.g., BUY, SELL, SHORT, COVER)
- `DTPOSTED` (UTC, ISO-8601)
- `FITID` (unique transaction ID)
- `currency_code` (e.g., USD)
- `entity_code` (e.g., RGL)
- `jurisdiction_code` (e.g., USA)
- `broker_code` (e.g., ALPACA)
- `strategy` (open, mid, close)
- `ticker`/`symbol`
- `side` (long/short)
- `size`
- `entry_price`
- `exit_price`
- `PnL`
- `audit_reference` (link to action in logs table)
- `TAG` (e.g., InverseETF, if applicable)
- `LEVERAGE_MULTIPLIER` (if leveraged ETF)

_All above fields must be present in each row for validation and downstream reporting._

----------------------------------------------------------------------
NOTE:  
Failure to comply with any of the above integration rules or required fields constitutes a critical error and will halt all ledger ingestion and OFX export, pending manual review.
----------------------------------------------------------------------



=============================================================================================================================================
Ledger Chart of Accounts (Final – Single-Broker TBot Architecture)
=============================================================================================================================================

This chart of accounts defines the structure for all TBot-generated SQLite ledgers, which are OFX-compliant and maintained under the accounting system’s `entities/{ENTITY_CODE}_{JURISDICTION_CODE}/ledgers/bot/` directory.

Each bot instance writes only to its assigned ledger file:
`output/ledgers/{ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_ledger.db`

----------------------------------------------------------------------------------------------------------------------------------------------
 Tbot – Execution System CHART OF ACCOUNTS {ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_COA.db 
----------------------------------------------------------------------------------------------------------------------------------------------

# -- COA Metadata (Required for ALL ledgers and COA files) --
COA_METADATA:
    currency_code: "USD"
    entity_code: "{ENTITY_CODE}"
    jurisdiction_code: "{JURISDICTION_CODE}"
    coa_version: "v1.0.0"
    created_at_utc: "<UTC_TIMESTAMP>"
    last_updated_utc: "<UTC_TIMESTAMP>"

# -- Account Structure --

1000 Bank and Cash Accounts [Cash & Cash Equivalents]
├── 1010 Float Injection – From RIGD Group
├── 1020 Float Returned – To RIGD Group
├── 1030 Alpaca – Cash [Cash & Cash Equivalents]
├── 1040 IBKR – Cash [Cash & Cash Equivalents]
├── 1050 Tradier – Cash [Cash & Cash Equivalents]
├── 1060 Robinhood – Cash [Cash & Cash Equivalents]

1100 Assets [Investing Activities]
├── 1110 Brokerage Accounts – Equities
│   ├── 1111 Alpaca – Equities
│   ├── 1112 IBKR – Equities
│   ├── 1113 Tradier – Equities
│   └── 1114 Robinhood – Equities

2000 Liabilities [Operating Activities]
├── 2010 Broker Payables (Accrued Fees)
├── 2020 Market Data Payables (Accrued Subscriptions)

3000 Equity [Financing Activities]
├── 3010 Capital Float Ledger
├── 3020 Daily Float Allocation History
├── 3030 Opening Balance
├── 3040 Accumulated Profit

4000 Income [Operating Activities]
├── 4010 Realized Gains – Alpaca
├── 4020 Realized Gains – IBKR
├── 4030 Realized Gains – Tradier
├── 4040 Realized Gains – Robinhood
├── 4050 Qualified Dividends
├── 4060 Short-Term Capital Gains
├── 4070 Long-Term Capital Gains

5000 Expenses [Operating Activities]
├── 5010 Broker Fees – Alpaca
├── 5020 Broker Fees – IBKR
├── 5030 Broker Fees – Tradier
├── 5040 Broker Fees – Robinhood
├── 5050 Slippage / Execution Losses
├── 5060 API Timeout Penalties
├── 5070 Bot Infrastructure Costs

9100 Exports [Control & Reporting]
├── 9110 Daily P&L Export – Manager.io Format
├── 9120 CSV/JSON Trade Log Export
├── 9130 SQLite Ledger Backup
├── 9140 Broker Confirm Archive (PDFs)
├── 9150 End-of-Day Snapshot (Holdings + Cash)

9200 Logging / Execution References [Control]
├── 9210 Trade UUID
├── 9220 Broker Confirm #
├── 9230 Strategy Tag
├── 9240 Source Method Tag
├── 9250 EOD Synced Flag
├── 9260 Reconciliation Passed Flag

9300 System Integrity [Control]
├── 9310 Failures & Rejected Orders
├── 9320 Manual Overrides
├── 9330 Ledger Lock Flag (YES/NO)
├── 9340 Ledger Status: ACTIVE / DECOMMISSIONED
├── 9350 Final Entry Timestamp
└── 9360 Debug / Strategy Tags

------------------------------------------------------------------------------------------
COA Metadata & Versioning Notes
------------------------------------------------------------------------------------------

- All COA database files must include the following metadata fields at the schema or file level:
    - `currency_code` (e.g., 'USD', 'EUR')
    - `entity_code` (e.g., 'RGL')
    - `jurisdiction_code` (e.g., 'USA')
    - (Optional) `coa_version` (e.g., 'v1.0.0')

- For future schema migrations, append a version to the COA filename:
    `{ENTITY_CODE}_{JURISDICTION_CODE}_COA_v1.0.0.db`
    `{ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_COA_v1.0.0.db`

- These metadata fields should be present in the COA database as a dedicated metadata table:
    - Table name: `coa_metadata`
    - Fields: `currency_code`, `entity_code`, `jurisdiction_code`, `coa_version`, `created_at_utc`, `last_updated_utc`

- All ledger and COA files must be designed for multi-entity and multi-currency extensibility, even if only one is in use.

------------------------------------------------------------------------------------------
Export Constraints and System Enforcement
------------------------------------------------------------------------------------------

- All `.csv` or `.json` logs are **external audit artifacts** and never parsed into the ledger  
- Only validated, reconciled trade data is written to the ledger after each strategy session  
- Each ledger must pass integrity validation before export  
- If ledger fails schema or double-entry validation, export process will abort  
- Export system relies on:
  - `/config.py`  
  - `/utils/db_connection.py`  
  - `/entities/init_db.py`  
  - `/ingestion/` modules  
  - `/processing/normalize.py`  
  - `/logs/logger.py`  
  - `/export/generate_ofx.py`  

**Note:** Inverse ETF and other leveraged short trades are recorded under standard trading accounts. Their instrument type and leverage details are tracked via transaction tags (`TAG`, `LEVERAGE_MULTIPLIER`) in the ledger and do not require separate COA accounts.

All ledger structures must comply with OFX alignment to ensure downstream export, tax prep, and inter-system reconciliation.



=============================================================================================================================================
Logging & Reporting Format 
=============================================================================================================================================

**Overview:**  
Each bot instance writes structured session outputs to support audit trails, dashboards, compliance reports, and downstream ingestion. Log outputs and ledgers are scoped **exclusively to the assigned broker, entity, and bot ID**, with no runtime mode switching.

All filenames and outputs are governed by `.env_bot` and `accounting_config.py`.

---

**Output Scope:**
- Logs, trade history, summaries, and unresolved order events
- All files include the bot ID, strategy name, and timestamp when applicable
- Files are separated by type: strategy logs, trade logs, daily summaries

---

**Primary Output Directories**

| Directory            | Contents                                                      |
|----------------------|--------------------------------------------------------------|
| `output/logs/`       | Strategy execution logs, error traces, broker-level issues   |
| `output/trades/`     | Per-session trade history logs (`csv` or `json`)             |
| `output/summaries/`  | Final summaries of strategy performance and PnL              |
| `backups/`           | Auto-archived versions of logs and ledgers (rotated)         |

---

**Filename Structure**

| Type               | Example Filename Format         | Notes                                  |
|--------------------|-------------------------------|----------------------------------------|
| Strategy Logs      | `open.log`, `mid.log`, `close.log`        | One per strategy, scoped to bot session |
| Trade History      | `trade_history.csv`, `trade_history.json` | Includes all executed trades            |
| Unresolved Orders  | `unresolved_orders.log`        | Captures rejects, partial fills, etc.   |
| Daily Summary      | `daily_summary.json`           | One per session, includes PnL, stats    |

All filenames are stored relative to the executing bot’s `output/` subdirectories.

---

**Log Format Configuration**

Set via `.env_bot`:

- `LOG_FORMAT=csv` → human-readable output  
- `LOG_FORMAT=json` → structured output for parsing, dashboards, ingestion

Only one format is written per session based on this variable.

---

**Required Fields – `trade_history.json`**

Each entry must include:

- `timestamp`          → ISO 8601 UTC timestamp  
- `strategy_name`      → open, mid, or close  
- `ticker`             → equity or ETF symbol  
- `side`               → long or short  
- `size`               → share or contract count  
- `entry_price`        → float  
- `exit_price`         → float  
- `PnL`                → float (realized only)  
- `broker`             → string from `.env_bot`  
- `error_code`         → if applicable (e.g., rejection, partial)

---

**Ledger Routing – Single-Broker Enforcement**

All trades are routed to the correct ledger using:

- Bot-assigned entity code  
- Jurisdiction code  
- Broker code  
- Bot ID  
- Ledger name suffix: `_BOT_ledger.db`

**Ledger path format:**  
`output/ledgers/{ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_ledger.db`

**Example:**  
`output/ledgers/TEST_USA_ALPACA_01_BOT_ledger.db`  

*This pathing is enforced by the accounting system. The bot **never selects its own ledger path**.*

---

**Export + Archive Flow**

1. `reporting_bot.py` collects trade logs post-session  
2. `accounting_api.py` submits all entries to ingestion pipeline  
3. `accounting_config.py` resolves final ledger and export destinations  
4. `generate_ofx.py` emits OFX 1.x/2.x output  
5. `auto_backup.py` archives all logs and ledgers (timestamped)

---

**Key Principles**

- Logs are **parallel audit artifacts** — never re-imported into ledgers  
- No separation of live vs paper trades — bot operates on one ledger only  
- Accounting system handles test/live classification **externally** via assigned ledgers  
- All outputs must be fully deterministic, timestamped, and account-mapped

---

**Use Cases**

- Daily PnL reports  
- Internal audit and compliance verification  
- Real-time dashboard ingestion  
- Historical trade analysis  
- Export to regulatory or tax systems via OFX

---




==========================================================
Modular Strategy Reporting & Audit Output Specification
==========================================================

**Objective:**  
Support robust, per-strategy reporting for live audit, optimization, and real-time validation of TradeBot behavior.

---

**1. Ensure Separate Logs and Summaries per Strategy**

Each strategy **must** write the following outputs in its assigned output directory:

- `open.log`, `mid.log`, `close.log`                # Per-strategy execution logs
- `trade_history.json`, `trade_history.csv`          # Complete trade-by-trade records
- `daily_summary.json`                               # End-of-session performance summary

**Required fields in all logs and trade records:**

- `strategy_name`
- `signal_trigger_time`
- `entry_timestamp`
- `exit_timestamp`
- `trade_side` (long/short)
- `entry_price`
- `exit_price`
- `size`
- `PnL`
- `broker`
- `exit_reason` (e.g., stop_loss, timeout, manual, target_hit)

---

**2. Daily Summary Metrics**

Ensure each session generates a `daily_summary.json` with, at minimum:

- `win_rate_per_strategy`
- `total_trades`
- `average_pnl_per_trade`
- `max_gain`
- `max_loss`
- `trade_count_vs_signals_triggered`
- `average_holding_time`
- `most_profitable_tickers`
- `worst_tickers`

---

**3. UI Reporting via `tbot_web`**

Expose core metrics and logs via the Flask dashboard:

- Win rate, PnL, trade count for open/mid/close strategies
- Load and display JSON log stats to `status.html`
- Optional: overlay charts showing PnL and trade count trends by session/strategy

---

**4. Runtime Validation**

In `env_bot.py`:

- Enforce that the following keys are present and valid:
  - `ENABLE_LOGGING=true`
  - `LOG_FORMAT=json` or `csv`

- Raise a **fatal error** if any are missing or invalid, with a clear message to user/operator.

---

**5. Tuning & Optimization**

- `tuning_tracker.py`
  - Load and compare strategy logs over historical runs
  - Recommend optimized values for: 
    - `STRAT_*_BUFFER`
    - `STRAT_MID_VWAP_THRESHOLD`
    - and any tunable parameters
  - Export a summary table with:
    - buffer value → win%, avg PnL, avg trade duration
    - rejection counts (blocks, failed filters)
    - ticker frequency analysis (most/least common tickers)

---

**Note:**  
All reporting, audit, and summary outputs must be fully deterministic, timestamped in UTC, and compliant with required field layouts. No aggregation or log post-processing may be performed outside the accounting system's ingestion and reporting modules.


=============================================================================================================================================
Centralized Error Management (Lossless Compression, Spec v1.1)
=============================================================================================================================================
Overview: TradeBot uses error_handler.py for runtime exception capture, deterministic escalation, and system stability. All logic is deterministic, auditable, and fatal on validation failure.

Emergency Event Matrix:
|Event|Detection|Scope|Response|Reboot|
|-----|---------|-----|--------|------|
|PnL Loss>DAILY_LOSS_LIMIT|kill_switch.py|Broker|Halt broker, log|No|
|Broker API Down|watchdog_bot.py|Broker|Suspend broker|No|
|Market Data Down|watchdog_bot.py|All|Trigger stop_bot.py|Yes|
|.env_bot Decryption Fail|security_bot.py|All|Block launch, log|Yes|
|Logic Error|error_handler.py|Varies|Escalate if critical|Yes|
|Defense Mode On|risk_bot.py+.env_bot|All|Compress risk|No|
|Validation Fail|risk_bot.py|Broker|Block trade, log|No|
|Manual Shutdown|control_stop.txt|Any|Immediate safe shutdown|Yes|
|System File Fail|build_check.py|All|Abort launch, log|Yes|

error_handler.py:
- Captures exceptions from all modules. Types: NetworkError (API/connectivity), BrokerError (order rejects/margin), LogicError (bad logic), ConfigError (.env_bot issues).
- Logs: output/logs/unresolved_orders.log (JSON/CSV per .env_bot). Required: timestamp, strategy, broker, error_type, error_code, raw_exception, context.
- Retry: exponential backoff, escalate >API_RETRY_LIMIT, trigger kill_switch.py or shutdown if unrecoverable.
- Alerts: notifier_bot.py on critical (uses SMTP or channel in .env_bot, includes context/trace).
- On fatal, kill_switch.py called. Logs UTC, reason.
- Usage: All exception handling passes to error_handler.handle(); uncaught triggers fatal log and safe shutdown.
- Dashboard: surfaced in logs_web.py/status_web.py (optional/read-only). Operates headless by default.

Backtest Engine (backtest_engine.py):
- Simulates strategy logic (no broker/ledger write, no tbot_web dep).
- Config from .env_bot or .env_bot.test; supports toggles for filters/sensitivity.
- Each strategy implements .simulate().
- Outputs: trade_history_backtest.csv/json, daily_summary_backtest.json (no SQLite/OFX/live ledger).
- Logging: same format as live (timestamp, strategy_name, ticker, side, size, entry_price, exit_price, PnL, mode=backtest).
- Metrics: Win Rate, Max Drawdown, Avg Trade Duration, Avg PnL, Sharpe. plot_results.py for visualization.
- CLI: python tbot_bot/backtest/backtest_engine.py --strategy=STRAT --start=YYYY-MM-DD --end=YYYY-MM-DD --data_source=CSV.
- CI: pytest/pydantic, accepts .env_bot.test, no tbot_web/API needed.
- Always run before deploy; validates .env_bot parsing/error handling before prod.

Summary:
- Centralized error mgmt: every runtime/validation/logic issue logged+classified.
- Fatal = immediate halt, full context for audit.
- All audit artifacts preserved.
- Backtest engine = CI-ready, safe, no ledger/OFX/web.





=============================================================================================================================================
Testing and Validation Suite 
=============================================================================================================================================
Overview: Robust testing ensures all TradeBot logic works as intended for every strategy, env, and runtime mode. Below is the complete testing framework for pre-deployment validation.

Testing Directory: tbot_bot/tests/
- test_main_bot.py: lifecycle loop, strategy routing, logger
- test_env_bot.py: .env_bot variable coverage, error, defaults, VERSION_TAG matches VERSION.md (build fails if mismatch)
- test_backtest_engine.py: simulated trades on historical data, rule consistency
- test_strategy_selfcheck.py: all .self_check() return True
- test_logging_format.py: log structure matches JSON schema
- test_broker_trade_stub.py: randomized micro-trades for order/logging/flow
- test_screener_random.py: randomized symbol screen, filter/eligibility logic
- test_strategy_tuner.py: strategy modules in isolation, tickers, threshold configs, entry/exit logic
- integration_test_runner.py: full-session simulation, end-to-end

Planned: test_broker.py – **Manual live trade placement/close for broker readiness (not yet implemented).**

Framework:
- All use pytest, CLI/CI-compatible, modular; batch or single test
- Output: --junitxml + all CI/CD test reporters

Test Command:
pytest tbot_bot/tests/

Integration Test Flow:
- Load .env_bot.test
- Launch main_bot.py, inject mock historical data, run start_bot.py (dry)
- Confirm: strategy order (STRATEGY_SEQUENCE), log generation, triggers/errors, trade/log/export integrity

CI/DevOps:
- Compatible: GitHub Actions, GitLab CI, local runners; all headless, no GUI/API required
- Custom .env_bot.test allowed for CI override

Requirements:
- Python 3.11+, pytest, pydantic, all requirements.txt

Test-Mode:
- integration_test_runner.py runs only if TEST_MODE=true
- All outputs to logs; failures to stdout/stderr

Version Enforcement:
- test_env_bot.py must confirm .env_bot["VERSION_TAG"] == VERSION.md

=============================================================================================================================================
Real-Time Monitoring Dashboard (COA Integration, v1.1)
=============================================================================================================================================

`tbot_web/` provides a secure, independent Flask-based web dashboard for real-time bot monitoring, audit, control, and Chart of Accounts (COA) management. All UI and backend components are explicitly listed.

**Frontend UI Components:**
- `index.html`: AES-encrypted login portal; RBAC, rate-limited authentication.
- `main.html`: Dashboard shell embedding all panels (strategy, log, status, COA).
- `status.html`: Displays live bot health, session lifecycle, active strategy state, float metrics, win-rate, cumulative PnL, and risk/defense/kill switch state; data sourced from `output/{ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}/status.json`.
- `logs.html`: Streams all bot logs in real time (open.log, mid.log, close.log, unresolved_orders.log, error_tracebacks.log).
- `configuration.html`: Secure interface for credentials, email, API/broker config; encrypted at rest.
- `settings.html`: Edit and validate runtime trading parameters (timings, thresholds, risk controls); excludes credentials and COA.
- `coa.html`: **COA management and export UI**; displays account hierarchy, metadata, version. Supports Markdown/CSV export, audit diffs, and admin-only edit workflow—all actions logged to `coa_edit.log`.

**Backend Flask Components:**
- `py/__init__.py`: Blueprint registration, route setup.
- `py/auth_web.py`: AES login/session logic, RBAC enforcement, lockouts.
- `py/configuration_web.py`: Reads/writes encrypted credentials, logs changes.
- `py/settings_web.py`: Loads/validates .env_bot trading config; API for updates/errors.
- `py/status_web.py`: Serves live bot/session status: lifecycle, strategy metrics, system state, broker/API health, win-rate, PnL, float deviation, rebalance triggers, Defense/kill switch state, and error/alert counts as JSON.
- `py/logs_web.py`: Streams/paginates logs (all log types).
- `py/start_stop_web.py`: Lifecycle controls (control_start.txt/control_stop.txt), transition verification, logs.
- `py/main_web.py`: Central route router; renders dashboard.
- `py/portal_web.py`: App factory for static/templates.
- `py/run_web.py`: Webserver launcher (host/port per .env).
- `py/coa_web.py`: **COA management API:** 
    - Loads current COA metadata and account structure from `output/{ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}/ledgers/{ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_COA_v*.db`.
    - GET/POST endpoints for viewing, exporting, and editing COA (Markdown/CSV/human-table).
    - All edits admin-only, version bumps/timestamps enforced; full audit diff to `logs/web/coa_edit.log`.

**Static Assets:**
- `/static/fnt/`: Fonts.
- `/static/css/main.css`, `/static/css/theme.css`: Core/theme styling.
- `favicon.ico`, `favicon.gif`.

**Security & Audit:**
- Rate-limited login (`Flask-Limiter`); all access/failure events logged.
- RBAC: Only admins can edit COA; all actions logged (user, UTC, IP, change diff).
- COA/config/credentials always encrypted at rest; session tokens AES-encrypted.
- All UI/API actions log user, UTC, IP, action, status.

**Live Monitoring Metrics:**
- Current strategy/session state, UTC windows (from .env_bot).
- Trade stats: signals, entry/exit, PnL per trade/aggregate, win-rate.
- Float status: actual vs. target, deviation %, rebalance status (triggers + logs).
- Broker/API health, connection status, retry/error counters.
- Defense Mode, kill switch, Test Mode flags.
- Error/exception counts, unresolved order backlog.
- COA: metadata (currency_code, coa_version, entity, jurisdiction), last update, audit status, full account hierarchy.

**COA Management Workflow:**
1. Admin opens `coa.html`; COA loaded from per-bot ledger file.
2. Export COA as Markdown/CSV for audit/docs.
3. Edits (if admin): Inline table editor, live diff/preview, change summary.
4. On submit:
    - New COA version written to ledger, `coa_version` and `last_updated_utc` updated.
    - Full diff + metadata to `logs/web/coa_edit.log` (user, UTC, prev/new version).
    - No propagation—COA always local to bot instance.

**Deployment/Isolation:**
- Dashboard and bot logic are fully decoupled (UI can be disabled with zero impact to trading).
- HTTPS strongly recommended.
- Non-admins: low-bandwidth, read-only access; admin: full COA control.
- Multi-user RBAC; audit trail enforced for every change.

**Testing:**
- `test_coa_web.py`: CI test for all COA endpoints (read/export/edit/audit), RBAC, and versioning.
- All frontend/backend exceptions logged.

**Compliance:**
- All COA/log/credential output local to bot—never pushed to accounting system.
- Exports only for compliance, audit, docs.

**Summary:**
- The dashboard is audit-compliant, supports live monitoring/control, and admin-only, per-bot COA management. All actions are versioned, locally enforced, and never propagate between systems. COA export/edit requires RBAC and logs all activity for full audit compliance.


=============================================================================================================================================
TradeBot Runtime Flow 
=============================================================================================================================================

Phase 0: Pre-Session (Preparation)
↓
- Edit/validate `.env_bot` (strategy, risk, runtime) and `.env` (keypaths, creds). If encrypted, decrypt `.env_bot.enc` using `security_bot.py` with AES-256 key from `ENV_BOT_KEY` in `.env` (must be at `storage/keys/env.key`).
- Bootstrap session: create `control_start.txt` **or** submit `configuration.html` via Web UI. (No CLI bootstrapping users/creds/logs.)

Phase 1: System Boot Validation
↓
- `security_bot.py` decrypts `.env_bot.enc` using the only valid keypath (`storage/keys/env.key`).
- `env_bot.py` parses and validates all required vars; missing/malformed values = FATAL error, halt.
- Run `.self_check()` for: `risk_bot.py`, `kill_switch.py`, `watchdog_bot.py`, `error_handler.py`, `strategy_router.py`. Any failure = abort + log to `output/logs/error_tracebacks.log` (UTC).
- All checks pass → proceed to session init.

Phase 2: Session Initialization
↓
- `float_bot.py` obtains current float/cash from accounting (bot never manages float/injections).
- Load all runtime params from `.env_bot` (`MAX_TRADES`, `MAX_OPEN_POSITIONS`, `TOTAL_ALLOCATION`, `WEIGHTS`, etc.). If `DEFENSE_MODE_ACTIVE=true`, apply overrides.
- `status_bot.py` writes initial bot/session state to `output/status.json` (strategies, limits).
- Begin strategy cycle.

Phase 3: Strategy Cycle (Open → Mid → Close, UTC)
For each enabled strategy:
↓
- `strategy_router.py` loads module per `.env_bot` toggle/schedule.
- Strategy runs `.self_check()` (timing, API, float present). Failure = abort/log UTC.
- `finnhub_screener.py` scans/filters symbols (volume, float, price, .env_bot filters).
- For each candidate: calc allocation via `WEIGHTS`, enforce caps (`MAX_RISK_PER_TRADE`, `MAX_TRADES`, spread, volume).
- On pass: submit order via `broker_api.py` (delegates to adapter), log via `trade_logger.py` to `output/trades/`.
- On fail: log to `output/logs/unresolved_orders.log` (UTC).
- Monitor positions (trailing stop, VWAP/VIX/filters, API health, PnL, loss limits).
- Strategy phase ends when window closes.

Phase 4: Risk/Fault Monitoring (Continuous)
↓
- `risk_bot.py`: enforce allocation, positions, defense mode.
- `kill_switch.py`: monitor PnL/`DAILY_LOSS_LIMIT`.
- `watchdog_bot.py`: verify API.
- `error_handler.py`: uncaught exceptions to `output/logs/error_tracebacks.log` (UTC).
- On breach: `kill_switch.py` halts broker, `watchdog_bot.py` suspends/halt, DEFENSE_MODE events logged (to `disaster_mode.log`, `unresolved_orders.log`, UTC).

Phase 5: Session Termination
↓
- `stop_bot.py` closes open positions (API retry as needed).
- `reporting_bot.py` writes all logs: `trade_history.csv/json`, `open.log`, `mid.log`, `close.log`, `daily_summary.json`, `disaster_mode.log`.
- All trades/session data are routed by `accounting_api.py` (no direct ledger writes) to assigned ledger: `entities/{ENTITY}_{JURIS}/ledgers/bot/{ENTITY}_{JURIS}_{BROKER}_{BOT_ID}_BOT_ledger.db` (OFX-compliant, validated).
- `auto_backup.py` archives logs/ledgers to `backups/` (UTC); backup failures never block reporting.
- `status_bot.py` marks session "CLOSED" in status.json.
- SESSION COMPLETE

Phase 6: Manual Review/Rebalancing
- Operator/accounting reviews logs, history, summary.
- Float reconciliations handled ONLY by accounting.
- `generate_ofx.py` (accounting) for OFX export.
- If `DEFENSE_MODE` triggered, manually reset `.env_bot` flag and document recovery in session audit logs.


=============================================================================================================================================
Key Design Confirmations 
=============================================================================================================================================

- Each bot instance is permanently assigned to a **single broker per session**; all trade execution, float usage, and risk enforcement are governed by `.env_bot`/`.env_bot.enc` parameters, but **float movements, final reconciliation, and official PnL are managed exclusively by the accounting system**.
- **Bot tracks and enforces risk limits (MAX_RISK_PER_TRADE, TOTAL_ALLOCATION, MAX_TRADES, MAX_OPEN_POSITIONS, DAILY_LOSS_LIMIT, etc.) in real time**, sourced strictly from `.env_bot`.
- **PnL calculation:** The bot computes and logs running realized PnL per session/strategy for dashboard display and risk gating (e.g., halt on DAILY_LOSS_LIMIT). **Full PnL statements, accounting period summaries, and compliance/tax outputs are handled only by the accounting system**.
- **Float logic:** Bot reads assigned float at session start, enforces per-trade and per-session allocation, and **notifies accounting system when float deviates from target (rebalance trigger), but never initiates float transfers directly**.
- **System-wide shutdowns (full bot halt)** triggered only by:
    - Global market data outage (watchdog_bot.py)
    - Broker API failure or repeated rejects (watchdog_bot.py, broker_api.py)
    - Unhandled exceptions in core/strategy modules (error_handler.py, strategy_router.py, etc.)
- **Defense Mode** triggers:
    - Drawdown/risk breach (`DAILY_LOSS_LIMIT`)
    - Win-rate below threshold
    - Manual/session log flag
  While active: `TOTAL_ALLOCATION` = `DEFENSE_MODE_TOTAL_ALLOCATION`, `MAX_TRADES`/`MAX_OPEN_POSITIONS` are scaled by `DEFENSE_MODE_TRADE_LIMIT_PCT`, and **stricter screening in all enhancement modules** (.env_bot-driven).
- **All audit outputs immutable/timestamped (UTC):**
    - `tbot_bot/output/logs/`, `tbot_bot/output/trades/`, `tbot_bot/output/summaries/`
    - `entities/{ENTITY_CODE}_{JURISDICTION_CODE}/ledgers/bot/` (OFX/ledger)
    - Archived on session close via `auto_backup.py`
- **Web Dashboard (`status.html`):**
    - Displays live strategy state, win-rate, session/day/week/month PnL, float usage/alloc, broker/API health (watchdog_bot.py), session uptime, Defense Mode/kill switch status.
    - **PnL/float info displayed is for live monitoring—official records come only from accounting/ledger exports.**
- **No hybrid mode:** Each bot/ledger/output is tied to one assignment for full audit clarity.
- **Specs/process locked; all changes require `VERSION.md` doc and must be rolled out via Web UI config only.**



=============================================================================================================================================
TradeBot Master Build Enhancements (Post-Stabilization, Spec-Locked)
=============================================================================================================================================

1. Automated Rebalance Triggers:
- Float deviation thresholds set in `.env_bot` (`REBALANCE_TRIGGER_PCT`).
- `notify_rebalance_requirements.py` compares live float vs. accounting system target via secured API call (`acct_api_credentials.json.enc`).
- If deviation > threshold, POST trigger sent to accounting; bot **never initiates ACH or ledger sync directly**.
- Event logged to `output/logs/rebalance_request.log`, must also generate OFX-aligned audit entry (for downstream reconciliation).
- Fully integrated with `risk_bot.py` (risk checks) and `kill_switch.py` (can pause or halt trading during rebalance event).

2. Multi-User Access Roles (RBAC):
- `tbot_web/` dashboard supports multi-role access: `admin`, `operator`, `auditor`, `viewer`.
- Secure login with bcrypt; roles/permissions managed in `core/databases/SYSTEM_USERS.db`.
- All access attempts and auth failures logged in `logs/web/access.log` and `auth_failures.log`.
- Role determines allowed UI actions: config edit, start/stop, reporting, read-only.

3. Strategy Optimization Module:
- `strategy_optimizer.py` executes scheduled backtests using rolling window (past N days, param: `OPTIMIZER_BACKTEST_LOOKBACK_DAYS`).
- Optimization methods: grid search, Bayesian, genetic; targets: entry/exit buffer, VWAP threshold, risk size.
- Results logged in `backtest_results/strategy_tuning/`; suggested configs versioned in `env_bot.versioned/`.
- **All optimized configs require explicit human approval via Web UI before activation—never auto-applied.**

4. Real-Time Alerting:
- `notifier_bot.py` supports multi-channel notification (`email`, `slack`, `sms`, `pagerduty`), all set in `.env_bot`:
  - `CRITICAL_ALERT_CHANNEL`, `ROUTINE_ALERT_CHANNEL`
  - `NOTIFY_ON_FILL`, `NOTIFY_ON_EXIT`, `NOTIFY_ON_FAILURE`
- Alert payload: timestamp, strategy, ticker, trade size, PnL, root cause/trigger.
- Configurable per-strategy and per-event; all critical alerts must be logged.

5. Slippage & Latency Simulation:
- `backtest_engine.py` supports optional simulation of order execution latency and slippage:
  - `SLIPPAGE_SIMULATION_TYPE` in `.env_bot.test` (`none`, `rule_based`, `randomized`)
  - `SIMULATED_LATENCY_MS` parameter for delay
  - Slippage modeled using `SLIPPAGE_MEAN_PCT` and `SLIPPAGE_STDDEV_PCT`
- Outputs to `backtest_results/backtest_slippage_comparison.json`; never impacts live trading.

Implementation Notes:
- All enhancements must:
  - Implement `.self_check()` for CI and runtime validation
  - Be fully modular (toggled via `.env_bot`)
  - Log all output/events to dedicated file(s), never mix with core logic if disabled
- Enhancements must not block or interfere with live core logic if toggled off
- All code/logic adheres to safety, audit, and deterministic runtime rules for single- or multi-broker expansion

**Version tag, schema changes, and new enhancements must be documented in `VERSION.md`.**


=============================================================================================================================================
Final Build Checklist 
=============================================================================================================================================

Configuration:
- `.env` includes: `ENCRYPTION_KEY`, SMTP credentials, IP/PORT, login toggles. No hardcoded credentials.
- `.env_bot` always loaded/decrypted from `.env_bot.enc` using `security_bot.py` and key from `.env`; all trading, risk, logging variables present; `VERSION_TAG` matches `VERSION.md`.
- Bootstrap/init scripts (user/account creation, credentials, DB init) run only via Web UI portal (`configuration_web.py`). No CLI/shell-based init.

Environment Validation:
- `env_bot.py` validates presence/correctness of all required keys/structure. Fatal error if missing/malformed.
- `.env_bot.template-test` is complete, with inline comments and always up-to-date with `.env_bot` schema.

Strategy Logic:
- `main.py` loads `STRATEGY_SEQUENCE`, routes strategy calls strictly per `.env_bot` toggles.
- All `strategy_*.py` modules implement/pass `.self_check()`; failure logs fatal reason/aborts session.
- Enforces `.env_bot` constraints: volume, slippage, spread, blocklist, price/market-cap, concurrency.

Logging:
- All log output via `accounting_config.py`; entries include: UTC timestamp, ticker, size, entry/exit, strategy, float/broker source, error codes.
- Output folders: `output/logs/` (per-strategy + error logs), `output/trades/` (trade history CSV/JSON, session summaries), `output/summaries/` (wrap-up/aggregate).
- Session logs/ledgers archived post-session by `auto_backup.py`; file format (`LOG_FORMAT`) per `.env_bot` (JSON/CSV).

Ledger & Accounting:
- `reporting_bot.py` collects trade logs for ingestion.
- `accounting_api.py` routes trades/PNL to accounting ingestion pipeline.
- Ledger file: `entities/{ENTITY}_{JURIS}/ledgers/bot/{ENTITY}{JURIS}{BROKER}_{BOT_ID}_BOT_ledger.db`
- Ledger must comply with `ledger_schema.py`: OFX-aligned, double-entry, all entries tagged with currency.
- Exports handled **only** via `generate_ofx.py`; backup archives to `/backups/`.

Broker Routing:
- `broker_api.py` dispatches trades to the one assigned broker per bot (no dual/parallel).
- `watchdog_bot.py` continuously monitors broker API connectivity, fills, health; triggers shutdown/alerts on failure.

Risk/Shutdown:
- `kill_switch.py` enforces global/per-broker `DAILY_LOSS_LIMIT`, triggers halt if violated.
- `risk_bot.py` applies risk/session constraints: position count, per-trade allocation, concurrency, float caps.
- `error_handler.py` logs all uncaught errors w/traceback.
- `stop_bot.py` force-closes positions, updates session status/outputs/shutdown reason (UTC timestamped).

Notifications:
- `notifier_bot.py` sends critical alerts if enabled (`.env` SMTP + `.env_bot` toggles); routine notifications (entry/exit) per config.
- Non-critical alerts suppressed if so configured.

Testing & QA:
- Dry run validates with actual ledgers/real config.
- All pytest-based tests in `tbot_bot/test/` must pass.
- `integration_test_runner.py` simulates end-to-end lifecycle.
- `test_broker_trade_stub.py` executes/logs manual trades for validation.
- No deprecated refs; all backtests (`tbot_bot/backtest/`) are sandboxed — never affect prod outputs.

Web Interface:
- Flask uses bcrypt-hashed user auth via `auth_web.py`, stored in `SYSTEM_USERS.db` (never plaintext).
- Bot lifecycle controlled by `control/control_start.txt` & `control/control_stop.txt`; never via direct API/web calls.
- UI routes (`/status`, `/logs`, `/settings`, `/configuration`) reflect live session state, RBAC enforced at all endpoints.
- Credentials/sensitive config via encrypted secrets & secure config pages (`configuration_web.py` for creds, `settings_web.py` for runtime logic).

Deployment:
- All code uses relative paths; cross-platform.
- Flask web server and bot are separate processes (`start_bot.py`, `service_bot.py`).
- Sensitive files excluded by `.scpignore_*` (never in build archives).
- `.env_bot` version always matches `VERSION.md`.
- Only finalized outputs/archives present in repo; no temp, test, or untracked files.

Post-Session Rebalance:
- If float deviation > `REBALANCE_THRESHOLD` (`.env_bot`), `rebalance_bot.py` emits signal; accounting handles float transfer, never the bot.
- All rebalance triggers logged with UTC timestamp & session context.


# All points above are non-ambiguous, spec-compliant, and enforce the current build/QA standard for RIGD_TradingBot_v038.


*End of Document*  
[UTC:2025-05-30 14:45 — RIGD_TradingBot_v038]

