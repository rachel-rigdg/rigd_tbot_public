Document 04-rigd_tbot_SingleBrokerTransition.txt

###  Migration Notice: Single Broker Architecture — Live/Paper Duality Removed

As of **v1.0.0**, TradeBot has transitioned to a **single-broker execution model**. The prior architecture that supported dual-mode operation (live vs. paper) has been **deprecated and fully removed**.

#### Structural Changes:

- `TEST_MODE`, `PAPER_MODE`, and `LIVE_MODE` flags have been **eliminated**. Test behavior is now handled exclusively by standalone test scripts under `tbot_bot/test/`.

- Ledgers are no longer split into separate live/paper versions.

- Each bot instance is now bound to **one broker only**, determined by `BROKER_NAME` in `.env_bot.enc`:
  - `BROKER_NAME="ALPACA"`  *(Options: ALPACA, IBKR, TRADIER, etc.)*  
    The appropriate adapter module is selected at runtime based on `BROKER_NAME`.

- `ALPACA_ENABLED` and `IBKR_ENABLED` have been **fully deprecated**. Their presence in `.env_bot` will trigger a schema validation error.

- Server IP binding and web port configuration have been **moved out of `.env`** and are now injected at runtime from the decrypted file:

  tbot_bot/storage/secrets/network_config.json.enc

  This contains: `LOCAL_IP`, `LOCAL_PORT`, `REMOTE_IP`, `REMOTE_PORT`.

- All runtime strategy execution, logging, and risk enforcement occurs in a single unified mode.

- `tbot_bot` is **agnostic to entities and jurisdictions**.  
  Identity metadata (`{ENTITY_CODE}`, `{JURISDICTION_CODE}`, `{BROKER_CODE}`, `{BOT_ID}`) is injected at runtime via the encrypted file:

  tbot_bot/secrets/bot_identity.json.enc

- All TradeBot outputs — including strategy logs, trade histories, and SQLite ledgers — are written to:

tbot_bot/
│   ├── output/											 # Output Artifacts
│   │   └── {ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}/                	# ← Scoped per bot ID - Entire directory mirrored to Accounting system
│   │       ├── logs/                           					# Unified strategy logs (one per phase or failure mode)
│   │       │   ├── open.log								# Log of all trades and decisions during open strategy window
│   │       │   ├── mid.log								# Log of trades during midday session (position management, adjustments)
│   │       │   ├── close.log								# Log of closeout phase decisions and trade executions
│   │       │   ├── unresolved_orders.log						# Captures failed, rejected, or stale orders not resolved during session
│   │       │   └── error_tracebacks.log						# Full Python tracebacks for all uncaught exceptions (with timestamps)
│   │       │
│   │       ├── ledgers/  
│   │       │   ├── {ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_COA.db       		# COA for bot ledger (per broker)
│   │       │   ├── {ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_ledger.db    		# OFX-compliant ledger for live trading data per broker
│   │       │   └── {ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_FLOAT_ledger.db         # Dedicated float ledger: tracks injections, limits, drain points per bot
│   │       │
│   │       ├── summaries/
│   │       │   └── {ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_daily_summary.json		# JSON performance summary for session (PnL, latency, counts, risk triggers)
│   │       │
│   │       └── trades/
│   │           ├── {ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_trade_history.csv		# All trade data for session (raw, human-readable)
│   │           └── {ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_trade_history.json		# Structured trade records for ingestion, reconciliation, and audit


- `tbot_bot` does not write to `entities/` or interpret accounting-specific paths. The accounting system is responsible for **ingesting outputs** and relocating them for audit, archival, and OFX compliance.

- The bot does **not interpret** any part of the identity string — the `{ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}` format is enforced solely for consistency with downstream accounting processes.

- **All filenames must strictly follow this convention** to ensure correct ingestion, reconciliation, and export behavior.

#### Testing & Simulation:
- Backtesting and test execution are isolated to:
  - `tbot_bot/backtest/`
  - `tbot_bot/test/integration_test_runner.py`
  - `tbot_bot/test/test_strategy_*.py`
  - These simulate execution logic **without touching production ledgers.**
  - All test outputs write to tbot_bot/output/trades/ and are excluded from ingestion by the accounting system.

#### Web UI User Authentication Overhaul:
The Web UI (`tbot_web/`) now supports **multi-user access**, isolated from the accounting system.

##### Core Databases to be Created in `tbot_bot/core/databases/`:
- `SYSTEM_USERS.db` — Stores bcrypt-hashed user credentials
- `SYSTEM_LOGS.db` — Captures logins, config changes, security events
- `USER_ACTIVITY_MONITORING.db` — (Optional) Tracks session access, IPs, timestamps
- `PASSWORD_RESET_TOKENS.db` — (Optional) If password recovery will be supported

##### Matching Schema Files in `tbot_bot/core/schemas/`:
- `system_users_schema.sql`
- `system_logs_schema.sql`
- `user_activity_monitoring_schema.sql`
- `password_reset_schema.sql`

##### Initialization via Web UI:
- All initialization scripts are executed **internally by the Web UI** when the user submits the form on `configuration.html`.
- These include logic from:
  - `init_system_users.py`
  - `init_system_logs.py`
  - `init_user_activity_monitoring.py` *(optional)*
  - `init_password_reset_tokens.py` *(optional)*
- Manual CLI execution is no longer required. These scripts are imported as modules and triggered by `configuration_web.py`.

##### Authentication Logic in `auth_web.py` Must:
- Use `bcrypt` for all password hashing/verification
- Log login attempts to `SYSTEM_LOGS.db`
- (Optionally) Record metadata in `USER_ACTIVITY_MONITORING.db`

##### Do **not** store password or broker credentials in `.env`.

####  Updated Encryption Strategy

All sensitive tokens are now stored in **`.key` files under `storage/keys/`** and excluded from deployment via `.scpignore`:

storage/keys/
├── acct_api.key # Used to call secure endpoints in accounting system
├── broker.key # Fernet key for encrypting broker credentials (Alpaca, IBKR, etc.)
├── env.key # Fernet key for decrypting .env_bot.enc
├── login.key # bcrypt/Fernet key for password hashes and session tokens
├── screener_api.key # Finnhub or other screener API credentials
└── smtp.key # SMTP login (DreamHost, etc.)


- Remove all encrypted password blobs from `.env`.  
- Ensure each consuming script or module reads from the corresponding `.key` file.  
- Do **not** merge `.key` purposes — each use case gets its own file.

#### Benefits:
- Fully hardened access control and encryption layout
- Zero shared state with accounting system
- Aligned with CI/CD practices and deployment boundaries
- Simplified audit trails and local user isolation

---

INSTRUCTIONS FOR BUILD CHAT — TRADEBOT v1.0.0 ARCHITECTURE

PROJECT: RIGD TradeBot — Hardened Web UI + Broker Execution Refactor  
SCOPE: Implement unified broker architecture and independent user login control for the Web UI.

OBJECTIVE:
Deploy `tbot_web/` as a standalone Flask interface with independent login, audit trail, and `.key`-based encryption. Migrate all test logic to isolated folders. Ensure all runtime behavior reflects new single-broker logic.

STARTING POINT:
Begin with:

1. `system_users_schema.sql`  
2. `configuration_web.py` — runs `init_system_users.py` and related modules when user submits setup form  
3. Load `broker.key` and `env.key` for decrypting config and broker credentials  

Refer to this block for all schema, folder, and logic constraints.



