

Paste this into a fresh ChatGPT window to kick off the build:

# -----------------------------------------

Please read and internalize all content in this thread. Acknowledge that you fully understand the Objective, System Instructions, and complete architecture of the system before proceeding. This session is part of an active build process and requires strict adherence to the documented structure and rules.

# -----------------------------------------


Then paste the following in its entirety:


# -----------------------------------------





==============================
Table of Contents – TradeBot Master Build Document
==============================

1. Objective                                   # Defines the bot's purpose, trade types, and execution goals

2. System Instructions                         # Build, testing, and deployment policies for ChatGPT and human use

3. .env – Top-Level Environment File           # Broker credentials, API keys, encryption settings, SMTP config

4. .env_bot – Trading Bot Configuration        # Strategy control, timing, risk settings, broker modes

5. Overall Directory Structure Diagram         # Folder layout and modular file structure for full system

6. Deployment Notes                            # Runtime behavior, environment requirements, and broker validation

7. Current Platforms                           # Development and production system compatibility

8. Time Zone Standards                         # Enforces UTC across strategy, logging, and exports

9. TradeBot Strategy Logic Spec v1.0           # Core strategy design: breakout, mean reversion, close logic

10. Runtime Modes                              # TEST_MODE, LIVE mode, and FORCE_PAPER_EXPORT explained

11. Capital Risk Controls                      # Max position size, allocation, trade weights, and limits

12. Strategy Modules (Unified Format)          # Behavior, toggles, enhancements, and lifecycle per strategy

13. Strategy Allocation Clarification          # Dynamic weighting logic and capital exposure limits

14. Logging & Reporting Format                 # Output files, log format, JSON/CSV routing by mode

15. Ledger Architecture                        # Manager.io-compatible structure and accounting categories

16. Enhancement Module Activation              # Plug-in logic filters (ADX, VIX, Bollinger, Imbalance, etc.)

17. Safety Systems                              # Risk aborts, broker disconnects, error classification

18. Secure Environment Variables                # Encrypted configs, AES keys, decryption process

19. Centralized Error Management                # Structured runtime error capture, classification, and escalation

20. Backtesting Framework                       # Historical replay engine, metrics, and test-mode simulation

21. Testing and Validation Suite                # Unit, integration, and CI-ready testing structure

22. Real-Time Monitoring Dashboard              # Flask-based read-only UI for monitoring and control

23. Final Build Checklist                       # Pre-deployment verification for safe execution



==============================
Objective
==============================

TradeBot automatically identifies securities in a bi-directional manner and places trades using:

- Long equity positions when bullish criteria are met.
- Long put options or inverse ETFs when bearish signals are triggered.

Supported brokers must allow:
- Long equity trading
- Long puts or inverse ETFs (based on `SHORT_TYPE_*` per strategy in `.env_bot`)
- Paper trading API access (when `TEST_MODE=true` or `FORCE_PAPER_EXPORT=true`)

TradeBot is designed to run in real-time using intraday strategies, and must support:

- Fully automated execution and dynamic position sizing
- Headless operation without requiring a web interface or API server
- Live risk enforcement via `.env_bot` controls (`DAILY_LOSS_LIMIT`, `MAX_RISK_PER_TRADE`, etc.)
- Audit-ready reporting via GnuCash ledger output
- Independent operation of all modules (`tbot_bot/`, `tbot_api/`, `tbot_web/`)

All trade execution, logging, and ledger export functions must be self-contained and operational without external triggers or user input.

Execution, broker access, and strategy activation are governed independently using:
- `ALPACA_ENABLED`, `IBKR_ENABLED`, etc.
- `STRAT_OPEN_ENABLED`, `STRAT_MID_ENABLED`, `STRAT_CLOSE_ENABLED`
- `FORCE_PAPER_EXPORT` overrides live exports even when `TEST_MODE=false`



==============================
System Instructions (Active Debugging Phase)
==============================

ChatGPT’s memory is not persistent across sessions. To ensure full traceability, consistency, and safety during debugging, testing, and deployment:

1. **All files must be printed as single complete Code Blocks** in the chat.
   - Do not use ZIPs, summaries, or partial output.
   - Each Code Block must be labeled with the filename as a comment at the top (e.g., `# tbot_bot/trading/orders_bot.py`).

2. **All environment-specific values must reference variables from `.env`, `.env_bot`, or `.env_bot.enc`.**
   - Do **not** hardcode API keys, thresholds, toggles, or paths.
   - Suggest new variables only if required, and document them clearly.

3. **Debugging & Testing Behavior:**
   - Perform only **one action or file generation at a time**.
   - Wait for **explicit user confirmation** (e.g., "continue", "go", "next") before proceeding.
   - Do **not** assume next steps or combine tasks.

4. **All code must include inline comments** that:
   - Explain logic and purpose
   - Reference relevant `.env_bot` settings or runtime flags
   - Clarify conditional paths or fallback behavior

5. **All code output must be complete and executable.**
   - Regenerate entire files — do not use patches or diffs unless explicitly allowed.
   - Never insert placeholders or mock logic unless explicitly instructed.

6. **All file paths must be relative and portable.**
   - No absolute paths or platform-specific logic.
   - All code must run on macOS, Linux, and production servers without modification.

7. **When `TEST_MODE=true`:**
   - Use broker paper trading APIs only
   - Write all logs and ledger exports to `_paper` files
   - Skip volume, spread, and slippage filters (unless overridden)
   - Never write to `_live` files or ledgers

8. **When `FORCE_PAPER_EXPORT=true`:**
   - All output (logs, trades, ledger) is routed to `_paper` files, regardless of broker or `TEST_MODE`
   - Broker API routing still respects `ALPACA_MODE`, `IBKR_MODE`

9. **Ledger Export Behavior:**
   - Write to `output/ledgers/tbot_Live_Ledger.manager` only if:
     - `TEST_MODE=false` AND `FORCE_PAPER_EXPORT=false`
   - Write to `output/ledgers/tbot_Paper_Ledger.manager` when:
     - `TEST_MODE=true` OR `FORCE_PAPER_EXPORT=true`

10. **Do not re-import `.csv` or `.json` trade logs** into accounting ledgers.
    - Ledgers are generated in memory from validated trade data only.
    - `.csv`/`.json` are for audit, review, or dashboards — not input.

11. **All strategy modules must include a `.self_check()` method**
    - `main.py` must call `.self_check()` before executing any strategy
    - Failure blocks the strategy and logs the failure clearly

12. **TEST_MODE Dry-Run Requirements:**
    - Must be completed before:
      - First production deployment
      - Any change to broker, accounting logic, or core strategy behavior
    - Confirms:
      - Broker connection
      - Trade logging
      - Ledger export
      - Notifications (if enabled)

13. **`env_bot.py` must validate**:
    - All required keys in `.env_bot`
    - Halt with a clear, human-readable error if keys are missing or malformed

14. **Log and ledger outputs must include:**
    - `timestamp`, `strategy_name`, `ticker`, `side`, `size`
    - `entry_price`, `exit_price`, `PnL`
    - `broker`, `mode` (live/paper)
    - `error_code` (if applicable)

15. **`VERSION.md` is mandatory** and must include:
    - Version tag
    - Major architecture or logic changes
    - Behavior differences across releases

16. **No emojis are allowed** anywhere in code, comments, output, or documentation.

17. **All modules must remain testable and executable independently:**
    - `tbot_bot/` must not rely on `tbot_web/` or any frontend
    - Flask/web modules may be disabled without affecting core logic

18. **Broker and strategy control must be modular and toggleable via `.env_bot`:**
    - `ALPACA_ENABLED`, `IBKR_ENABLED`
    - `STRAT_OPEN_ENABLED`, `STRAT_MID_ENABLED`, `STRAT_CLOSE_ENABLED`

19. **All final files must be reprinted in full for backup or version locking.**
    - This includes every regenerated script, config, and ledger

20. **No assumptions, no shortcuts, no improvisation.**
    - If an instruction or config is unclear, request clarification before proceeding




==============================
.env – Top-Level Environment File
==============================

# .env – Top-Level Environment Configuration
# Handles global system, API, encryption, and notification settings
# This file is parsed by tbot_api/, tbot_bot/, and related utility scripts

# -----------------------------------------
# Environment Flags
# -----------------------------------------
ENVIRONMENT="production"         # production or development mode
LOCAL=true                       # If running in local dev environment
LOCAL_IP=""                      # Optional: bind to a specific local IP
LOCAL_PORT="6900"                # Port for local web/API access
REMOTE_IP=""                     # Optional: external IP override
REMOTE_PORT="6900"               # Port for external access or reverse proxy
ENV_BOT_KEY="" 			# Bot Config Encryption

# -----------------------------------------
# Authentication (for web login)
# -----------------------------------------
USERNAME=""                      # Web dashboard login username
PASSWORD=""                      # (Optional) plaintext password (not used in production)
ENCRYPTED_PASSWORD=""            # Required for login; use encrypt_password.py to generate
ENCRYPTION_KEY=""                # AES key to decrypt .env_bot and validate user credentials
SESSION_TIMEOUT="3000"            # Session Timeout- Default: 3000 seconds (50 minutes)


# -----------------------------------------
# API Keys & External Services
# -----------------------------------------

# Finnhub – used for screener, price/volume lookup
FINNHUB_API_KEY=""

# -----------------------------------------
# Alpaca Broker Credentials
# -----------------------------------------
ALPACA_PAPER_API_KEY=""          # Paper trading key
ALPACA_PAPER_SECRET_KEY=""       # Paper secret
ALPACA_LIVE_API_KEY=""           # Live trading key
ALPACA_LIVE_SECRET_KEY=""        # Live secret
ALPACA_PAPER_URL="https://paper-api.alpaca.markets"
ALPACA_LIVE_URL="https://api.alpaca.markets"

# -----------------------------------------
# Interactive Brokers (IBKR) API Credentials
# -----------------------------------------
IBKR_PAPER_USERNAME=""           # TWS username (paper)
IBKR_PAPER_ACCOUNT_NUMBER=""     # Account number used for paper trades
IBKR_PAPER_PASSWORD=""           # Optional: stored securely if automation is enabled
IBKR_LIVE_API_KEY=""             # API key for live session
IBKR_LIVE_SECRET_KEY=""          # Secret for live trading

# -----------------------------------------
# Notifications (Email Alerts)
# -----------------------------------------
ALERT_EMAIL=tb@tb.rgdnn.com      # Email to send alerts to
SMTP_USER=tb@tb.rgdnn.com        # SMTP login
SMTP_PASS=MyTPassIs5^            # SMTP password or app-specific key
SMTP_HOST=smtp.dreamhost.com     # SMTP server
SMTP_PORT=486                    # SMTP port for TLS/SSL relay






==============================
# .env_bot – Trading Bot Configuration File
==============================


# Controls strategy timing, broker access, risk, logging, and reporting.
# All time values are in UTC.

# -----------------------------------------
# General & Debugging
# -----------------------------------------
VERSION_TAG=v1.0.0                     # Bot version label
BUILD_MODE=release                     # Options: debug, release
DISABLE_ALL_TRADES=false               # Master kill switch to block all trades
TEST_MODE=true                         # Enables paper APIs, skips filters, shortens runtime
FORCE_PAPER_EXPORT=false               # Force all trades to route to paper ledger even in live mode
DEBUG_LOG_LEVEL=verbose                # Logging level: quiet, info, verbose
ENABLE_LOGGING=true                    # Enables all file output logs
LOG_FORMAT=json                        # Options: json (structured) or csv (flat text)

# -----------------------------------------
# Trade Execution & Risk Controls
# -----------------------------------------
TRADE_CONFIRMATION_REQUIRED=false      # Require manual confirmation before sending trade orders
API_RETRY_LIMIT=3                      # Broker API retry attempts before failing
FRACTIONAL=true                        # Enable fractional share trading (if broker supports it)
TOTAL_ALLOCATION=0.02                  # Total capital to allocate per strategy window (e.g., 2%)
MAX_TRADES=4                           # Maximum number of trades allowed per strategy
WEIGHTS=0.4,0.2,0.2,0.2                # Allocation weights per trade if multiple entries trigger
DAILY_LOSS_LIMIT=0.05                  # Max daily loss threshold (as percent of capital)
MAX_RISK_PER_TRADE=0.025               # Max capital at risk per trade (e.g., 2.5%)
MAX_OPEN_POSITIONS=5                   # Cap on total concurrent open positions across all strategies

# -----------------------------------------
# Price & Volume Filters
# -----------------------------------------
MIN_PRICE=2                            # Minimum stock price filter
MAX_PRICE=100                          # Maximum stock price filter
MIN_VOLUME_THRESHOLD=1000000           # Minimum daily volume filter (ignored if TEST_MODE=true)

# -----------------------------------------
# Strategy Routing & Broker Mode
# -----------------------------------------
ALPACA_ENABLED=true                    # Enable Alpaca broker integration
IBKR_ENABLED=true                      # Enable Interactive Brokers integration
ALPACA_MODE=paper                      # Alpaca account mode: live or paper
IBKR_MODE=paper                        # IBKR account mode: live or paper
STRATEGY_SEQUENCE=open,mid,close       # Execution order for strategies
STRATEGY_OVERRIDE=null                 # Optional: run only one strategy (open, mid, close)

# -----------------------------------------
# Global Time & Polling
# -----------------------------------------
TRADING_DAYS=mon,tue,wed,thu,fri       # Days allowed for trading (UTC-based)
SLEEP_TIME=1s                          # Delay between polling cycles (e.g., 1s, 5s, 10s)

# -----------------------------------------
# OPEN Strategy Configuration
# -----------------------------------------
STRAT_OPEN_ENABLED=true                # Master toggle for OPEN strategy
START_TIME_OPEN=14:30                  # UTC start time (9:30 AM EST)
OPEN_ANALYSIS_TIME=20                  # Minutes to build opening range
OPEN_MONITORING_TIME=30                # Duration to monitor and exit trades
STRAT_OPEN_BUFFER=0.02                 # Breakout buffer percentage (e.g., 2%)
SHORT_TYPE_OPEN=disabled               # Shorting type: ShortSell, LongPut, InverseETF, or disabled

# -----------------------------------------
# MID Strategy Configuration (VWAP Mean Reversion)
# -----------------------------------------
STRAT_MID_ENABLED=true                 # Master toggle for MID strategy
START_TIME_MID=15:30                   # UTC start time (10:30 AM EST)
MID_ANALYSIS_TIME=10                   # Minutes to validate VWAP signal
MID_MONITORING_TIME=45                 # Duration to monitor trade
STRAT_MID_VWAP_THRESHOLD=0.02          # VWAP deviation trigger percentage
SHORT_TYPE_MID=InverseETF              # Shorting type for MID: ShortSell, LongPut, InverseETF, or disabled

# -----------------------------------------
# CLOSE Strategy Configuration (Momentum or Fade)
# -----------------------------------------
STRAT_CLOSE_ENABLED=true               # Master toggle for CLOSE strategy
START_TIME_CLOSE=19:30                 # UTC start time (2:30 PM EST)
CLOSE_ANALYSIS_TIME=10                 # Minutes to identify trend or fade
CLOSE_MONITORING_TIME=30               # Duration to manage position
STRAT_CLOSE_VIX_THRESHOLD=15           # VIX threshold to enable entry
SHORT_TYPE_CLOSE=LongPut               # Shorting type for CLOSE: ShortSell, LongPut, InverseETF, or disabled

# -----------------------------------------
# Notifications
# -----------------------------------------
NOTIFY_ON_FILL=true                    # Email alert when trade is filled
NOTIFY_ON_EXIT=true                    # Email alert when trade is closed

# -----------------------------------------
# Reporting & GnuCash Export
# -----------------------------------------
GNC_EXPORT_MODE=auto                   # Options: auto = export after each trade, off = skip export




====================================
Overall Directory Structure Diagram
====================================

├── TradeBot-001/
│
│   # Core Metadata & Environment Config
│   ├── VERSION.md                       # Version change log for human or GPT reference
│   ├── CHANGELOG.md                     # Technical commit-style change history (optional)
│   ├── README.md                        # Project overview, architecture, and usage instructions
│   ├── requirements.txt                 # Python package dependencies
│
│   ├── .env                             # Global config (Flask port, encryption keys, login)
│   ├── .env_bot                         # Decrypted bot settings (overwritten each run if using encrypted version)
│   ├── .env_bot.template-test           # Example/test-mode config for cloning bots
│   ├── .scpignore_env                   # Excludes only env/config
│   ├── .scpignore_dev                   # Excludes test scripts, logs, debug files
│   ├── .scpignore_enc                   # Used when deploying encrypted-only configs
│   ├── .scpignore_prod_archive          # Used when deploying archive packages (no .env, no .gnucash, etc.)
│
│   # Encryption / Auth Tools
│   ├── tools/
│   │   ├── encrypt_password.py          # AES-encrypts login password and updates .env
│   │   ├── encrypt_env_bot.py           # Encrypts .env_bot and saves it as env_bot.enc
│   │   └── sync_project.sh              # CLI interface for dev→live→prod folder syncs
│
│   # Runtime Output / Audit Artifacts
│   ├── backups/                         # Archived ledgers and logs (daily snapshots)-  Matches /output/summaries/*.json at session end
│   │   ├── logs_live_*.zip              # Zipped bot logs (live)
│   │   ├── logs_paper_*.zip             # Zipped bot logs (paper)
│   │   ├── manager_live_*.manager       # Timestamped Manager.io ledger backups (live sessions)
│   │   ├── manager_paper_*.manager      # Timestamped Manager.io ledger backups (test/paper sessions)
│   │   ├── summary_live_*.json          # JSON reports from live session
│   │   └── summary_paper_*.json         # JSON reports from test mode
│
│   ├── logs/                            # Active logging folder (rotated or zipped by auto_backup)
│   │   ├── bot/
│   │   │   ├── live/                    # Live logs by strategy phase (open, mid, close)
│   │   │   └── paper/                   # Simulated logs (test mode)
│   │   └── web/
│   │       ├── access.log               # IP/timestamp of each login request
│   │       └── auth_failures.log        # Failed login attempts, lockout triggers
│
│   # Internal Documentation
│   ├── docs/
│   │   ├── architecture.md              # System architecture and module breakdown
│   │   ├── API_reference.md             # CLI & internal API details (optional)
│   │   └── security_notes.md            # Data handling, encryption key roles, etc.
│
│   # Automation Scripts (Optional)
│   ├── scripts/
│   │   ├── sync_to_company_books.py     # Pushes .manager data to formal books
│   │   ├── audit_log_parser.py          # CLI utility to review logs and summarize behavior
│   │   └── upload_backups_to_cloud.sh   # Syncs backups/ to S3 or external vault
│
│
├── tbot_bot/                             # Core engine for execution, strategy logic, reporting, and control
│
│   # Accounting Scripts & Logic (modular, software-agnostic)
│   ├── accounting/
│   │   ├── account_transaction.py           # Generic transaction entry builder used by all accounting exporters
│   │   ├── accounting_api.py                # Dispatches ledger export to the active accounting backend
│   │   ├── accounting_config.py             # Controls ledger export behavior and file format settings
│   │   ├── ledger_schema.py                 # Defines account hierarchy and types for use in all exports
│   │   ├── manager_exporter.py              # Generates Manager.io-compatible accounting entries
│   │   └── tradebot_ledger_schema.sql	     # SQL reference for ledger structure – mirrors Manager.io layout; not used to write data
│
│   # Backtesting & Research
│   ├── backtest/
│   │   ├── backtest_engine.py           # Core simulator to replay past trades
│   │   ├── load_historical_data.py      # Load from CSV, OHLCV, or tick sources
│   │   ├── performance_metrics.py       # Computes performance metrics for backtest results - Sharpe, win %, drawdown, etc.
│   │   └── plot_results.py              # Graphs equity curves, trades, and heatmaps
│
│   # Broker Integrations
│   ├── broker/
│   │   ├── broker_alpaca.py             # Alpaca implementation (live/paper)
│   │   ├── broker_api.py                # Unified broker interface and trade dispatch router
│   │   ├── broker_ibkr.py               # Interactive Brokers implementation (live/paper)
│   │   ├── broker_robinhood.py          # Placeholder integration for sandbox/testing (not production)
│   │   ├── broker_tastytrade.py         # Placeholder integration for sandbox/testing (not production)
│   │   └── broker_webull.py             # Placeholder integration for sandbox/testing (not production)
│
│   # Configuration & Security
│   ├── config/
│   │   ├── env_bot.py                    # Validates and parses .env_bot
│   │   ├── error_handler.py             # Centralized exception manager and classified logging for tbot
│   │   ├── security_bot.py              # Encrypts/decrypts .env_bot to .env_bot.enc
│   │   └── settings_bot.py              # Programmatic editor for .env_bot values
│
│   # Control Signals (Web/CLI)
│   ├── control/
│   │   ├── control_start.txt            # Start flag file created by web/CLI to trigger bot launch
│   │   └── control_stop.txt             # Stop flag file created by web/CLI to trigger safe shutdown
│
│   # Enhancements (Optional Guards & Filters)
│   ├── enhancements/
│   │   ├── adx_filter.py                # Blocks mid-session trades during trending ADX conditions
│   │   ├── bollinger_confluence.py      # Confirms entries using Bollinger band alignment
│   │   ├── build_check.py               # Validates presence of required files and config before launch
│   │   ├── imbalance_scanner_ibkr.py    # Scans IBKR imbalance feed for market-on-close risk
│   │   ├── ticker_blocklist.py          # Prevents duplicate ticker trading in same session
│   │   └── vix_gatekeeper.py            # Blocks close strategy if VIX is under threshold
│
│   # Output Artifacts
│   ├── output/                             # Canonical location for all bot-generated files
│   │   ├── ledgers/                        # Generated accounting files for live/paper modes (Manager.io)
│   │   │   ├── tbot_live_ledger.manager        # Manager.io-compatible ledger file for real trades
│   │   │   └── tbot_paper_ledger.manager       # Manager.io-compatible ledger file for simulated (paper) trades
│   │   ├── logs/                           # Strategy-specific and broker-level logs
│   │   │   ├── close_live.log                  # Strategy log – close (live)
│   │   │   ├── close_paper.log                 # Strategy log – close (paper)
│   │   │   ├── mid_live.log                    # Strategy log – mid (live)
│   │   │   ├── mid_paper.log                   # Strategy log – mid (paper)
│   │   │   ├── open_live.log                   # Strategy log – open (live)
│   │   │   ├── open_paper.log                  # Strategy log – open (paper)
│   │   │   ├── unresolved_orders_live.log      # Live broker error log
│   │   │   └── unresolved_orders_paper.log     # Paper broker error log
│   │   ├── summaries/                      # End-of-session performance summaries and trade metrics
│   │   │   ├── daily_summary_live.json         # End-of-session stats and trade summaries of live session (PNL, fills, errors)
│   │   │   └── daily_summary_paper.json        # End-of-session stats and trade summaries of paper session
│   │   └── trades/                         # CSV and JSON trade history for each run
│   │       ├── trade_history_live.csv          # Raw log (live trades)
│   │       ├── trade_history_live.json         # Structured JSON (live)
│   │       ├── trade_history_paper.csv         # Raw log (test trades)
│   │       └──trade_history_paper.json        # Structured JSON (test)
│
│   # Reporting & Logging
│   ├── reporting/
│   │   ├── auto_backup.py               # Compresses and archives logs/ledgers after session end
│   │   ├── session_report.py            # Generates final report for each trading session
│   │   └── status_logger.py             # Writes status.json for web interface sync
│
│   # Session Lifecycle
│   ├── runtime/
│   │   ├── main.py                      # Main bot controller (analysis → trade → shutdown)
│   │   ├── start_bot.py                 # Main entry point for bot; starts session lifecycle and strategy sequence
│   │   ├── status_bot.py                # Tracks and records state changes
│   │   ├── stop_bot.py                  #  Safely exits all positions and ends session
│   │   ├── tbot_runner_supervisor.py 	# Oversees session state, handles retries, enforces global watchdog logic
│   │   └── watchdog_bot.py              # Broker connectivity monitor and auto-retry
│
│   # Screener & Symbol Selection
│   ├── screeners/
│   │   └── finnhub_screener.py          #  Screens symbols using Finnhub price and volume data
│
│   # Strategy Logic
│   ├── strategy/
│   │   ├── strategy_close.py            # Implements Late-day momentum/fade strategy with VIX gating
│   │   ├── strategy_meta.py             # Thresholds and toggles used by all strategies
│   │   ├── strategy_mid.py              # Implements VWAP-based mean reversion strategy
│   │   ├── strategy_open.py             # Implements opening range breakout strategy logic
│   │   └── strategy_router.py           # Routes execution to correct strategy based on time or STRATEGY_OVERRIDE

│
│   # Support
│   ├── support/
│   │   ├── utils_bot.py                     # Shared utilities (time, math, file ops, conversions)
│   │   ├── service_bot.py                   # Daemon listener for start/stop signals (optional systemd hook)
│   │   └── env_bot.enc                      # Encrypted bot config loaded at runtime
│
│   # Test Suite
│   ├── test/
│   │   ├── integration_test_runner.py   # Simulates full bot session in TEST_MODE for integration validation
│   │   ├── test_backtest_engine.py      # Regression test for backtest engine accuracy
│   │   ├── test_env_bot.py              # Validates .env_bot parsing, defaults, and edge cases
│   │   ├── test_exporter_manager.py     # Test Manager.io export output for schema compliance
│   │   ├── test_main_bot.py             # Core lifecycle testing
│   │   ├── test_strategy_selfcheck.py   # Confirms all strategy modules pass .self_check()
│   │   └── test_logging_format.py       # Log format validator
│
│   # Trade Execution
│   └── trading/
│       ├── kill_switch.py              # Abort if drawdown exceeds DAILY_LOSS_LIMIT
│       ├── logs_bot.py                  # Runtime trade + session logging
│       ├── notifier_bot.py              # Alerts via email or Slack
│       ├── orders_bot.py                # Submit, modify, or cancel broker orders
│       ├── reporting_bot.py             # Logs trade results and routes output to accounting exporters
│       └── risk_bot.py                  # Risk management enforcement (allocations, max trades)
│
│
│
└── tbot_web/                             # Web dashboard for monitoring, logs, and control
    ├── assets/                           # Static frontend resources
    │   ├── fnt/                          # Embedded fonts used in the interface
    │   └── css/
    │       ├── main.css                 # Core layout and UI styling rules
    │       └── theme.css                # Optional theme layer (e.g. light/dark modes)
    ├── favicon.ico / favicon.gif        # Site icon for browser tab
    ├── py/                              # Flask backend for web UI and bot interaction
    │   ├── __init__.py                  # Registers Flask blueprints for all routes
    │   ├── auth_web.py                  # AES decryption for login password validation
    │   ├── login_web.py                 # Login/logout route handling with rate limit enforcement
    │   ├── logs_web.py                  # Displays latest bot log output to the web UI
    │   ├── main_web.py                  # Web router and load shell for dashboard interface
    │   ├── portal_web.py                # Flask app factory for app + static + template setup
    │   ├── run_web.py                   # Webserver launcher for local or remote access
    │   ├── settings_web.py              # Updates .env_bot config via web interface
    │   ├── start_stop_web.py            # Drops control_start.txt / control_stop.txt to trigger bot control loop
    │   ├── status_web.py                # Loads bot status from JSON output (status_bot.json)
    ├── robots.txt                       # Blocks bots and search engine indexing (security)
    └── templates/                       # HTML UI templates rendered with Jinja2
        ├── index.html                   #  Login screen rendered via Jinja2
        ├── main.html                    # Dashboard shell container with embedded panels
        ├── logs.html                    # Shows logs from current session in read-only format
        ├── settings.html                # Editable UI form for modifying .env_bot values
        └── status.html                  # Live bot status pulled from status_bot.json



==============================
Deployment Notes
==============================

- All file paths must be **relative and platform-agnostic**, ensuring compatibility across macOS, Linux, and cloud servers (e.g., DigitalOcean).
- The `tbot_bot/` module must operate **fully independently**, even if `tbot_api/` (FastAPI interface) or `tbot_web/` (frontend) are disabled or unavailable.
- All logs, ledger exports, and backup behavior must remain active regardless of whether API or web modules are enabled.
- On first deployment, enable **only one broker** (`ALPACA_ENABLED=true` or `IBKR_ENABLED=true`) to simplify debugging and test connectivity.
- At startup, all enabled brokers must validate their API credentials from `.env`. Missing, malformed, or unauthorized keys must trigger a hard stop.
- Strategy activation is controlled independently using:
  - `STRAT_OPEN_ENABLED`
  - `STRAT_MID_ENABLED`
  - `STRAT_CLOSE_ENABLED`
- Before placing **live trades**, the bot must check:
  - Market spread: abort if spread > 1.5% of `entry_price`
  - Volume threshold: abort if average daily volume < `MIN_VOLUME_THRESHOLD` (unless `TEST_MODE=true`)
  - Risk: validate against `MAX_RISK_PER_TRADE` and `DAILY_LOSS_LIMIT`
- Auto-shutdown must occur if:
  - The broker API is offline (`watchdog_bot.py`)
  - A critical error is caught by `error_handler.py`
  - Cumulative losses exceed `DAILY_LOSS_LIMIT` (triggered via `kill_switch.py`)
- TEST_MODE must never write to:
  - `gnu_live.gnucash`
  - Any log files with `_live` in their name
  - Any `.json`, `.log`, or `.csv` file outside the `_paper` variants
- `FORCE_PAPER_EXPORT=true` overrides normal TEST_MODE behavior and forces all exports to `_paper` outputs. This includes trade history, strategy logs, daily summaries, and GnuCash ledger writes.
- GnuCash XML exports are saved to:
  - `gnu_live.gnucash` when `TEST_MODE=false` and `FORCE_PAPER_EXPORT=false`
  - `gnu_paper.gnucash` when `TEST_MODE=true` or `FORCE_PAPER_EXPORT=true`
- All GnuCash ledger writes are preceded by an automated timestamped backup using `gnu_backup.py`, saved under `/backups/`.
- Session logs are stored in `/logs/bot/live/` or `/logs/bot/paper/`, then zipped and archived to `/backups/` by `auto_backup.py`.
- All backups may be optionally synced to external storage (e.g., S3, Dropbox, or remote FTP) via the optional script:
  - `scripts/upload_backups_to_cloud.sh`
- Strategy timing and trade session control is managed via `.env_bot` using:
  - `START_TIME_OPEN`, `START_TIME_MID`, `START_TIME_CLOSE`
  - `[STRAT]_ANALYSIS_TIME` and `[STRAT]_MONITORING_TIME` per strategy
- All test runs and live executions must honor `TRADING_DAYS` to prevent execution on weekends or holidays (manually disabled as needed).




==============================
Current Platforms
==============================

Development Environment:
- Local testing and version control are performed on macOS 15.2 with Python 3.11+
- All code must be compatible with macOS and Linux (no platform-specific imports or absolute paths)
- Recommended IDE: Visual Studio Code with Black or Ruff for formatting and linting
- Python scripts are executed via terminal or cron, not from GUI IDEs
- Local logs and test exports are saved to `logs/bot/paper/` and `backups/`

Production Deployment:
- Hosted on a DigitalOcean droplet running Ubuntu 22.04 LTS
- Deployed via secure SCP/SFTP
- Execution initiated using:
  - `start_bot.py` (manual or cron trigger)
  - `service_bot.py` (optional daemon for systemd)
- Production mode writes to `logs/bot/live/` and `output/ledgers/tbot_Live_Ledger.manager`

Broker Integrations:
- Alpaca: used for stock/ETF trading and paper/live testing (`ALPACA_MODE` in `.env_bot`)
- Interactive Brokers: supports long puts, inverse ETFs, and advanced routing (`IBKR_MODE`)
- Tastytrade, Webull, and Robinhood modules exist in sandbox/test only (not yet production-ready)

Market Data Services:
- Finnhub API provides real-time screening/filtering for all strategies via `finnhub_screener.py`
- Supports pre-market scans, volume thresholds, and breakout/high-low tracking

Accounting Integration:
- Modular accounting engine supports multiple backends via `accounting_api.py`
- Current implementation uses `manager_exporter.py` to generate Manager.io-compatible ledgers
- Ledgers are written to `output/ledgers/` and rotated daily by `auto_backup.py`
- Structure defined by `ledger_schema.py` for universal mapping

Web Interface:
- `tbot_web/`: Flask-based dashboard for live monitoring, control, and configuration
- Supports real-time log viewing, session status, settings updates, and manual start/stop
- Login credentials are AES-encrypted and validated with bcrypt
- All login failures and access attempts are logged to `logs/web/auth_failures.log`

Alerting & Notifications:
- Trade fills and exits can trigger email alerts when `NOTIFY_ON_FILL` or `NOTIFY_ON_EXIT` are enabled
- Emails are dispatched via DreamHost SMTP using credentials defined in `.env`

Security:
- `.env_bot` is encrypted to `.env_bot.enc` using `security_bot.py`
- AES key is stored in the root `.env` file under `ENV_BOT_KEY`
- `.env_bot` is never committed to version control and must be manually restored or decrypted



==============================
Time Zone Standards
==============================

Overview:
To ensure consistency, accuracy, and interoperability across development, testing, and production environments, all time-related variables in TradeBot are defined and logged in **UTC (Coordinated Universal Time)**.

Usage:
- All strategy start times (`START_TIME_OPEN`, `START_TIME_MID`, `START_TIME_CLOSE`) are set in UTC
- Log timestamps, strategy triggers, ledger entries, and alerts must all use UTC
- Internal time comparisons in `strategy_router.py` and `status_bot.py` must convert local system time to UTC before logic execution

Reasoning:
- UTC avoids ambiguity across time zones, daylight saving time shifts, or server environments (macOS, Linux, cloud)
- Allows reliable scheduling when hosting in geographically distributed environments (e.g., DigitalOcean, AWS)
- Compatible with broker API timestamps and log analysis pipelines

Example Mapping:
- 14:30 UTC → 9:30 AM EST (Market Open)
- 15:30 UTC → 10:30 AM EST (Midday Strategy)
- 19:30 UTC → 2:30 PM EST (Close Strategy)

Implementation Tip:
If debugging locally in EST or PST, always convert timestamps before interpreting logs or database entries.

Best Practice:
Add a helper function in `utils_bot.py`:
```python
def utc_now():
    return datetime.utcnow().replace(tzinfo=timezone.utc)




==============================
TradeBot Strategy Logic Spec v1.0
==============================

Overview:
TradeBot executes intraday breakout and reversion strategies using a unified logic pipeline. All entries are directional and follow structured risk, time, and allocation parameters.

Supported Instruments:
- Long equity (common stocks or ETFs)
- Inverse ETFs (e.g., SH, SQQQ)
- Long puts (IBKR only)

Trade Direction Rules:
- Long trades = supported on all brokers
- Bearish trades = only executed if `SHORT_TYPE_*` is not `disabled`
- Puts = only used if broker = IBKR and `SHORT_TYPE_*` = LongPut
- Inverse ETFs = fallback for non-options brokers when `SHORT_TYPE_*` = InverseETF

Supported Brokers:
- Alpaca: long equity, inverse ETFs
- IBKR: long equity, long puts, inverse ETFs
- Webull: read-only (screening only)
- Tastytrade, Robinhood: reserved for future support

Execution Framework:
- Strategy execution is controlled via `STRATEGY_SEQUENCE` in `.env_bot`
- Each strategy module is loaded independently by `strategy_router.py`
- Runtime logic respects UTC windows and `.env_bot` timing variables

Active Strategies:
TradeBot includes three modular strategies:

-----------------------------------------
Strategy: strategy_open.py – Opening Range Breakout
-----------------------------------------

- Time Window:
  - Starts at `START_TIME_OPEN`
  - Uses `OPEN_ANALYSIS_TIME` to track initial high/low range
  - Monitors active trades for `OPEN_MONITORING_TIME`
- Trade Direction: Long only
- Entry Logic:
  - Track high and low during analysis window
  - Entry if price breaks above high (+ `STRAT_OPEN_BUFFER`)
  - Volume confirmation enforced unless `TEST_MODE=true`
- Exit Logic:
  - Stop-loss triggered at 2% drawdown
  - Hard exit after monitoring window
- Shorting: Always disabled (`SHORT_TYPE_OPEN=disabled`)
- Logging:
  - `open_live.log` or `open_paper.log`
  - `trade_history_*.csv` and `*.json`
  - `gnu_live.gnucash` or `gnu_paper.gnucash`

-----------------------------------------
Strategy: strategy_mid.py – VWAP Mean Reversion
-----------------------------------------

- Time Window:
  - Starts at `START_TIME_MID`
  - Signals evaluated after `MID_ANALYSIS_TIME`
  - Trades monitored for `MID_MONITORING_TIME`
- Trade Direction: Long or Bearish (via inverse ETF or put)
- Entry Logic:
  - Entry when price deviates from VWAP by `STRAT_MID_VWAP_THRESHOLD`
  - Candlestick or reversal signal must confirm
  - Filters may block trades if conditions not met (ADX, etc.)
- Exit Logic:
  - VWAP reversion
  - Stop-loss at 1.5%
  - Max duration: 45 minutes (via monitoring timer)
- Shorting:
  - Based on `SHORT_TYPE_MID` (InverseETF, LongPut, ShortSell, or disabled)
- Enhancements:
  - `adx_filter.py` (skip trades if ADX > 25)
  - `bollinger_confluence.py` (require 2 std dev confluence)
- Logging:
  - `mid_live.log` or `mid_paper.log`
  - `trade_history_*.csv` and `*.json`
  - GnuCash XML export via `gnu_exporter.py`

-----------------------------------------
Strategy: strategy_close.py – EOD Momentum / Fade
-----------------------------------------

- Time Window:
  - Starts at `START_TIME_CLOSE`
  - Uses `CLOSE_ANALYSIS_TIME` for signal evaluation
  - Trades monitored for `CLOSE_MONITORING_TIME`
- Trade Direction: Long or Bearish
- Entry Logic:
  - Continuation (momentum) if aligned with session trend
  - Fade if large reversal signal appears late day
  - VIX-based filter applies: skip if VIX < `STRAT_CLOSE_VIX_THRESHOLD`
- Exit Logic:
  - Stop-loss at 2%
  - Hard exit 5 minutes before market close
- Shorting:
  - Based on `SHORT_TYPE_CLOSE` (LongPut, InverseETF, etc.)
- Enhancements:
  - `vix_gatekeeper.py`, `imbalance_scanner_ibkr.py`, `ticker_blocklist.py`
- Logging:
  - `close_live.log` or `close_paper.log`
  - `gnu_*.gnucash`, `trade_history_*.json`, daily summaries

Strategy Failover:
- If any strategy fails `.self_check()`, it will not run and an error will be logged
- Override logic in `.env_bot` can be used to run only one strategy:
  - Example: `STRATEGY_OVERRIDE=mid`

==============================
Runtime Modes
==============================

TBot supports two execution modes, controlled via the `TEST_MODE` flag in `.env_bot`. These modes share the same strategy logic but differ in how trades are routed, logs are written, and filters are enforced.

A third override behavior exists via `FORCE_PAPER_EXPORT=true`, which forces **all trade outputs** (including live trades) to write to `_paper` logs and paper-mode accounting ledgers, regardless of `TEST_MODE`.

-----------------------------------------
TEST_MODE=true
-----------------------------------------

Purpose:
- Used to validate broker connectivity, logging, and accounting exports via real paper APIs without risking capital.

Behavior:
- Trades routed through paper APIs:
  - `ALPACA_MODE=paper`
  - `IBKR_MODE=paper`
- Runtime durations are shortened for validation:
  - `OPEN_ANALYSIS_TIME=1`
  - `OPEN_MONITORING_TIME=1`
  - Same for mid and close strategies
- Filters disabled:
  - Volume, spread, volatility ignored
- Outputs:
  - `open_paper.log`, `mid_paper.log`, `close_paper.log`
  - `trade_history_paper.csv`, `trade_history_paper.json`
  - `daily_summary_paper.json`
  - `tbot_Paper_Ledger.manager`
- Logging and exports activated only if:
  - `ENABLE_LOGGING=true`
  - `ACCOUNTING_EXPORT_MODE=auto`

Restrictions:
- Must **never** write to:
  - `tbot_Live_Ledger.manager`
  - Any `_live` logs, even accidentally

-----------------------------------------
TEST_MODE=false
-----------------------------------------

Purpose:
- Full production mode with capital exposure and complete risk systems enabled.

Behavior:
- Trades routed through live APIs:
  - `ALPACA_MODE=live`
  - `IBKR_MODE=live`
- Runtime durations and filters fully enforced:
  - `*_ANALYSIS_TIME`, `*_MONITORING_TIME`
  - Volume, slippage, spread limits enforced
- Outputs:
  - `open_live.log`, `mid_live.log`, `close_live.log`
  - `trade_history_live.csv`, `trade_history_live.json`
  - `daily_summary_live.json`
  - `tbot_Live_Ledger.manager`
- Logging and export behavior same as TEST_MODE, gated by:
  - `ENABLE_LOGGING=true`
  - `ACCOUNTING_EXPORT_MODE=auto`

-----------------------------------------
FORCE_PAPER_EXPORT=true
-----------------------------------------

Purpose:
- Routes all logs and ledger exports to paper-mode outputs, even in live mode.
- Useful for testing new strategy logic or broker APIs in production without corrupting official books.

Behavior:
- Does **not** affect which broker is used for trade routing
  - You may still place real trades (e.g., `IBKR_MODE=live`)
- But:
  - All `.log`, `.csv`, `.json` files are saved as `_paper`
  - `tbot_Paper_Ledger.manager` is written instead of `tbot_Live_Ledger.manager`
- Overrides TEST_MODE during export
- Strategy logs and accounting exports still require:
  - `ENABLE_LOGGING=true`
  - `ACCOUNTING_EXPORT_MODE=auto`

Example:
If `TEST_MODE=false` but `FORCE_PAPER_EXPORT=true`:
- Real trades are executed via live broker
- But logs and accounting data are routed to paper output files for isolation

This setting is ideal for confirming behavior on production accounts without writing to official accounting ledgers.


==============================
Capital Risk Controls
==============================

All capital risk controls are defined in `.env_bot` and enforced in real-time by `risk_bot.py`, `kill_switch.py`, and strategy logic.

Each position is evaluated before entry and monitored continuously through its lifecycle. These controls are independent of the strategy used.

-----------------------------------------
MAX_RISK_PER_TRADE
-----------------------------------------
Variable: `MAX_RISK_PER_TRADE`
- Defines the maximum allowable risk for a single trade, expressed as a fraction of total capital.
- Example: 0.025 means 2.5% maximum risk per position.
- Exceeding this threshold prevents order placement.

-----------------------------------------
MAX_OPEN_POSITIONS
-----------------------------------------
Variable: `MAX_OPEN_POSITIONS`
- Caps the total number of positions that may remain open concurrently across all strategies.
- Prevents portfolio overexposure or capital lock-up during high signal frequency.

-----------------------------------------
TOTAL_ALLOCATION
-----------------------------------------
Variable: `TOTAL_ALLOCATION`
- Represents the total fraction of capital allowed to be deployed across all trades in a single strategy session.
- This value is redistributed dynamically based on the number of trades triggered, using the `WEIGHTS` variable.

-----------------------------------------
MAX_TRADES + WEIGHTS
-----------------------------------------
Variables: `MAX_TRADES`, `WEIGHTS`
- Defines how TOTAL_ALLOCATION is split among trades if multiple signals trigger.
- `WEIGHTS` must contain the same number of values as `MAX_TRADES`.
- Example: If `MAX_TRADES=4` and `WEIGHTS=0.4,0.2,0.2,0.2`:
  - 1 signal → 100% of TOTAL_ALLOCATION
  - 2 signals → 60% / 40%
  - 3 signals → 40% / 30% / 30%
  - 4 signals → 40% / 20% / 20% / 20%

-----------------------------------------
DAILY_LOSS_LIMIT
-----------------------------------------
Variable: `DAILY_LOSS_LIMIT`
- If cumulative realized losses exceed this percentage of total capital, trading halts automatically.
- `kill_switch.py` is triggered and prevents further orders.
- Live sessions will terminate or lock until the following day.

-----------------------------------------
Enforcement Modules
-----------------------------------------
- `risk_bot.py`: Prevents oversize trades or violations of any above settings
- `kill_switch.py`: Monitors realized PnL and triggers shutdown when `DAILY_LOSS_LIMIT` is breached
- `watchdog_bot.py`: Will also disable execution if API or order latency crosses thresholds

All risk controls apply equally to TEST_MODE and LIVE MODE; the only difference is whether trades are simulated (`paper`) or executed (`live`).

==============================
Strategy Modules (Unified Format)
==============================

Each strategy module operates independently and is triggered according to its `START_TIME_*` value in `.env_bot`.

All time values are UTC.

Strategy behavior, allocation logic, enhancements, and shorting rules are modular, toggleable, and fully configurable using `.env_bot` variables.

Each strategy is only executed if its corresponding master toggle is enabled:

- `STRAT_OPEN_ENABLED=true`
- `STRAT_MID_ENABLED=true`
- `STRAT_CLOSE_ENABLED=true`

If any of these are set to false, the strategy will be skipped automatically by `strategy_router.py` before initialization.

-----------------------------------------
strategy_open.py – Opening Range Breakout
-----------------------------------------

START_TIME_OPEN: 14:30 UTC (9:30 AM EST)  
ANALYSIS WINDOW: `OPEN_ANALYSIS_TIME`  
MONITORING WINDOW: `OPEN_MONITORING_TIME`  
SHORTING: Disabled (`SHORT_TYPE_OPEN=disabled`)  
ENABLED: Controlled by `STRAT_OPEN_ENABLED`

- Tracks price range for first `OPEN_ANALYSIS_TIME` minutes after market opens.
- If price breaks above high (or below low) by more than `STRAT_OPEN_BUFFER`, triggers a trade.
- Volume check required (skipped in TEST_MODE).
- Direction: Long only
- Instrument: Stock or ETF
- Enhancements: None (core breakout logic only)
- Exit: 2% stop loss or end of `OPEN_MONITORING_TIME`

LOG OUTPUT:
- `open_live.log` / `open_paper.log`
- GnuCash: `gnu_live.gnucash` or `gnu_paper.gnucash`
- Trade History: `trade_history_*.csv/json`

-----------------------------------------
strategy_mid.py – VWAP Mean Reversion
-----------------------------------------

START_TIME_MID: 15:30 UTC (10:30 AM EST)  
ANALYSIS WINDOW: `MID_ANALYSIS_TIME`  
MONITORING WINDOW: `MID_MONITORING_TIME`  
SHORTING: Allowed if `SHORT_TYPE_MID` = `InverseETF`  
ENABLED: Controlled by `STRAT_MID_ENABLED`

- Tracks price deviation from VWAP of ±`STRAT_MID_VWAP_THRESHOLD`.
- Identifies reversal signals (candlestick or momentum).
- Optional enhancements:
  - `adx_filter.py`: Skip trades when ADX > 25 (strong trend)
  - `bollinger_confluence.py`: Require Bollinger touch confirmation
- Direction: Long or bearish (via inverse ETF only)
- Instrument: Stock or Inverse ETF
- Exit: VWAP touch, timeout, or 1.5% stop loss

LOG OUTPUT:
- `mid_live.log` / `mid_paper.log`
- GnuCash: `gnu_live.gnucash` or `gnu_paper.gnucash`
- Trade History: `trade_history_*.csv/json`

-----------------------------------------
strategy_close.py – End-of-Day Momentum/Fade
-----------------------------------------

START_TIME_CLOSE: 19:30 UTC (2:30 PM EST)  
ANALYSIS WINDOW: `CLOSE_ANALYSIS_TIME`  
MONITORING WINDOW: `CLOSE_MONITORING_TIME`  
SHORTING: Allowed if `SHORT_TYPE_CLOSE` = `LongPut` or `InverseETF`  
ENABLED: Controlled by `STRAT_CLOSE_ENABLED`

- Determines whether to follow momentum or fade signal based on market context.
  - Momentum: Continue trend
  - Fade: Reverse late-day spike
- Requires VIX filter (`STRAT_CLOSE_VIX_THRESHOLD`) for entry
- Optional enhancements:
  - `imbalance_scanner_ibkr.py`: Reads IBKR imbalance feed (if broker = ibkr)
  - `ticker_blocklist.py`: Prevents duplicate trades on same symbol
  - `vix_gatekeeper.py`: Skips strategy if VIX < threshold
- Direction: Long or bearish (via long puts or inverse ETFs)
- Exit: 2% stop loss or end of `CLOSE_MONITORING_TIME`

LOG OUTPUT:
- `close_live.log` / `close_paper.log`
- GnuCash: `gnu_live.gnucash` or `gnu_paper.gnucash`
- Trade History: `trade_history_*.csv/json`

Strategy Failover:
- If any strategy fails `.self_check()`, it will not run and an error will be logged
- Override logic in `.env_bot` can be used to run only one strategy:
  - Example: `STRATEGY_OVERRIDE=mid`





==============================
Strategy Allocation Clarification
==============================


Overview:
TradeBot allocates capital dynamically based on the number of valid trade signals returned by each strategy. The logic ensures that total capital exposure respects the configured limits while maximizing potential opportunity.

Total Capital Limit:
- Variable: TOTAL_ALLOCATION
- Example: 0.02 = 2% of total account capital available to that strategy window
- This value is split across multiple trades using WEIGHTS if more than one signal passes the filters

Maximum Trades:
- Variable: MAX_TRADES
- Defines the max number of trades that can be placed during a strategy window (e.g., 4)

Trade Weighting:
- Variable: WEIGHTS
- Format: comma-separated list matching MAX_TRADES
- Example: 0.4,0.2,0.2,0.2 (used if all 4 trades pass filters)

Allocation Behavior:
The bot dynamically adapts capital allocation if fewer trades qualify:

- 1 trade: 100% of TOTAL_ALLOCATION
- 2 trades: 60% / 40%
- 3 trades: 40% / 30% / 30%
- 4 trades: 40% / 20% / 20% / 20% (default weights)

This ensures that high-confidence signals receive more capital, and weak or borderline signals are deprioritized or skipped.

Implementation:
- Logic handled inside `risk_bot.py` and `reporting_bot.py`
- Trade size is determined using available buying power and selected weight
- All allocations respect MAX_OPEN_POSITIONS and FRACTIONAL settings

Edge Case Handling:
- If fewer than expected trades pass all filters, unallocated capital is held in reserve
- Trade weight list is truncated dynamically to match number of qualifying entries
- If weights are misconfigured or total > 1.0, `env_bot.py` will raise a validation error

Best Practice:
Use realistic weights and limit MAX_TRADES based on broker rules and personal risk tolerance



- Fails early if critical files are missing or invalid.


==============================
Logging & Reporting Format
==============================

TBot writes structured output files during every session for audits, dashboards, and accounting exports. Output is routed to either `_live` or `_paper` variants based on `TEST_MODE`.

Log Mode Switching
------------------------------
Variable: TEST_MODE (from .env_bot)
- true  → writes to `_paper` logs and ledgers
- false → writes to `_live` logs and ledgers

Variable: LOG_FORMAT (from .env_bot)
- csv   → human-readable logs
- json  → structured logs (for dashboards, parsing, etc.)

Primary Log Files
------------------------------
All strategy and trade logs follow this naming structure:

  open_live.log / open_paper.log              # Strategy: Opening Range Breakout  
  mid_live.log / mid_paper.log                # Strategy: VWAP Mean Reversion  
  close_live.log / close_paper.log            # Strategy: End-of-Day Fade/Momentum  

  trade_history_live.csv / trade_history_paper.csv  
  trade_history_live.json / trade_history_paper.json  

  unresolved_orders_live.log / unresolved_orders_paper.log  
  daily_summary_live.json / daily_summary_paper.json  

All logs are staged into:
- `output/logs/`          → strategy, error, and unresolved order logs
- `output/trades/`        → trade history per session
- `output/summaries/`     → final session summaries (PnL, stats)

Rotated and timestamped logs are archived into `/backups/` via `auto_backup.py`.

Required Fields in trade_history_*.json (if LOG_FORMAT=json)
------------------------------
- timestamp          → ISO 8601 UTC  
- strategy_name      → open, mid, or close  
- ticker             → stock or ETF symbol  
- side               → long or short  
- size               → shares/contracts  
- entry_price        → float  
- exit_price         → float  
- PnL                → profit or loss  
- broker             → e.g., alpaca, ibkr  
- mode               → paper or live  
- error_code         → present only if rejected, partial, or failed  

Log File Notes
------------------------------
- Logs are never re-imported into the ledger; they are a parallel audit trail.  
- `unresolved_orders_*.log` captures broker-level failures, delays, or partial fills.  
- `daily_summary_*.json` includes:
  - trade counts  
  - win/loss ratio  
  - PnL totals  
  - execution speed  
  - most/least profitable symbols  
  - triggered strategies

Ledger Routing
------------------------------
All ledger output is routed by:

- `TEST_MODE`                  → routes to live or paper ledger
- `FORCE_PAPER_EXPORT=true`   → overrides to paper ledger (even for live trades)
- `ACCOUNTING_EXPORT_MODE=auto` → enables export after trades

Ledger Output Files:
- `TEST_MODE=true`  
  → `output/ledgers/tbot_Paper_Ledger.manager`  
- `TEST_MODE=false`  
  → `output/ledgers/tbot_Live_Ledger.manager`  

Export Flow:
1. `reporting_bot.py` collects trade data  
2. `accounting_api.py` routes to correct backend (currently: Manager.io)  
3. `manager_exporter.py` generates entries  
4. `accounting_config.py` manages export format, path, and mode  
5. `auto_backup.py` archives ledger file after session

Use Cases
------------------------------
- Auditing and compliance snapshots  
- Session summaries for internal dashboards  
- Matching live vs. test-mode performance  
- Confirming strategy execution integrity


==============================
Ledger Architecture
==============================

The following ledger structure applies to all Manager-compatible exports written by `manager_exporter.py`. It supports full double-entry audit trails and syncs with your corporate chart of accounts.

=============================================
tbot_Live_Ledger.manager – Real Trades Ledger
=============================================

Assets
├── Bank Accounts
│   ├── Float Injection – From RIGD Group
│   └── Float Returned – To RIGD Group
├── Broker Accounts (Live)
│   ├── Alpaca – Cash
│   ├── Alpaca – Equities
│   ├── IBKR – Cash
│   └── IBKR – Equities

Income
├── Realized Gains – Alpaca
├── Realized Gains – IBKR

Expenses
├── Broker Fees – Alpaca
├── Broker Fees – IBKR
├── Slippage / Execution Losses
├── API Timeout Penalties
├── Bot Infrastructure Costs

Equity
├── Capital Float Ledger
├── Daily Float Allocation History
├── Opening Balance

Metadata / Logging
├── Trade UUID
├── Broker Confirm #
├── Strategy Tag
├── Source Method Tag
├── EOD Synced Flag
├── Reconciliation Passed Flag

System Integrity
├── Failures & Rejected Orders
├── Manual Overrides
├── Ledger Lock State (true/false)
├── Ledger Status: ACTIVE / DECOMMISSIONED
├── Final Entry Timestamp
├── Debug/Strategy Tags

Exports
├── Daily P&L → Summary Report
├── JSON/CSV for Audit Archive
├── SQLite Ledger Dump
├── Broker Confirm Archive (PDFs)
└── EOD Position Snapshot

=============================================
tbot_Paper_Ledger.manager – Simulated Trades Ledger
=============================================

Assets
├── Simulated Cash – Alpaca
├── Simulated Cash – IBKR

Income
├── Simulated Gains – Alpaca
├── Simulated Gains – IBKR

Expenses
├── Simulated Broker Fees
├── Simulated Slippage Losses
├── Simulated Platform Access Charges

Equity
├── Simulated Capital Float
├── Reset Marker (Backtest Start Point)
├── Opening Equity for Scenario

Audit / Logging
├── UUID Tags for Simulated Trades
├── Strategy Variant Tags
├── API Failures (Simulated)
├── Trade Log Snapshots
├── Manual Test Notes
├── Ledger Lock State
├── Ledger Status
├── Final Entry Timestamp
└── Comparison to Live Ledger (optional)

Exports
├── P&L Export (CSV)
├── SQLite Dump
├── Match Table vs. Live Ledger
├── Execution Integrity Report
└── Sim Snapshot Archive (Broker API Emulation)

Export Rules
------------------------------
- `FORCE_PAPER_EXPORT=true` overrides all routing to paper ledger  
- No `.csv` or `.json` logs are parsed into the ledger  
- Only active session memory and validated trade data are exported  
- All exports are timestamped and archived on session end  
- Exports will **fail fast** if structure or lock-state errors are detected  

==============================
Enhancement Module Activation
==============================

Overview:
TradeBot includes modular enhancements that can refine signal quality, block trades under poor conditions, or perform startup diagnostics. These are located in `/tbot_bot/enhancements/` and operate as plug-ins—each designed to activate automatically based on strategy context or `.env_bot` configuration.

All enhancements are:
- Independently testable
- Compatible with both TEST_MODE and live mode
- Invoked automatically from `strategy_router.py` or within individual strategy files

Behavior & Integration:
- Each enhancement returns a simple boolean (`True` = allow trade, `False` = block trade)
- If any enhancement fails (e.g., due to missing data), the strategy logs a warning and proceeds with core logic—unless a fatal error is raised



Enhancement Modules
------------------------------

1. adx_filter.py – Trend Strength Filter
----------------------------------------
Purpose:
- Blocks mean reversion trades when ADX > 25 (indicating a strong trend)

Applies to:
- strategy_mid.py

Trigger:
- Always-on (future toggle: `ADX_FILTER_ENABLED=true` in `.env_bot`)

Notes:
- Skips VWAP entries during trending markets

2. bollinger_confluence.py – Volatility Confirmation
-----------------------------------------------------
Purpose:
- Requires price to touch or exceed ±2 standard deviations on Bollinger Bands

Applies to:
- strategy_mid.py

Trigger:
- Inline call in strategy_mid.py; may be toggleable in future builds

Notes:
- Reduces false positives in flat or low-volatility conditions

3. vix_gatekeeper.py – Volatility Threshold Lockout
----------------------------------------------------
Purpose:
- Prevents trades if VIX is below configured minimum

Applies to:
- strategy_close.py

Trigger:
- Compares real-time VIX against `STRAT_CLOSE_VIX_THRESHOLD` in `.env_bot`

Notes:
- Helps avoid EOD trades during complacent market conditions

4. imbalance_scanner_ibkr.py – Order Book Pressure Monitor
-----------------------------------------------------------
Purpose:
- Reads Interactive Brokers imbalance data between 20:30–21:00 UTC

Applies to:
- strategy_close.py

Trigger:
- Active only when `BROKER=ibkr`

Notes:
- Blocks late-day trades if strong opposing imbalance is detected (IBKR market data subscription required)

5. ticker_blocklist.py – One Trade Per Ticker Per Day
------------------------------------------------------
Purpose:
- Prevents repeat trades on the same ticker during a single session

Applies to:
- All strategies

Trigger:
- Always-on (no toggle)

Notes:
- Tracks traded symbols in memory or temp file

6. build_check.py – Pre-Launch System Verifier
----------------------------------------------
Purpose:
- Verifies all required files, paths, and variables before runtime

Applies to:
- Called once at startup by `main_bot.py` or via CLI

Checks:
- Presence of `.env`, `.env_bot`, `.gnucash` files
- Writable paths and initialized log files
- Placeholder outputs for first run

Fail Behavior:
- Halts the bot if any check fails

Best Practices:
---------------
- Keep all enhancements decoupled from strategy core logic
- Add toggles in `.env_bot` only if dynamic enable/disable behavior is needed
- Use enhancements to prevent poor trades, not as signal generators







==============================
Safety Systems
==============================

Overview:
TradeBot includes multiple layered safety systems to prevent losses, mitigate risk, and ensure fault-tolerant behavior. These systems are enforced regardless of TEST_MODE or broker configuration.

Modules:

1. kill_switch.py
   - Automatically halts the bot if cumulative daily losses exceed the `DAILY_LOSS_LIMIT` specified in `.env_bot`
   - Shuts down all strategy modules and logs the trigger event
   - Prevents further trades until the next session

2. watchdog_bot.py
   - Monitors API availability and response times for:
     - Broker (ALPACA_MODE or IBKR_MODE)
     - Market data (Finnhub)
   - If any API becomes unreachable or unresponsive:
     - Logs the failure
     - Cancels open orders
     - Gracefully shuts down the bot

3. risk_bot.py
   - Evaluates every proposed trade against the following constraints:
     - `MAX_RISK_PER_TRADE`
     - `TOTAL_ALLOCATION`
     - `MAX_OPEN_POSITIONS`
   - If any rule is violated, the trade is blocked and the reason is logged

4. error_handler.py
   - Global exception manager
   - Categorizes errors into:
     - NetworkError
     - BrokerError
     - LogicError
     - ConfigError
   - Logs full traceback and metadata to:
     - `unresolved_orders_live.log` or `unresolved_orders_paper.log`
   - For critical errors:
     - Sends alert via `notifier_bot.py`
     - May trigger kill_switch if severity exceeds threshold

5. security_bot.py
   - Manages encryption and secure storage of `.env_bot`
   - Only decrypts the environment file if valid `ENCRYPTION_KEY` is provided in the root `.env`
   - Prevents use of plaintext trading credentials in production

Hard Shutdown Behavior:
- If any of the above modules raise a fatal error or threshold is breached:
  - Open trades are exited if possible
  - The bot writes a final `daily_summary_*.json` log
  - Email or Slack alert is sent (if enabled)

All safety modules must pass their respective `self_check()` validations before strategy execution begins. Failing any check will prevent trading activity.



==============================
Secure Environment Variables
==============================

Overview:
TradeBot separates its runtime configuration into two environment files:
- `.env` contains broker credentials, API keys, encryption keys, and SMTP credentials.
- `.env_bot` defines trading logic, timing, strategy settings, and risk controls.

Security Goals:
- Never expose `.env_bot` contents in plaintext on shared systems.
- Ensure only validated and decrypted variables are loaded during runtime.
- Allow encrypted deployment on remote servers (e.g., DigitalOcean) without exposing raw configuration.

Encryption System:
- `.env_bot` is encrypted using AES-256 via the `cryptography` module.
- The encrypted version is saved as `.env_bot.enc`.
- The decryption key is defined in the global `.env` file under:
  ENCRYPTION_KEY="your-256-bit-key"

Required Files:
- `security_bot.py`: Handles encryption and decryption of the `.env_bot` file.
- `generate_key.py`: One-time use script to generate a strong AES-256 key.
- `encrypt_password.py`: CLI tool to encrypt login credentials for the web interface.

Encryption Workflow:
1. Create a plaintext `.env_bot` file and populate it with all required variables.
2. Run `security_bot.py encrypt` to generate `.env_bot.enc`.
3. Store the `ENCRYPTION_KEY` securely inside `.env` (never commit to GitHub or version control).
4. During runtime, `env_bot.py` will:
   - Load and decrypt `.env_bot.enc` using the key from `.env`
   - Validate all keys and raise readable errors if any are missing or malformed

Manual Encryption Example:
  python tbot_bot/security_bot.py encrypt

Manual Decryption Example (for debugging):
  python tbot_bot/security_bot.py decrypt

Security Notes:
- Never include `.env_bot` or `.env_bot.enc` in version control or build packages.
- Use `.scpignore` and `.gitignore` to exclude these files.
- Encrypted files should only be decrypted in memory or on secure systems.

Best Practices:
- Always test decryption and validation on a staging environment before deploying to production.
- Rotate keys if deployment environments or personnel change.
- Log failed decryptions or missing variables to `unresolved_orders_*.log`.

Recovery:
If `.env_bot.enc` becomes corrupted or the encryption key is lost:
- Use the latest `.env_bot` backup from the `/backups/` folder
- Re-encrypt using `security_bot.py`





==============================
Centralized Error Management
==============================

Overview:
TradeBot uses a centralized error handling system to monitor and manage failures during runtime across all modules. The `error_handler.py` module ensures that critical issues are logged, reported, and escalated appropriately — preventing silent failures or inconsistent state.

Module: `tbot_bot/error_handler.py`

Capabilities:
- Captures and categorizes exceptions from:
  - Strategy modules (e.g. logic errors, data type mismatches)
  - Broker interface modules (`broker_api.py`, `broker_ibkr.py`, etc.)
  - Utility and infrastructure modules (`reporting_bot.py`, `risk_bot.py`, etc.)

- Error Classification:
  - `NetworkError`: API connectivity issues, timeouts, DNS failures
  - `BrokerError`: Order rejection, margin issues, invalid asset classes
  - `LogicError`: Runtime logic issues or invalid config values
  - `ConfigError`: Missing keys or improperly formatted values in `.env_bot`

- Logging Behavior:
  - All errors are written in structured format to:
    - `unresolved_orders_live.log` or `unresolved_orders_paper.log` (based on `TEST_MODE`)
    - Format: JSON or CSV depending on `LOG_FORMAT`
  - Fields:
    - `timestamp`
    - `strategy_name`
    - `broker`
    - `error_type`
    - `error_code` (optional)
    - `raw_exception` (full stack trace, truncated to prevent log overflow)

- Retry & Fallback:
  - Implements exponential backoff retry logic for transient failures (e.g. temporary API downtime)
  - If retry fails after `API_RETRY_LIMIT`, error is escalated and logged

- Notification System:
  - For critical errors or unresolved rejections, triggers alert via `notifier_bot.py`
  - Alerts include timestamp, error summary, strategy context, and broker info
  - Alert channels defined via SMTP settings in `.env`

- Kill Switch Integration:
  - On detection of unrecoverable error conditions:
    - Invokes `kill_switch.py` to halt further trades
    - Ensures clean shutdown and logs the shutdown reason to `logs_bot.py`

- Optional Integration:
  - Can be linked to `status_web.py` and `logs_web.py` to show error status via dashboard
  - Failsafe behavior should never rely on frontend modules — operates fully headless

Usage Notes:
- Must be imported and initialized in `main_bot.py` and reused across all critical modules
- When possible, all exceptions should be wrapped and passed to `error_handler.handle()` with appropriate classification tags
- Ensures maximum transparency and auditability of all failed or skipped trades


==============================
Backtesting Framework
==============================

Overview:
To ensure robustness and validate strategy logic before deployment, TradeBot includes a complete historical backtesting engine. This framework simulates trades using historical data and provides actionable performance metrics.

Module:
- backtest_engine.py

Features:
- Simulates historical trades using the same strategy logic found in:
  - strategy_open.py
  - strategy_mid.py
  - strategy_close.py
- Loads minute-level OHLCV data via load_historical_data.py
- Bypasses live broker APIs; trades are simulated internally
- Compatible with both CSV and JSON output formats
- Results are stored in a subfolder such as backtest_results/
- Reuses all logic and environment variables from .env_bot

Performance Metrics (via performance_metrics.py):
- Win Rate (%)
- Maximum Drawdown
- Average Trade Duration
- Average PnL per trade
- Sharpe Ratio

Charts & Reports:
- Visualize equity curve, drawdown, and entry/exit points using plot_results.py

Command-Line Interface:
Run from the root of tbot_bot/ using:
python backtest/backtest_engine.py --strategy=open --start=2023-01-01 --end=2023-12-31 --data_source=./historical_data/open_ohlcv.csv

Runtime Configuration:
- All parameters (allocation, thresholds, filters) are pulled from .env_bot
- TEST_MODE logic is automatically assumed (no real trades)
- Filters (e.g., volume, price) may be toggled manually for analysis

Supported Strategies:
- open, mid, close — must be listed in STRATEGY_SEQUENCE
- Each strategy must support a .simulate() method or equivalent backtest logic

Ledger Output:
- Trade logs generated during backtests will be written to:
  - trade_history_backtest.csv
  - trade_history_backtest.json
  - daily_summary_backtest.json
- These do not modify live or paper GnuCash ledgers
- GnuCash XML export is not used during backtesting

Logging Format:
All simulated trade logs follow the same structure as live/paper runs:
- timestamp
- strategy_name
- ticker, side, size
- entry_price, exit_price, PnL
- mode=backtest

Notes:
- The backtest engine is sandboxed and stateless.
- It is a required step before any live trading session begins for a new strategy.
- Does not depend on tbot_api/ or tbot_web/.




==============================
Testing and Validation Suite
==============================

Overview:
A robust testing framework ensures that all TradeBot logic executes as expected across strategies, environments, and runtime modes. The following tools, test files, and logic gates are implemented to support validation prior to any live deployment.

Testing Directory Structure:
Located in: `tbot_bot/tests/`

Files:
- `test_main_bot.py` – Verifies lifecycle loop, strategy routing, and logger integrity.
- `test_env_bot.py` – Confirms full variable coverage, validation errors, and defaults in `.env_bot`.
- `test_backtest_engine.py` – Runs simulated trades on sample historical data and verifies consistency with execution rules.
- `integration_test_runner.py` – Launches end-to-end simulation of a trading session (TEST_MODE only).

Framework:
- All tests use `pytest` and must be runnable via CLI or CI/CD pipeline.
- Tests are modular and can be run individually or in batches.
- Output formats are compatible with `--junitxml` and CI test reporters.

Example Test Command:
  pytest tbot_bot/tests/

Integration Test Workflow:
1. Loads a simulated `.env_bot` test config
2. Launches `main_bot.py` using `TEST_MODE=true`
3. Injects historical price data using mocks or patched inputs
4. Runs `start_bot.py` in dry-run mode
5. Verifies:
   - Strategy execution order (based on `STRATEGY_SEQUENCE`)
   - Log generation to correct `_paper` files
   - GnuCash export logic (`gnu_exporter.py`)
   - Proper handling of signals, triggers, and errors
6. Asserts trade integrity and structure of all logs and exports

CI Compatibility:
- Compatible with GitHub Actions, GitLab CI, or local test runners.
- All test scripts and outputs are headless (no GUI, web UI, or API calls required).
- Custom `.env_bot.test` config files may be loaded during CI runs with overrides.

Requirements:
- Python 3.11+
- `pytest`, `pydantic`, and all packages listed in `requirements.txt`

Test-Mode Enforcement:
- `integration_test_runner.py` MUST only run with `TEST_MODE=true`
- All trade outputs are written to `*_paper` logs only
- Test failures are captured and printed to stdout/stderr immediately

Version Compliance:
- `test_env_bot.py` must validate that `.env_bot["VERSION_TAG"]` matches `VERSION.md`
- Build is considered invalid if the tags are mismatched

Recommended Additions (Optional):
- `test_gnu_exporter.py`: Verify XML structure, account mappings, and compliance
- `test_logging_format.py`: Validate JSON structure matches schema
- `test_strategy_selfcheck.py`: Confirm `.self_check()` returns `True` across all strategies


==============================
Real-Time Monitoring Dashboard
==============================

Overview:
The web interface provided by `tbot_web/` includes a live dashboard designed to monitor bot operations, active positions, and key runtime metrics. This dashboard operates independently of trading logic and is updated via background tasks and lightweight API polling.

Purpose:
- Provides remote visibility into trading activity and system health
- Allows real-time monitoring without compromising headless operation
- Offers read-only observability and does not affect core strategy execution

Metrics to Display:
- Current active strategy (`strategy_open.py`, `strategy_mid.py`, `strategy_close.py`)
- Scheduled and actual UTC start times from `.env_bot`
- Number of trades signaled, entered, exited
- Real-time P&L (per position and cumulative)
- Active positions (ticker, size, entry price, current price, unrealized PnL)
- Broker connectivity and API status (`watchdog_bot.py`)
- System state: idle, analyzing, trading, shutdown
- API retry count or recent error summary
- Test mode indicator (true/false)

Frontend Components:
- `status.html`: Live strategy state and performance metrics
- `logs.html`: Stream of major log events, alerts, and errors
- `main.html`: Container layout for dashboard navigation
- `index.html`: Login portal (encrypted via `auth.py`)

Backend Modules:
- `status_web.py`: Streams live data from `status_bot.py` to frontend
- `logs_web.py`: Exposes recent log snapshots
- `start_stop_web.py`: Optional lifecycle control from web UI
- `main_web.py`: FastAPI router for web interface
- `login_web.py`: Handles user authentication

Implementation Details:
- Data is updated either via WebSockets or async polling via FastAPI
- Web layer relies on `.env` credentials for login and encrypted session management
- Supports read-only mode for secure deployments (no trading control exposed)

Security:
- Login attempts are rate-limited via SlowAPI
- Failed login attempts are written to `logs/web/auth_failures.log`
- Successful access is logged to `logs/web/access.log`

Important Notes:
- The dashboard is optional and not required for bot functionality
- All logic must remain functional even if `tbot_web` is disabled or unreachable
- Can be monitored from desktop, tablet, or mobile device in low-bandwidth environments


==============================
Final Build Checklist
==============================

This checklist ensures that all components of TBot are production-ready, internally consistent, and compliant with safety, logging, and accounting requirements. Every item must pass validation prior to live deployment.

Configuration
-------------
- `.env` is present, with populated:
  - `ENCRYPTION_KEY`
  - SMTP credentials
  - Local IP and PORT for Flask
  - Login credentials and environment toggles
- `.env_bot` is either decrypted or automatically loaded from `.env_bot.enc`
- All strategy, risk, and logging variables are valid and non-empty
- `VERSION_TAG` inside `.env_bot` matches root `VERSION.md`

Environment Validation
-----------------------
- `env_bot.py` performs full schema validation with required key checks
- Fails fast on missing, malformed, or out-of-range values
- `.env_bot.template-test` is up to date with full variable list and inline comments

Strategy Logic
--------------
- `main.py` loads `STRATEGY_SEQUENCE` and routes to the correct strategy file
- Each strategy (`strategy_open.py`, `strategy_mid.py`, `strategy_close.py`) implements `self_check()` and passes
- Execution rules (volume filter, slippage filter, spread limits) are respected in live mode

Logging System
--------------
- Log files route to either `_live` or `_paper` folders depending on:
  - `TEST_MODE`
  - `FORCE_PAPER_EXPORT`
- All log entries include timestamp, ticker, side, size, prices, strategy, broker, and mode
- Logging path is consistent with:
  - `output/logs/` (active session)
  - `backups/` (archived after session end)
- `LOG_FORMAT` applies globally across all output logs (CSV or JSON)

Accounting Ledger Export (Manager.io-Compatible)
------------------------------------------------
- Trade data is collected by `reporting_bot.py`
- Export dispatches through `accounting_api.py` to `manager_exporter.py`
- Output file:
  - `tbot_Live_Ledger.manager` (live)
  - `tbot_Paper_Ledger.manager` (paper)
- Structure defined by `ledger_schema.py` and validated before write
- Ledger export respects:
  - `TEST_MODE`
  - `FORCE_PAPER_EXPORT`
  - `ACCOUNTING_EXPORT_MODE=auto`
- Backups of exported ledgers stored in `backups/`

Broker Connectivity & Routing
------------------------------
- `broker_api.py` correctly dispatches to:
  - Alpaca (`broker_alpaca.py`)
  - IBKR (`broker_ibkr.py`)
  - Others (Webull, Tastytrade, Robinhood) are inactive
- `ALPACA_MODE` and `IBKR_MODE` control paper/live routing
- `watchdog_bot.py` runs broker connectivity health checks before and during trading

Safety & Shutdown Systems
------------------------------
- `kill_switch.py` halts execution if `DAILY_LOSS_LIMIT` is breached
- `risk_bot.py` prevents trade entry that violates:
  - Allocation limits
  - Position size rules
  - Ticker blacklist
- `error_handler.py` logs uncaught exceptions and optionally triggers alert
- `stop_bot.py` exits all positions and ends session cleanly

Notifications
-------------
- `notifier_bot.py` sends real-time email alerts if:
  - `NOTIFY_ON_FILL=true`
  - `NOTIFY_ON_EXIT=true`
- SMTP is configured in `.env` and validated
- Alerts are disabled in test mode unless explicitly allowed

Testing & Quality Assurance
------------------------------
- Dry-run complete with:
  - `TEST_MODE=true`
  - `FORCE_PAPER_EXPORT=true`
- All `_paper` files were generated and reviewed
- `pytest` passes all unit tests in `tests/`
- `integration_test_runner.py` successfully simulates full lifecycle in test mode

Web Control & Interface
------------------------------
- Flask interface (`tbot_web/`) is running at expected IP/PORT
- Login authentication and AES encryption tested with:
  - `encrypt_password.py`
  - `ENCRYPTED_PASSWORD` + `PASSWORD`
- Web controls (Start/Stop buttons) correctly write to:
  - `control/control_start.txt`
  - `control/control_stop.txt`
- All `/settings`, `/logs`, `/status` routes function correctly and are protected

Deployment Readiness
------------------------------
- All file paths are relative, portable, and Linux/macOS compatible
- Web server and bot logic run in separate processes:
  - Flask is independent of bot lifecycle
- CLI triggers include:
  - `start_bot.py` for direct launch
  - `service_bot.py` for daemon mode
- All sensitive files ignored by `.scpignore_*` rules

Version Control & Deliverables
------------------------------
- Final build printed in Code Blocks (not distributed as ZIP)
- `VERSION.md` documents all changes per version tag
- No test artifacts, temp logs, or passwords committed to repo
- `backups/` and `output/` contents verified for accuracy and isolation




























































