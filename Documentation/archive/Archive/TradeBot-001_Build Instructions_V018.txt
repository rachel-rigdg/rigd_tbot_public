

Paste this into a fresh ChatGPT window to kick off the build:

# -----------------------------------------

Please read and internalize all content in this thread. Acknowledge that you fully understand the Objective, System Instructions, and complete architecture of the system before proceeding. This session is part of an active build process and requires strict adherence to the documented structure and rules.



==============================
Table of Contents – TradeBot Master Build Document
==============================

1. Objective                                   # Defines the bot's purpose, trade types, and execution goals

2. System Instructions                         # Build, testing, and deployment policies for ChatGPT and human use

3. .env – Top-Level Environment File           # Broker credentials, API keys, encryption settings, SMTP config

4. .env_bot – Trading Bot Configuration        # Strategy control, timing, risk settings, broker modes

5. Overall Directory Structure Diagram         # Folder layout and modular file structure for full system

6. Deployment Notes                            # Runtime behavior, environment requirements, and broker validation

7. Current Platforms                           # Development and production system compatibility

8. Time Zone Standards                         # Enforces UTC across strategy, logging, and exports

9. TradeBot Strategy Logic Spec v1.0           # Core strategy design: breakout, mean reversion, close logic

10. Runtime Modes                              # TEST_MODE, LIVE mode, and FORCE_PAPER_EXPORT explained

11. Capital Risk Controls                      # Max position size, allocation, trade weights, and limits

12. Strategy Modules (Unified Format)          # Behavior, toggles, enhancements, and lifecycle per strategy

13. Strategy Allocation Clarification          # Dynamic weighting logic and capital exposure limits

14. Logging & Reporting Format                 # Output files, log format, JSON/CSV routing by mode

15. Ledger Architecture                        # Manager.io-compatible structure and accounting categories

16. Enhancement Module Activation              # Plug-in logic filters (ADX, VIX, Bollinger, Imbalance, etc.)

17. Safety Systems                              # Risk aborts, broker disconnects, error classification

18. Secure Environment Variables                # Encrypted configs, AES keys, decryption process

19. Centralized Error Management                # Structured runtime error capture, classification, and escalation

20. Backtesting Framework                       # Historical replay engine, metrics, and test-mode simulation

21. Testing and Validation Suite                # Unit, integration, and CI-ready testing structure

22. Real-Time Monitoring Dashboard              # Flask-based read-only UI for monitoring and control

23. Final Build Checklist                       # Pre-deployment verification for safe execution



==============================
Objective
==============================

TradeBot automatically identifies securities in a bi-directional manner and places trades using:

- Long equity positions when bullish criteria are met.
-  inverse ETFs or long put when bearish signals are triggered.

Supported brokers must allow:
- Long equity trading
- Long puts or inverse ETFs (based on SHORT_TYPE_* per strategy in .env_bot)
- Paper trading API access (when TEST_MODE=true or FORCE_PAPER_EXPORT=true)

TradeBot is designed to run in real-time using intraday strategies and must support:
- Fully automated execution and dynamic position sizing
- Headless operation without requiring a web interface or API server
- Live risk enforcement via .env_bot controls (DAILY_LOSS_LIMIT, MAX_RISK_PER_TRADE, etc.)
- Audit-ready reporting via the dedicated accounting system’s OFX-compliant ledger exports (replacing Manager.io)
- Independent operation of all modules (tbot_bot/, tbot_api/, tbot_web/)

All trade execution, logging, and ledger export functions must be self-contained and operational without external triggers or user input.

Execution, broker access, and strategy activation are governed independently using:
- ALPACA_ENABLED, IBKR_ENABLED, etc.
- STRAT_OPEN_ENABLED, STRAT_MID_ENABLED, STRAT_CLOSE_ENABLED
- FORCE_PAPER_EXPORT overrides live exports even when TEST_MODE=false

Ledger interactions:
- All trade activities must post directly to the accounting system’s entity-specific SQLite ledgers (no in-memory or temporary log-only structures).
- Both paper and live trading modes must write to separate but identically structured ledgers to allow parallel testing and reconciliation.
- OFX export compliance, cross-entity float tracking, and immutable audit logs are enforced per the accounting system design.



==============================
System Instructions (Active Debugging Phase)
==============================

1. All files must be printed as single complete Code Blocks in the chat.
   - Do not use ZIPs, summaries, or partial output.
   - Each Code Block must be labeled with the filename as a comment at the top (e.g., # tbot_bot/trading/orders_bot.py).

2. All environment-specific values must reference variables from .env, .env_bot, or .env_bot.enc.
   - Do not hardcode API keys, thresholds, toggles, or paths.
   - Suggest new variables only if required, and document them clearly.

3. Debugging & Testing Behavior:
   - Perform only one action or file generation at a time.
   - Wait for explicit user confirmation (e.g., "continue", "go", "next") before proceeding.
   - Do not assume next steps or combine tasks.

4. All code must include inline comments that:
   - Explain logic and purpose
   - Reference relevant .env_bot settings or runtime flags
   - Clarify conditional paths or fallback behavior

5. All code output must be complete and executable.
   - Regenerate entire files — do not use patches or diffs unless explicitly allowed.
   - Never insert placeholders or mock logic unless explicitly instructed.

6. All file paths must be relative and portable.
   - No absolute paths or platform-specific logic.
   - All code must run on macOS, Linux, and production servers without modification.

7. When TEST_MODE=true:
   - Use broker paper trading APIs only.
   - Write all logs and ledger exports to _paper files.
   - Skip volume, spread, and slippage filters (unless overridden).
   - Never write to _live files or ledgers.

8. When FORCE_PAPER_EXPORT=true:
   - All output (logs, trades, ledger) is routed to _paper files, regardless of broker or TEST_MODE.
   - Broker API routing still respects ALPACA_MODE, IBKR_MODE.

9. Ledger Export Behavior:
   - All trade and ledger activity must write directly to the accounting system’s dedicated entity-specific SQLite3 ledgers (e.g., entities/TBL_live.db for live, entities/TBL_paper.db for paper).
   - When TEST_MODE=false AND FORCE_PAPER_EXPORT=false:
     - Write only to the live ledger (entities/TBL_live.db).
   - When TEST_MODE=true OR FORCE_PAPER_EXPORT=true:
     - Write only to the paper/simulated ledger (entities/TBL_paper.db).
   - All external exports (OFX, CSV, reports) are produced exclusively through the accounting system’s export modules (e.g., /export/generate_ofx.py).
   - TradeBot must not generate or maintain any separate external export files; all formal outputs flow through the accounting system pipeline.


10. Do not re-import .csv or .json trade logs into accounting ledgers.
    - Ledgers are generated in memory from validated trade data only.
    - .csv/.json are for audit, review, or dashboards — not input.

11. All strategy modules must include a .self_check() method.
    - main.py must call .self_check() before executing any strategy.
    - Failure blocks the strategy and logs the failure clearly.

12. TEST_MODE Dry-Run Requirements:
    - Must be completed before:
      - First production deployment.
      - Any change to broker, accounting logic, or core strategy behavior.
    - Confirms:
      - Broker connection.
      - Trade logging.
      - Ledger export.
      - Notifications (if enabled).

13. env_bot.py must validate:
    - All required keys in .env_bot.
    - Halt with a clear, human-readable error if keys are missing or malformed.

14. Log and ledger outputs must include:
    - timestamp, strategy_name, ticker, side, size.
    - entry_price, exit_price, PnL.
    - broker, mode (live/paper).
    - error_code (if applicable).

15. VERSION.md is mandatory and must include:
    - Version tag.
    - Major architecture or logic changes.
    - Behavior differences across releases.

16. No emojis are allowed anywhere in code, comments, output, or documentation.

17. All modules must remain testable and executable independently.
    - tbot_bot/ must not rely on tbot_web/ or any frontend.
    - Flask/web modules may be disabled without affecting core logic.

18. Broker and strategy control must be modular and toggleable via .env_bot:
    - ALPACA_ENABLED, IBKR_ENABLED.
    - STRAT_OPEN_ENABLED, STRAT_MID_ENABLED, STRAT_CLOSE_ENABLED.

19. All final files must be reprinted in full for backup or version locking.
    - This includes every regenerated script, config, and ledger.

20. No assumptions, no shortcuts, no improvisation.
    - If an instruction or config is unclear, request clarification before proceeding.



==============================
.env – Top-Level Environment File
==============================

# .env – Top-Level Environment Configuration
# Handles global system, API, encryption, and notification settings
# This file is parsed by tbot_api/, tbot_bot/, and related utility scripts

ENVIRONMENT="production"         # production or development mode
LOCAL="true"                       # If running in local dev environment
CONTROL_DIR="control"  
ENV_BOT_PATH=".env_bot"


LOCAL_IP="192.168.1.67"                      # Optional: bind to a specific local IP
LOCAL_PORT="6900"                # Port for local web access
REMOTE_IP="164.92.120.154"                     # Optional: external IP 
REMOTE_PORT="6900"              # Port for external access or reverse proxy



USERNAME="RGD"



# Session Timeout
SESSION_TIMEOUT="3000"                     # Default: 3000 seconds (50 minutes)


# API Keys
FINNHUB_API_KEY="cvnh1upr01qq3c7f9ko0cvnh1upr01qq3c7f9kog"

# Alpaca
ALPACA_PAPER_API_KEY="PKL84EVSFADUH51578O6"
ALPACA_PAPER_SECRET_KEY="33j2bpc2tQhwHXgaZf5igC05fyej1EPdP6S3cH6b"
ALPACA_LIVE_API_KEY=""
ALPACA_LIVE_SECRET_KEY=""
ALPACA_PAPER_URL=https://paper-api.alpaca.markets
ALPACA_LIVE_URL=https://api.alpaca.markets

# IBKR
IBKR_PAPER_USERNAME="olthf385"
IBKR_PAPER_ACCOUNT_NUMBER="DUK397802"
IBKR_PAPER_PASSWORD="MyPPassIs5^"
IBKR_LIVE_API_KEY=""
IBKR_LIVE_SECRET_KEY=""

# SMTP
ALERT_EMAIL="tb@tb.rgdnn.com"
SMTP_USER="tb@tb.rgdnn.com"
SMTP_PASS="MyTPassIs5^"
SMTP_HOST="smtp.dreamhost.com"
SMTP_PORT="486"


# Authentication:
ENCRYPTION_KEY="e4bnsgMcLcN3gePi133c0Wrj-WWlQFYsDZn93rYbpPw="
ENCRYPTED_PASSWORD="gAAAAABoA221kjvqGBSXTpIEcvIgbulGO_lfBPd3XDdL1pHzJHwSGHrhMpNPiS-lfWdPiBR7MtYv4v_f1-01sHcC5Xe0-vb6vw=="
PASSWORD="gAAAAABoA221yypvGBBh5rJ7RgB9Ri-a8wtNxzsiIiaSiYbKbLmy2UO6W4dU3uAYEs7TUs8q7FtI4aRY-RlXjBCOpam-9gHObg=="


# Bot Config Encryption
ENV_BOT_KEY="UuGZodtO7Llbbk-8OUvaU3NKF9V24apT_J7GdAk2fTM="



==============================
# .env_bot – Trading Bot Configuration File
==============================
# .env_bot – TradeBot Configuration v1.0.0+
# All strategy logic, broker routing, and runtime behavior are driven by this file.
# Time values are specified in UTC. Comments indicate usage and system impact.

# -----------------------------------------
# General & Debugging
# -----------------------------------------

# Version tag (must match VERSION.md)
VERSION_TAG=v1.0.0

# debug or release – sets internal behavior and logging verbosity
BUILD_MODE=release

# Master kill switch to block all trading activity
DISABLE_ALL_TRADES=false

# Enables paper trading APIs and shortens analysis/monitoring windows
TEST_MODE=true

# Forces all logs/ledgers to paper mode, regardless of TEST_MODE
FORCE_PAPER_EXPORT=false

# Logging level: quiet, info, or verbose
DEBUG_LOG_LEVEL=verbose

# Enable writing log files to /logs and /backups
ENABLE_LOGGING=true

# json (structured) or csv (flat) log output format
LOG_FORMAT=json

# -----------------------------------------
# Trade Execution & Risk Controls
# -----------------------------------------

# If true, bot will wait for manual confirmation before sending trades
TRADE_CONFIRMATION_REQUIRED=false

# Number of times to retry failed broker API calls      
API_RETRY_LIMIT=3

# how many seconds before timeout 
API_TIMEOUT=30

# Allow fractional shares (broker must support)
FRACTIONAL=true

# Total capital allocated per strategy session (e.g., 2% of account)
TOTAL_ALLOCATION=0.02

# Max number of trades allowed per strategy window
MAX_TRADES=4

# Trade weight percentages based on number of triggered trades
WEIGHTS=0.4,0.2,0.2,0.2

# Absolute loss limit (e.g., 5% of capital); triggers shutdown
DAILY_LOSS_LIMIT=0.05

# Maximum allocation per trade based on account value (2.5%)
MAX_RISK_PER_TRADE=0.025

# Cap on total simultaneous positions across all strategies
MAX_OPEN_POSITIONS=5                   

# -----------------------------------------
# Price & Volume Filters
# -----------------------------------------

# Minimum price allowed per trade
MIN_PRICE=5

# Maximum price allowed per trade
MAX_PRICE=100

# Minimum volume filter (ignored when TEST_MODE=true)
MIN_VOLUME_THRESHOLD=1000000       

    

# -----------------------------------------
# Strategy Routing & Broker Mode
# -----------------------------------------

# Enable Alpaca broker integration
ALPACA_ENABLED=true

# Enable IBKR (Interactive Brokers) integration
IBKR_ENABLED=false

# paper or live – applies only to Alpaca
ALPACA_MODE=paper

# paper or live – applies only to IBKR
IBKR_MODE=paper

# Strategy run order; values: open, mid, close
STRATEGY_SEQUENCE=open,mid,close

# Optional: override normal order and run only one strategy
STRATEGY_OVERRIDE=

# -----------------------------------------
# Global Time & Polling
# -----------------------------------------

# Days allowed for trading (UTC-based control logic)
TRADING_DAYS=mon,tue,wed,thu,fri

# Interval between polling cycles for runtime monitoring
SLEEP_TIME=1s

# -----------------------------------------
# OPEN Strategy Configuration
# -----------------------------------------


# Maximum gap allowed from open to current price (used in screener)
MAX_GAP_PCT_OPEN=0.1

# Minimum and maximum market cap allowed for OPEN strategy candidates
MIN_MARKET_CAP_OPEN=2000000000
MAX_MARKET_CAP_OPEN=10000000000

# Enable or disable OPEN strategy
STRAT_OPEN_ENABLED=true

# UTC start time (market open = 9:30 AM EST)
START_TIME_OPEN=14:30

# Minutes to track high/low range before breakout
OPEN_ANALYSIS_TIME=20

# Minutes to for breakout to happen
OPEN_BREAKOUT_TIME=10

# Minutes to monitor active positions
OPEN_MONITORING_TIME=30

# Breakout threshold above high/low range (e.g., 2%)
STRAT_OPEN_BUFFER=0.02

# Shorting method: disabled, ShortSell, LongPut, InverseETF
SHORT_TYPE_OPEN=LongPut               

# -----------------------------------------
# MID Strategy Configuration (VWAP Reversion)
# -----------------------------------------

# Maximum gap allowed from open to current price (used in screener)
MAX_GAP_PCT_MID=0.1

# Minimum and maximum market cap allowed for MID strategy candidates
MIN_MARKET_CAP_MID=2000000000
MAX_MARKET_CAP_MID=10000000000


# Enable or disable MID strategy
STRAT_MID_ENABLED=true

# UTC start time (10:30 AM EST)
START_TIME_MID=15:30

# Minutes before trade signal is evaluated
MID_ANALYSIS_TIME=10

# Minutes to for breakout to happen
MID_BREAKOUT_TIME=10

# Maximum hold time after entry
MID_MONITORING_TIME=45

# VWAP deviation required to enter trade
STRAT_MID_VWAP_THRESHOLD=0.02

# Shorting method: ShortSell, LongPut, *InverseETF*, or disabled
SHORT_TYPE_MID= InverseETF              

# -----------------------------------------
# CLOSE Strategy Configuration (EOD Momentum/Fade)
# -----------------------------------------

# Maximum gap allowed from open to current price (used in screener)
MAX_GAP_PCT_CLOSE=0.1

# Minimum and maximum market cap allowed for CLOSE strategy candidates
MIN_MARKET_CAP_CLOSE=2000000000
MAX_MARKET_CAP_CLOSE=10000000000


# Enable or disable CLOSE strategy
STRAT_CLOSE_ENABLED=true

# UTC start time (2:30 PM EST)
START_TIME_CLOSE=19:30

# Minutes to detect signal
CLOSE_ANALYSIS_TIME=10

# Minutes to for breakout to happen
CLOSE_BREAKOUT_TIME=10

# Duration to manage position after entry
CLOSE_MONITORING_TIME=30

# Min VIX level required to allow entry
STRAT_CLOSE_VIX_THRESHOLD=15

# Shorting method: ShortSell, *LongPut,* InverseETF, or disabled
SHORT_TYPE_CLOSE= LongPut               

# -----------------------------------------
# Notifications
# -----------------------------------------

# Send email alert on trade entry
NOTIFY_ON_FILL=true

# Send email alert on trade exit
NOTIFY_ON_EXIT=true                    

# -----------------------------------------
# Reporting & Ledger Export
# -----------------------------------------

# auto = export after each trade, off = no export
LEDGER_EXPORT_MODE=auto


# -----------------------------------------
# Defense Mode (Disaster Risk Reduction)
# -----------------------------------------

# Set true if Disaster Protocol triggers; resets to false on recovery
DEFENSE_MODE_ACTIVE=false

# Percentage of normal MAX_CONCURRENT_TRADES allowed (rounded down)
DEFENSE_MODE_TRADE_LIMIT_PCT=66

# Maximum session allocation allowed during Defense Mode (e.g., 1%)
DEFENSE_MODE_TOTAL_ALLOCATION=0.01





====================================
Overall Directory Structure Diagram
====================================

├── TradeBot-001/
│
│   # Core Metadata & Environment Config
│   ├── VERSION.md                       # Version change log for human or GPT reference
│   ├── CHANGELOG.md                     # Technical commit-style change history (optional)
│   ├── README.md                        # Project overview, architecture, and usage instructions
│   ├── requirements.txt                 # Python package dependencies
│
│   ├── .env                             # Global config (Flask port, encryption keys, login)
│   ├── .env_bot                         # Decrypted bot settings (overwritten each run if using encrypted version)
│   ├── .env_bot.template-test           # Example/test-mode config for cloning bots
│   ├── .scpignore_env                   # Excludes only env/config
│   ├── .scpignore_dev                   # Excludes test scripts, logs, debug files
│   ├── .scpignore_enc                   # Used when deploying encrypted-only configs
│   ├── .scpignore_prod_archive          # Used when deploying archive packages (no .env, no .manager, etc.)
│
│   # Encryption / Auth Tools
│   ├── tools/
│   │   ├── encrypt_password.py          # AES-encrypts login password and updates .env
│   │   ├── encrypt_env_bot.py           # Encrypts .env_bot and saves it as env_bot.enc
│   │   └── sync_project.sh              # CLI interface for dev→live→prod folder syncs
│
│   # Runtime Output / Audit Artifacts
│   ├── backups/                         # Archived ledgers and logs (daily snapshots)-  Matches /output/summaries/*.json at session end
│   │   ├── logs_live_*.zip              # Zipped bot logs (live)
│   │   ├── logs_paper_*.zip             # Zipped bot logs (paper)
│   │   ├── manager_live_*.manager       # Timestamped Manager.io ledger backups (live sessions)
│   │   ├── manager_paper_*.manager      # Timestamped Manager.io ledger backups (test/paper sessions)
│   │   ├── summary_live_*.json          # JSON reports from live session
│   │   └── summary_paper_*.json         # JSON reports from test mode
│
│   ├── logs/                            # Active logging folder (rotated or zipped by auto_backup)
│   │   ├── bot/
│   │   │   ├── live/                    # Live logs by strategy phase (open, mid, close)
│   │   │   └── paper/                   # Simulated logs (test mode)
│   │   └── web/
│   │       ├── access.log               # IP/timestamp of each login request
│   │       └── auth_failures.log        # Failed login attempts, lockout triggers
│
│   # Internal Documentation
│   ├── docs/
│   │   ├── architecture.md              # System architecture and module breakdown
│   │   ├── API_reference.md             # CLI & internal API details (optional)
│   │   └── security_notes.md            # Data handling, encryption key roles, etc.
│
│   # Automation Scripts (Optional)
│   ├── scripts/
│   │   ├── sync_to_company_books.py     # Pushes .manager data to formal books
│   │   ├── audit_log_parser.py          # CLI utility to review logs and summarize behavior
│   │   └── upload_backups_to_cloud.sh   # Syncs backups/ to S3 or external vault
│
│
├── tbot_bot/                             # Core engine for execution, strategy logic, reporting, and control
│   │
│   ├── __init__.py
│
│   # Accounting Scripts & Logic (modular, software-agnostic)
│   ├── accounting/
│   │   ├── account_transaction.py           # Generic transaction entry builder used by all accounting exporters
│   │   ├── accounting_api.py                # Dispatches ledger export to the active accounting backend
│   │   ├── accounting_config.py             # Controls ledger export behavior and file format settings
│   │   ├── ledger_schema.py                 # Defines account hierarchy and types for use in all exports
│   │   ├── manager_exporter.py              # Generates Manager.io-compatible accounting entries
│   │   └── tradebot_ledger_schema.sql	     # SQL reference for ledger structure – mirrors Manager.io layout; not used to write data
│
│   # Backtesting & Research
│   ├── backtest/
│   │   ├── backtest_engine.py           # Core simulator to replay past trades
│   │   ├── load_historical_data.py      # Load from CSV, OHLCV, or tick sources
│   │   ├── performance_metrics.py       # Computes performance metrics for backtest results - Sharpe, win %, drawdown, etc.
│   │   └── plot_results.py              # Graphs equity curves, trades, and heatmaps
│
│   # Broker Integrations
│   ├── broker/
│   │   ├── broker_alpaca.py             # Alpaca implementation (live/paper)
│   │   ├── broker_api.py                # Unified broker interface and trade dispatch router
│   │   ├── broker_ibkr.py               # Interactive Brokers implementation (live/paper)
│   │   ├── broker_robinhood.py          # Robinhood implementation (live/paper)
│   │   ├── broker_tradier.py         # tradier Brokers implementation (live/paper)
│   │   └── broker_webull.py             # webull integration for sandbox/testing (not production)
│
│   # Configuration & Security
│   ├── config/
│   │   ├── env_bot.py                    # Validates and parses .env_bot
│   │   ├── error_handler.py             # Centralized exception manager and classified logging for tbot
│   │   ├── security_bot.py              # Encrypts/decrypts .env_bot to .env_bot.enc
│   │   └── settings_bot.py              # Programmatic editor for .env_bot values
│
│   # Control Signals (Web/CLI)
│   ├── control/
│   │   ├── control_start.txt            # Start flag file created by web/CLI to trigger bot launch
│   │   └── control_stop.txt             # Stop flag file created by web/CLI to trigger safe shutdown
│
│   # Enhancements (Optional Guards & Filters)
│   ├── enhancements/
│   │   ├── adx_filter.py                # Blocks mid-session trades during trending ADX conditions
│   │   ├── bollinger_confluence.py      # Confirms entries using Bollinger band alignment
│   │   ├── build_check.py               # Validates presence of required files and config before launch
│   │   ├── imbalance_scanner_ibkr.py    # Scans IBKR imbalance feed for market-on-close risk
│   │   ├── ticker_blocklist.py          # Prevents duplicate ticker trading in same session
│   │   └── vix_gatekeeper.py            # Blocks close strategy if VIX is under threshold
│
│   # Output Artifacts
│   ├── output/                             # Canonical location for all bot-generated files
│   │   ├── ledgers/                        # Generated accounting files for live/paper modes (Manager.io)
│   │   │   ├── tbot_live_ledger.manager        # Manager.io-compatible ledger file for real trades
│   │   │   └── tbot_paper_ledger.manager       # Manager.io-compatible ledger file for simulated (paper) trades
│   │   ├── logs/                           # Strategy-specific and broker-level logs
│   │   │   ├── close_live.log                  # Strategy log – close (live)
│   │   │   ├── close_paper.log                 # Strategy log – close (paper)
│   │   │   ├── mid_live.log                    # Strategy log – mid (live)
│   │   │   ├── mid_paper.log                   # Strategy log – mid (paper)
│   │   │   ├── open_live.log                   # Strategy log – open (live)
│   │   │   ├── open_paper.log                  # Strategy log – open (paper)
│   │   │   ├── unresolved_orders_live.log      # Live broker error log
│   │   │   └── unresolved_orders_paper.log     # Paper broker error log
│   │   ├── summaries/                      # End-of-session performance summaries and trade metrics
│   │   │   ├── daily_summary_live.json         # End-of-session stats and trade summaries of live session (PNL, fills, errors)
│   │   │   └── daily_summary_paper.json        # End-of-session stats and trade summaries of paper session
│   │   └── trades/                         # CSV and JSON trade history for each run
│   │       ├── trade_history_live.csv          # Raw log (live trades)
│   │       ├── trade_history_live.json         # Structured JSON (live)
│   │       ├── trade_history_paper.csv         # Raw log (test trades)
│   │       └──trade_history_paper.json        # Structured JSON (test)
│
│   # Reporting & Logging
│   ├── reporting/
│   │   ├── auto_backup.py               # Compresses and archives logs/ledgers after session end
│   │   ├── daily_summary.py            # generate_summary(trades: List[dict], stats: dict, mode: str) → writes /output/summaries/
│   │   ├── export_manager.py            # export_trade_to_manager(trade: dict, mode: str) → appends trade to live/paper Manager.io file
│   │   ├── log_rotation.py            # rotate_logs(retention_days: int = 7) → clean up /logs and /output after N days
│   │   ├── report_router.py            # finalize_trade(trade: dict, strategy: str, mode: str) → routes to trade_logger, daily_summary, export_manager, email alert
│   │   ├── session_report.py            # Generates final report for each trading session
│   │   ├── status_logger.py            # Writes status.json for web interface sync
│   │   └── trade_logger.py             # append_trade(trade: dict, mode: str) → writes to JSON/CSV under /output/trades/
│
│   # Session Lifecycle
│   ├── runtime/
│   │   ├── __init__.py
│   │   ├── main.py                      # Main bot controller (analysis → trade → shutdown)
│   │   ├── start_bot.py                 # Main entry point for bot; starts session lifecycle and strategy sequence
│   │   ├── status_bot.py                # Tracks and records state changes
│   │   ├── stop_bot.py                  #  Safely exits all positions and ends session
│   │   ├── tbot_runner_supervisor.py 	# Oversees session state, handles retries, enforces global watchdog logic
│   │   └── watchdog_bot.py              # Broker connectivity monitor and auto-retry
│
│   # Screener & Symbol Selection
│   ├── screeners/
│   │   └── finnhub_screener.py          #  Screens symbols using Finnhub price and volume data
│
│   # Strategy Logic
│   ├── strategy/
│   │   ├── strategy_close.py            # Implements Late-day momentum/fade strategy with VIX gating
│   │   ├── strategy_meta.py             # Thresholds and toggles used by all strategies
│   │   ├── strategy_mid.py              # Implements VWAP-based mean reversion strategy
│   │   ├── strategy_open.py             # Implements opening range breakout strategy logic
│   │   └── strategy_router.py           # Routes execution to correct strategy based on time or STRATEGY_OVERRIDE

│
│   # Support
│   ├── support/
│   │   ├── .env_bot.enc                      # Encrypted bot config loaded at runtime
│   │   ├── utils_bot.py                     # Shared utilities (time, math, file ops, conversions)
│   │   └── service_bot.py                   # Daemon listener for start/stop signals (optional systemd hook)
│
│   # Test Suite
│   ├── test/
│   │   ├── integration_test_runner.py   # Simulates full bot session in TEST_MODE for integration validation
│   │   ├── test_backtest_engine.py      # Regression test for backtest engine accuracy
│   │   ├── test_env_bot.py              # Validates .env_bot parsing, defaults, and edge cases
│   │   ├── test_exporter_manager.py     # Test Manager.io export output for schema compliance
│   │   ├── test_logging_format.py       # Log format validator
│   │   ├── test_main_bot.py             # Core lifecycle testing
│   │   └── test_strategy_selfcheck.py   # Confirms all strategy modules pass .self_check()

│
│   # Trade Execution
│   └── trading/
│       ├── float_bot.py                 # Loads or calculates the current broker-specific float allocation
│       ├── kill_switch.py               # Abort if drawdown exceeds DAILY_LOSS_LIMIT
│       ├── logs_bot.py                  # Runtime trade + session logging
│       ├── notifier_bot.py              # Alerts via email or Slack
│       ├── orders_bot.py                # Submit, modify, or cancel broker orders
│       ├── reporting_bot.py             # Logs trade results and routes output to accounting exporters
│       └── risk_bot.py                  # Risk management enforcement (allocations, max trades)
│
│
│
└── tbot_web/                             # Web dashboard for monitoring, logs, and control
    ├── assets/                           # Static frontend resources
    │   ├── fnt/                          # Embedded fonts used in the interface
    │   └── css/
    │       ├── main.css                 # Core layout and UI styling rules
    │       └── theme.css                # Optional theme layer (e.g. light/dark modes)
    ├── favicon.ico / favicon.gif        # Site icon for browser tab
    ├── py/                              # Flask backend for web UI and bot interaction
    │   ├── __init__.py                  # Registers Flask blueprints for all routes
    │   ├── auth_web.py                  # AES decryption for login password validation
    │   ├── login_web.py                 # Login/logout route handling with rate limit enforcement
    │   ├── logs_web.py                  # Displays latest bot log output to the web UI
    │   ├── main_web.py                  # Web router and load shell for dashboard interface
    │   ├── portal_web.py                # Flask app factory for app + static + template setup
    │   ├── run_web.py                   # Webserver launcher for local or remote access
    │   ├── settings_web.py              # Updates .env_bot config via web interface
    │   ├── start_stop_web.py            # Drops control_start.txt / control_stop.txt to trigger bot control loop
    │   └── status_web.py                # Loads bot status from JSON output (status_bot.json)
    ├── robots.txt                       # Blocks bots and search engine indexing (security)
    └── templates/                       # HTML UI templates rendered with Jinja2
        ├── index.html                   #  Login screen rendered via Jinja2
        ├── main.html                    # Dashboard shell container with embedded panels
        ├── logs.html                    # Shows logs from current session in read-only format
        ├── settings.html                # Editable UI form for modifying .env_bot values
        └── status.html                  # Live bot status pulled from status_bot.json



==============================
Deployment Notes
==============================

- All file paths must be **relative and platform-agnostic**, ensuring compatibility across macOS, Linux, and cloud servers (e.g., DigitalOcean).
- The `tbot_bot/` module must operate **fully independently**, even if `tbot_api/` (FastAPI interface) or `tbot_web/` (frontend) are disabled or unavailable.
- All logs, ledger exports, and backup behavior must remain active regardless of whether API or web modules are enabled.
- On first deployment, enable **only one broker** (`ALPACA_ENABLED=true` or `IBKR_ENABLED=true`) to simplify debugging and test connectivity.
- At startup, all enabled brokers must validate their API credentials from `.env`. Missing, malformed, or unauthorized keys must trigger a hard stop.
- Strategy activation is controlled independently using:
  - `STRAT_OPEN_ENABLED`
  - `STRAT_MID_ENABLED`
  - `STRAT_CLOSE_ENABLED`
- Before placing **live trades**, the bot must check:
  - Market spread: abort if spread > 1.5% of `entry_price`
  - Volume threshold: abort if average daily volume < `MIN_VOLUME_THRESHOLD` (unless `TEST_MODE=true`)
  - Risk: validate against `MAX_RISK_PER_TRADE` and `DAILY_LOSS_LIMIT`
- Auto-shutdown must occur if:
  - The broker API is offline (`watchdog_bot.py`)
  - A critical error is caught by `error_handler.py`
  - Cumulative losses exceed `DAILY_LOSS_LIMIT` (triggered via `kill_switch.py`)
- TEST_MODE must never write to:
- Ensure that when TEST_MODE=true, the bot does not interact with real data, brokers, or markets in any way. 
  - `tbot_live_ledger.manager`
  - Any log files with `_live` in their name
  - Any `.json`, `.log`, or `.csv` file outside the `_paper` variants
- `FORCE_PAPER_EXPORT=true` overrides normal TEST_MODE behavior and forces all exports to `_paper` outputs. This includes trade history, strategy logs, daily summaries, and ledger writes.
- Ledger  exports are saved to:
  - `tbot_live_ledger.manager` when `TEST_MODE=false` and `FORCE_PAPER_EXPORT=false`
  - `tbot_paper_ledger.manager` when `TEST_MODE=true` or `FORCE_PAPER_EXPORT=true`
- All ledger writes are preceded by an automated timestamped backup using `ledger_backup.py`, saved under `/backups/`.
- Session logs are stored in `/logs/bot/live/` or `/logs/bot/paper/`, then zipped and archived to `/backups/` by `auto_backup.py`.
- All backups may be optionally synced to external storage (e.g., S3, Dropbox, or remote FTP) via the optional script:
  - `scripts/upload_backups_to_cloud.sh`
 -Ensure that the backup process does not interfere with live data and that all backup files are properly tagged to prevent mismanagement
- Strategy timing and trade session control is managed via `.env_bot` using:
  - `START_TIME_OPEN`, `START_TIME_MID`, `START_TIME_CLOSE`
  - `[STRAT]_ANALYSIS_TIME` and `[STRAT]_MONITORING_TIME` per strategy
- All test runs and live executions must honor `TRADING_DAYS` to prevent execution on weekends or holidays (manually disabled as needed).




==============================
Current Platforms
==============================

Development Environment:
- Local testing and version control are performed on macOS 15.2 with Python 3.11+
- All code must be compatible with macOS and Linux (no platform-specific imports or absolute paths)
- Recommended IDE: Visual Studio Code with Black or Ruff for formatting and linting
- Python scripts are executed via terminal or cron, not from GUI IDEs
- Local logs and test exports are saved to `logs/bot/paper/` and `backups/`

Production Deployment:
- Hosted on a DigitalOcean droplet running Ubuntu 22.04 LTS
- Deployed via secure SCP/SFTP
- Execution initiated using:
  - `start_bot.py` (manual or cron trigger)
  - `service_bot.py` (optional daemon for systemd)
- Production mode writes to `logs/bot/live/` and `output/ledgers/tbot_Live_Ledger.manager`

Broker Integrations:
- Alpaca: used for stock/ETF trading and paper/live testing (`ALPACA_MODE` in `.env_bot`)
- Interactive Brokers: supports long puts, inverse ETFs, and advanced routing (`IBKR_MODE`)
- trader, Webull, and Robinhood modules exist in sandbox/test only (not yet production-ready)

Market Data Services:
- Finnhub API provides real-time screening/filtering for all strategies via `finnhub_screener.py`
- Supports pre-market scans, volume thresholds, and breakout/high-low tracking

Accounting Integration:
- Modular accounting engine supports multiple backends via `accounting_api.py`
- Current implementation uses `manager_exporter.py` to generate Manager.io-compatible ledgers
- Ledgers are written to `output/ledgers/` and rotated daily by `auto_backup.py`
- Structure defined by `ledger_schema.py` for universal mapping

Web Interface:
- `tbot_web/`: Flask-based dashboard for live monitoring, control, and configuration
- Supports real-time log viewing, session status, settings updates, and manual start/stop
- Login credentials are AES-encrypted and validated with bcrypt
- All login failures and access attempts are logged to `logs/web/auth_failures.log`

Alerting & Notifications:
- Trade fills and exits can trigger email alerts when `NOTIFY_ON_FILL` or `NOTIFY_ON_EXIT` are enabled
- Emails are dispatched via DreamHost SMTP using credentials defined in `.env`

Security:
- `.env_bot` is encrypted to `.env_bot.enc` using `encrypt_env_bot.py`
- AES key is stored in the root `.env` file under `ENV_BOT_KEY`
- `.env_bot` is never committed to version control and must be manually restored or decrypted

Clarification on Sandbox Testing
tradier, Webull, Robinhood: Specify whether these brokers are read-only (no real trades, only symbol screening) or simulate live trading in test mode (virtual orders, trade lifecycle management).

Backup Synchronization
External Backup Storage: Ensure auto_backup.py synchronizes backups (logs, trade history, ledgers) to cloud storage (S3, Dropbox) or remote FTP.

Encryption: All backup files must be encrypted for secure offsite storage and recovery.

Production Setup Testing
Single Broker Testing: Before full deployment, enable only one broker (either Alpaca or IBKR) to simplify debugging and ensure proper configuration.

Backup Redundancy
Secondary Backup Locations: Replicate backup files to secondary storage (e.g., additional cloud services or FTP) to ensure data availability in case of server failure.

Redundancy Checks: Implement periodic checks to ensure backups are replicated properly.


==============================
Time Zone Standards
==============================

Overview:
To ensure consistency, accuracy, and interoperability across development, testing, and production environments, all time-related variables in TradeBot are defined and logged in **UTC (Coordinated Universal Time)**.

Usage:
- All strategy start times (`START_TIME_OPEN`, `START_TIME_MID`, `START_TIME_CLOSE`) are set in UTC
- Log timestamps, strategy triggers, ledger entries, and alerts must all use UTC
- Internal time comparisons in `strategy_router.py` and `status_bot.py` must convert local system time to UTC before logic execution

Reasoning:
- UTC avoids ambiguity across time zones, daylight saving time shifts, or server environments (macOS, Linux, cloud)
- Allows reliable scheduling when hosting in geographically distributed environments (e.g., DigitalOcean, AWS)
- Compatible with broker API timestamps and log analysis pipelines

Example Mapping:
- 14:30 UTC → 9:30 AM EST (Market Open)
- 15:30 UTC → 10:30 AM EST (Midday Strategy)
- 19:30 UTC → 2:30 PM EST (Close Strategy)

Implementation Tip:
If debugging locally in EST or PST, always convert timestamps before interpreting logs or database entries.

Best Practice:
Add a helper function in `utils_bot.py`:
```python
def utc_now():
    return datetime.utcnow().replace(tzinfo=timezone.utc)



===============================================
RIGD GROUP LLC — Unified Capital Risk Controls and Dynamic Broker Float Allocation (Final .env_bot-Compliant Version)
===============================================
Overview:
RIGD Group LLC (RGL) must dynamically allocate capital and trading float across multiple brokers,
enforce strict per-broker risk controls, and ensure per-session risk discipline across sequentially executed strategies (OPEN, MID, CLOSE).

The system must dynamically adapt as capital grows, brokers are added or removed, or risk parameters are changed via .env_bot.

All constants and thresholds must be sourced from .env_bot environment variables — no hardcoded limits permitted.

Core Capital Allocation Rules:
Total Capital Framework:
100% of RGL available capital must be managed according to the following split:

50% deployed to active brokers (trading float pool)

50% retained in Mercury Reserve (risk buffer and float replenishment pool)

Dynamic Broker Float Allocation:
Deployed float is divided equally among all active brokers.

Formula:
broker_allocation_percentage = 50 / number_of_active_brokers
broker_float_target_usd = RGL_total_capital_usd * broker_allocation_percentage
Adding or removing brokers automatically rebalances floats.

Reserve Integrity:
The Mercury Reserve (remaining 50%) must always be preserved unless explicitly authorized otherwise.

Core Trading Risk Controls:
Risk per Strategy Session (TOTAL_ALLOCATION):
Each strategy session (OPEN, MID, CLOSE) must risk no more than the value of TOTAL_ALLOCATION from .env_bot,
expressed as a fraction of the executing broker’s float.

Formula:
session_risk_cap = broker_current_float * TOTAL_ALLOCATION
The session allocation is divided among active trades using the WEIGHTS array defined in .env_bot.

Important Notes:
TOTAL_ALLOCATION applies to the entire session, not to individual trades.

Each trade receives a fractional share of session allocation based on WEIGHTS.

Example Allocation (Per Broker, Per Session):

Number of Signals	Weight Split (From WEIGHTS)	Risk Allocation
1 signal	100%	100% of session allocation
2 signals	60% / 40%	60%, 40% of session allocation
3 signals	40% / 30% / 30%	40%, 30%, 30% of session allocation
4 signals	40% / 20% / 20% / 20%	40%, 20%, 20%, 20% of session allocation
(Actual weight values sourced from the WEIGHTS setting.)

Example (Assuming Defaults):
Broker float = $2,500

TOTAL_ALLOCATION=0.02

2% session cap = $50

Split according to current WEIGHTS.

Maximum Concurrent Open Positions (MAX_OPEN_POSITIONS and MAX_TRADES):
No more than MAX_TRADES trades may be opened during any single strategy session per broker.

Total open positions across all strategies must not exceed MAX_OPEN_POSITIONS, as defined in .env_bot.

Trade Allocation Weights (WEIGHTS):
Defined in .env_bot.

Determines how TOTAL_ALLOCATION is divided among active trades during a session.

Must have as many entries as the maximum number of possible trades (MAX_TRADES).

Daily Loss Limit (DAILY_LOSS_LIMIT):
Each broker independently tracks cumulative realized PnL relative to its own float.

Formula:

broker_daily_loss_limit_usd = broker_current_float * DAILY_LOSS_LIMIT
If a broker’s realized losses breach this limit:

Only that broker’s trading is halted for the remainder of the day.

Other brokers continue trading unless they individually breach their own DAILY_LOSS_LIMIT.

Rebalancing and Transfer Protocol:
Rebalancing Triggers:
Rebalancing must occur manually or scheduled (e.g., 1–2 times per week).

Rebalancing triggered if a broker’s float deviates by more than 10% from its calculated target.

Transfer Mechanics:
Mercury API must be used for ACH fund movements.

Transfers must not exceed Mercury’s configured ACH limits (currently ~$500K/day unless changed).

Scaling and Compounding:
Broker floats, session risk caps, and trade sizing must scale dynamically based on RGL total capital.

No manual recalibration is permitted unless explicitly authorized and reflected via updated .env_bot values.

Enforcement Modules:

Module	Responsibility
risk_bot.py	Enforces session risk caps (TOTAL_ALLOCATION), WEIGHTS-based trade allocation, concurrent open trade limits (MAX_TRADES and MAX_OPEN_POSITIONS), and monitors per-broker PnL.
kill_switch.py	Halts trading at individual brokers when DAILY_LOSS_LIMIT thresholds are breached.
watchdog_bot.py	Monitors API and server infrastructure stability, disabling broker trading when failures occur.
All controls must operate equally in TEST_MODE and LIVE MODE.

Manual overrides are strictly prohibited unless explicitly authorized and properly reflected in .env_bot.

---------------------------------------------------------

Enforcement Modules:

Module	Responsibility
risk_bot.py	Enforces per-session risk caps, WEIGHTS-based dynamic trade allocation, MAX_CONCURRENT_TRADES_PER_BROKER, and per-broker PnL monitoring.
kill_switch.py	Halts trading at individual brokers if DAILY_LOSS_LIMIT thresholds are breached.
watchdog_bot.py	Monitors API and server stability, disabling broker trading on infrastructure failure.
All controls apply equally in both TEST_MODE and LIVE MODE environments.

No overrides allowed without explicit authorization.

==============================
TradeBot Strategy Logic Spec v1.1
==============================

Overview:
TradeBot executes intraday breakout and reversion strategies using a unified logic pipeline. All entries are directional and follow structured risk, time, and allocation parameters.

Supported Instruments:
- Long equity (common stocks or ETFs)
- Inverse ETFs (e.g., SH, SQQQ)
- Long puts (IBKR only)

Trade Direction Rules:
- Long trades = supported on all brokers
- Bearish trades = only executed if `SHORT_TYPE_*` is not `disabled`
- Puts = only used if broker = IBKR and `SHORT_TYPE_*` = LongPut
- Inverse ETFs = fallback for non-options brokers when `SHORT_TYPE_*` = InverseETF

Supported Brokers:
- Alpaca: long equity, inverse ETFs
- IBKR: long equity, long puts, inverse ETFs
- Webull: read-only (screening only)
- tradier, Robinhood: reserved for future support

Execution Framework:
- Strategy execution is controlled via `STRATEGY_SEQUENCE` in `.env_bot`
- Each strategy module is loaded independently by `strategy_router.py`
- Runtime logic respects UTC windows and `.env_bot` timing variables
- When `TEST_MODE=true`, strategy windows are compressed and symbol scan duration is capped at 1 minute

Active Strategies:
TradeBot includes three modular strategies:

---------------------------------------------------------
Strategy: strategy_open.py – Opening Range Breakout
---------------------------------------------------------

- Time Window:
  - Start: `START_TIME_OPEN` (14:30 UTC = 9:30 AM EST)
  - Analysis phase: `OPEN_ANALYSIS_TIME` minutes
  - Breakout phase: `OPEN_BREAKOUT_TIME` minutes (default: 10)
  - Trade management: `OPEN_MONITORING_TIME` minutes
- Trade Direction: Long by default; supports short breakout only if `SHORT_TYPE_OPEN` is not `disabled`
- Entry Logic:
  - Track high/low range during `OPEN_ANALYSIS_TIME`
  - Enter trade if current price > high * (1 + `STRAT_OPEN_BUFFER`) or < low * (1 - `STRAT_OPEN_BUFFER`)
  - Must occur within `OPEN_BREAKOUT_TIME`
- Exit Logic:
  - 2% trailing stop or timeout (`OPEN_MONITORING_TIME`)
- Enhancements: None
- Instrument: Stock or ETF
- Logging:
  - `open_live.log` / `open_paper.log`
  - Ledger: `manager_live_*.manager` / `manager_paper_*.manager`
  - Trade History: `trade_history_*.csv/json`

-----------------------------------------
Strategy: strategy_mid.py – VWAP Mean Reversion
-----------------------------------------

- Time Window:
  - Start: `START_TIME_MID` (15:30 UTC = 10:30 AM EST)
  - Analysis phase: `MID_ANALYSIS_TIME` minutes
  - Breakout phase: `MID_BREAKOUT_TIME` minutes (default: 10)
  - Trade management: `MID_MONITORING_TIME` minutes
- Trade Direction: Long or Bearish (via inverse ETF or put)
- Entry Logic:
  - Enter when price deviates from VWAP ±`STRAT_MID_VWAP_THRESHOLD`
  - Signal confirmation via ADX and Bollinger filter
  - Entry must occur within `MID_BREAKOUT_TIME`
- Exit Logic:
  - VWAP touch, 1.5% stop loss, or time expiry
- Shorting:
  - Controlled by `SHORT_TYPE_MID`: InverseETF, LongPut, ShortSell, or disabled
- Enhancements:
  - `adx_filter.py`
  - `bollinger_confluence.py`
- Instrument: Stock or Inverse ETF
- Logging:
  - `mid_live.log` / `mid_paper.log`
  - Ledger: `manager_live_*.manager` / `manager_paper_*.manager`
  - Trade History: `trade_history_*.csv/json`

-----------------------------------------
Strategy: strategy_close.py – End-of-Day Momentum / Fade
-----------------------------------------

- Time Window:
  - Start: `START_TIME_CLOSE` (19:30 UTC = 2:30 PM EST)
  - Analysis phase: `CLOSE_ANALYSIS_TIME` minutes
  - Breakout phase: `CLOSE_BREAKOUT_TIME` minutes (default: 10)
  - Trade management: `CLOSE_MONITORING_TIME` minutes
- Trade Direction: Long or Bearish
- Entry Logic:
  - Momentum (continue trend) or fade (reverse spike)
  - Must occur within `CLOSE_BREAKOUT_TIME`
  - Requires VIX > `STRAT_CLOSE_VIX_THRESHOLD`
- Exit Logic:
  - 2% stop loss or hard exit before close
- Shorting:
  - Controlled by `SHORT_TYPE_CLOSE`: LongPut, InverseETF, ShortSell, or disabled
- Enhancements:
  - `vix_gatekeeper.py`
  - `imbalance_scanner_ibkr.py`
  - `ticker_blocklist.py`
- Logging:
  - `close_live.log` / `close_paper.log`
  - Ledger: `manager_live_*.manager` / `manager_paper_*.manager`
  - Trade History: `trade_history_*.csv/json`

-----------------------------------------
Strategy Failover Logic
-----------------------------------------
- Any strategy failing `.self_check()` will skip execution
- If `STRATEGY_OVERRIDE` is set (e.g., `STRATEGY_OVERRIDE=mid`), only that strategy runs
- All execution respects global constraints:
  - `DISABLE_ALL_TRADES`
  - `DAILY_LOSS_LIMIT`
  - `MAX_OPEN_POSITIONS`
  - `TOTAL_ALLOCATION` and `WEIGHTS`
  - Broker status and account restrictions
  - Trade History: `trade_history_*.csv/json`


==============================
Enhancement Module Activation
==============================

Overview:
TradeBot includes modular enhancements that can refine signal quality, block trades under poor conditions, or perform startup diagnostics. These are located in `/tbot_bot/enhancements/` and operate as plug-ins—each designed to activate automatically based on strategy context or `.env_bot` configuration.

All enhancements are:
- Independently testable
- Compatible with both TEST_MODE and live mode
- Invoked automatically from `strategy_router.py` or within individual strategy files

Behavior & Integration:
- Each enhancement returns a simple boolean (`True` = allow trade, `False` = block trade)
- If any enhancement fails (e.g., due to missing data), the strategy logs a warning and proceeds with core logic—unless a fatal error is raised



Enhancement Modules
------------------------------

1. adx_filter.py – Trend Strength Filter
----------------------------------------
Purpose:
- Blocks mean reversion trades when ADX > 25 (indicating a strong trend)

Applies to:
- strategy_mid.py

Trigger:
- Always-on (future toggle: `ADX_FILTER_ENABLED=true` in `.env_bot`)

Notes:
- Skips VWAP entries during trending markets

2. bollinger_confluence.py – Volatility Confirmation
-----------------------------------------------------
Purpose:
- Requires price to touch or exceed ±2 standard deviations on Bollinger Bands

Applies to:
- strategy_mid.py

Trigger:
- Inline call in strategy_mid.py; may be toggleable in future builds

Notes:
- Reduces false positives in flat or low-volatility conditions

3. vix_gatekeeper.py – Volatility Threshold Lockout
----------------------------------------------------
Purpose:
- Prevents trades if VIX is below configured minimum

Applies to:
- strategy_close.py

Trigger:
- Compares real-time VIX against `STRAT_CLOSE_VIX_THRESHOLD` in `.env_bot`

Notes:
- Helps avoid EOD trades during complacent market conditions

4. imbalance_scanner_ibkr.py – Order Book Pressure Monitor
-----------------------------------------------------------
Purpose:
- Reads Interactive Brokers imbalance data between 20:30–21:00 UTC

Applies to:
- strategy_close.py

Trigger:
- Active only when `BROKER=ibkr`

Notes:
- Blocks late-day trades if strong opposing imbalance is detected (IBKR market data subscription required)

5. ticker_blocklist.py – One Trade Per Ticker Per Day
------------------------------------------------------
Purpose:
- Prevents repeat trades on the same ticker during a single session

Applies to:
- All strategies

Trigger:
- Always-on (no toggle)

Notes:
- Tracks traded symbols in memory or temp file

6. build_check.py – Pre-Launch System Verifier
----------------------------------------------
Purpose:
- Verifies all required files, paths, and variables before runtime

Applies to:
- Called once at startup by `main_bot.py` or via CLI

Checks:
- Presence of `.env`, `.env_bot`, `.env_bot.enc` files
- Writable paths and initialized log files
- Placeholder outputs for first run

Fail Behavior:
- Halts the bot if any check fails

Best Practices:
---------------
- Keep all enhancements decoupled from strategy core logic
- Add toggles in `.env_bot` only if dynamic enable/disable behavior is needed
- Use enhancements to prevent poor trades, not as signal generators


===============================================
Unified Safety, Disaster, and Risk Control Protocols (Final Per-Broker Version)
===============================================
Overview:
TradeBot includes multiple layered systems to ensure fault-tolerant behavior, risk discipline, and disaster recovery capability.

All systems operate continuously in both TEST_MODE and LIVE MODE, driven dynamically by .env_bot configuration variables.

Two operational layers:

Safety Systems: Immediate fault detection, error handling, and enforced shutdowns for catastrophic failures (global or broker-specific).

Disaster Risk Reduction Protocol: Gradual automatic risk compression triggered by degrading performance, broker-specific losses, or volatility.

All critical thresholds, caps, and behavioral switches are controlled via .env_bot, with no hardcoded limits allowed.

------------------------------------------------------
1. Disaster Risk Reduction Protocol (.env_bot Driven)
------------------------------------------------------
Trigger Conditions:
Disaster Mode (Defense Mode) activates if any of the following conditions are met:


Condition	Threshold (current, but parameterizable later)
Rolling 1-month win rate drops below	50%
Broker-specific float drawdown exceeds	15% of starting float (per broker basis)
Mercury reserve drawdown exceeds	10%
Kill Switch triggered more than	2 times across all brokers in 20 trading days
Immediate Risk Reductions (All Sourced from .env_bot):

Element	New Behavior	.env_bot Source
Defense Mode Activation	Set DEFENSE_MODE_ACTIVE=true	.env_bot
Session Risk Cap	Set TOTAL_ALLOCATION=DEFENSE_MODE_TOTAL_ALLOCATION per broker	.env_bot
Max Concurrent Trades	Scale MAX_TRADES per broker by DEFENSE_MODE_TRADE_LIMIT_PCT	.env_bot
Trade Weight Adjustment	Dynamically reweight per strategy session based on active trades	Derived at runtime
Strategy Aggressiveness	Disable marginal setups manually or by higher filter thresholds	Operational procedure
Behavioral Changes Under Defense Mode:
Risk per session is capped at DEFENSE_MODE_TOTAL_ALLOCATION relative to each broker's current float.

Max concurrent trades per broker are reduced to (MAX_TRADES × DEFENSE_MODE_TRADE_LIMIT_PCT / 100), rounded down.

No upward float scaling during Defense Mode even if temporary profits occur.

Trade filters become stricter (e.g., higher VWAP deviation thresholds, stronger trend confirmation).

Defense Mode Exit Criteria:
Defense Mode remains active until either:

60 consecutive trades (globally) with win rate >55%, or

30 consecutive sessions (globally) with win rate >55%.

Metrics must be verifiable through logged history and audit trails.

Rebalancing and Transfers During Defense Mode:
Rebalancing Frequency:
Increased to minimum 2× per week (Monday, Thursday).

Reserve Access Restrictions:
No Mercury reserve funds can be injected into broker floats during Defense Mode without explicit approval.

Communication and Logging:
Session Tagging:
All trades during Defense Mode must be tagged "DEFENSE_MODE_ACTIVE" at session start.

Logging:
Maintain an independent Disaster Mode Log recording:

Activation/deactivation timestamps

Triggering conditions

Adjusted float allocations and active trade limits

Optional Dynamic Enforcement Function (Python):
python
Copy
Edit
# risk_bot/defense_mode_utils.py

def calculate_defense_mode_max_trades(normal_max_trades: int, defense_trade_limit_pct: int) -> int:
    if normal_max_trades <= 1:
        return 1
    adjusted_trades = int(normal_max_trades * (defense_trade_limit_pct / 100))
    return max(1, adjusted_trades)
Runtime Enforcement Concept (Per Broker):
python
Copy
Edit
from os import getenv

DEFENSE_MODE_ACTIVE = getenv("DEFENSE_MODE_ACTIVE", "false").lower() == "true"
DEFENSE_MODE_TRADE_LIMIT_PCT = int(getenv("DEFENSE_MODE_TRADE_LIMIT_PCT", 66))
MAX_TRADES = int(getenv("MAX_TRADES", 4))

if DEFENSE_MODE_ACTIVE:
    current_max_trades = calculate_defense_mode_max_trades(MAX_TRADES, DEFENSE_MODE_TRADE_LIMIT_PCT)
else:
    current_max_trades = MAX_TRADES

# Then enforce: active_trades_per_broker <= current_max_trades
------------------------------------------------------
2. Core Safety Systems (Global and Per-Broker)
------------------------------------------------------
2.1. kill_switch.py
Primary Functionality:
Automatically halts trading at individual brokers if realized PnL breach DAILY_LOSS_LIMIT (per broker).

Behavior:

Shuts down all trading at the breached broker.

Other brokers continue unless they independently breach their own limits.

Attempts to close open trades gracefully at breached broker only.

Logs shutdown reason to per-broker shutdown_flag.

2.2. watchdog_bot.py
Primary Functionality:
Continuously monitors API health per broker and market data feeds.

Behavior:

If any broker API becomes unresponsive:

Cancel pending orders at that broker.

Suspend new trade generation only for that broker.

If system-wide (e.g., market data failure), global shutdown is triggered.

2.3. risk_bot.py
Primary Functionality:
Real-time enforcement of:

MAX_RISK_PER_TRADE relative to each broker’s live float.

TOTAL_ALLOCATION per strategy session, per broker.

MAX_TRADES and adjusted dynamic limits in Defense Mode.

Behavior:

Trade validations are executed per broker context.

Violations block trades independently per broker without affecting others.

2.4. error_handler.py
Primary Functionality:
Captures and categorizes runtime exceptions globally and per broker:

NetworkError

BrokerError

LogicError

ConfigError

Behavior:

Logs errors structured by timestamp, broker, strategy, and error class.

Triggers localized or full shutdown based on severity level.

2.5. security_bot.py
Primary Functionality:
Enforces encrypted .env_bot handling at startup to protect configuration integrity.

Behavior:

Requires valid ENCRYPTION_KEY.

No plaintext credential usage permitted in production.

------------------------------------------------------
3. Emergency Shutdown Behavior (Global vs Broker)
------------------------------------------------------

Event	Scope	Action
Broker DAILY_LOSS_LIMIT breach	Broker only	Shut down trading at that broker.
Broker API failure (watchdog)	Broker only	Halt that broker's trading until API recovery.
Global Market Data API failure	All brokers	Full system shutdown.
Uncaught critical system error	All brokers	Full system shutdown.
Manual admin override	Specified scope	Manual controlled shutdown or reset
All shutdowns trigger final audit logs and administrative alerts.

------------------------------------------------------
4. Self-Check System
------------------------------------------------------
All core safety modules (kill_switch.py, watchdog_bot.py, risk_bot.py, error_handler.py, security_bot.py) must pass self_check() validation at system boot.

Validation includes:

.env_bot structure

Defense Mode variables

Broker connectivity

Risk limits correctly loaded

Any self_check failure prevents system launch and logs the specific cause.

===============================================
End of Unified Safety, Disaster, and Risk Control Protocols (Per-Broker Version)
===============================================


====================================================================
INTEGRATION MODULE – TBOT + ACCOUNTING SYSTEM ALIGNMENT
====================================================================

Purpose:
This section mandates integration alignment between the tbot execution system and the forensic-grade accounting system currently under modular build.

Scope:
These rules apply to:
- All tbot trading actions (live, paper, test modes)
- All float injections, float returns, broker cash movements
- All profit/loss logging, reconciliation, and reporting

====================================================================
KEY INTEGRATION RULES
====================================================================

1. LEDGER ISOLATION PER ENTITY + MODE
   - All tbot activities must write to the dedicated ledger for its operating mode:
     - `TBL-LIVE` → live ledger database
     - `TBL-PAPER` → paper/simulation ledger database
   - Under no circumstances should tbot write directly to non-tbot entity databases (e.g., `RGL`, `RHL`).
   - Float movements between entities (including between live/paper environments) must be recorded via cross-entity sync handlers.

2. MULTI-CURRENCY READINESS
   - All ledger entries must carry an explicit currency code (`currency_code`), even if currently single-currency.
   - The accounting system’s schema supports multi-currency by default; ensure tbot passes accurate currency on all postings.

3. INGESTION PIPELINE COMPLIANCE
   - All broker API fills and executed trades must pass through the accounting system ingestion modules (e.g., `mercury_pull.py`, `wise_pull.py`).
   - Raw trade or bank records should not be written directly into final ledger tables.

4. DOUBLE-ENTRY ENFORCEMENT
   - Every tbot action that creates a ledger entry must obey split sum = 0 constraints (double-entry).
   - Injection, withdrawal, profit, loss, and fee postings must balance across accounts.

5. AUDIT LOGGING
   - Every critical tbot-triggered accounting action (injection, trade, reconciliation) must create an immutable audit log entry in the `logs` table.
   - Manual corrections or overrides must be flagged and tracked.

6. OFX EXPORT READINESS
   - All ledger data written by tbot must remain OFX-aligned for seamless export and downstream processing.
   - Ensure that every recorded transaction includes:
     - OFX-compliant `TRNTYPE`
     - Proper `DTPOSTED` timestamp
     - Stable `FITID` identifier

7. SYSTEM INDEPENDENCE
   - tbot must not bypass the accounting system’s control, validation, or export layers.
   - Even in test or simulation modes, tbot should simulate writing through the accounting interfaces for consistency.

====================================================================
MANDATORY DEPENDENCY MODULES (FROM ACCOUNTING BUILD)
====================================================================
For the tbot-to-ledger integration to work, the following accounting system modules must be complete before tbot integration:

- Phase 0: Core Framework (`/config.py`, `/utils/db_connection.py`, `/entities/init_db.py`)
- Phase 1: Ingestion Pipeline (`/ingestion/*`, `/processing/normalize.py`, `/logs/logger.py`)
- Phase 4: OFX Export Generator (`/export/generate_ofx.py`)

====================================================================
RISKS IF IGNORED
====================================================================
- Inconsistent or unbalanced ledgers
- Breakage in cross-entity or cross-mode financial control
- Regulatory non-compliance (IRS, SEC)
- Corruption of forensic audit trail
- Inability to generate correct OFX or tax drafts
- Confusion between paper and live capital pools

====================================================================
NEXT STEP
====================================================================
Update the master tbot build instructions section by section, ensuring:
- All direct ledger writes are rerouted through the accounting system
- All reconciliations and exports pull from the aligned, mode-specific ledger databases
- All float handling obeys cross-entity sync and logging controls
- All ledger entries include currency tagging for multi-currency support





==============================
Logging & Reporting Format
==============================

TBot writes structured output files during every session for audits, dashboards, and accounting exports. Output is routed to either `_live` or `_paper` variants based on `TEST_MODE`.

Log Mode Switching
------------------------------
Variable: TEST_MODE (from .env_bot)
- true  → writes to `_paper` logs and ledgers
- false → writes to `_live` logs and ledgers

Variable: LOG_FORMAT (from .env_bot)
- csv   → human-readable logs
- json  → structured logs (for dashboards, parsing, etc.)

Primary Log Files
------------------------------
All strategy and trade logs follow this naming structure:

  open_live.log / open_paper.log              # Strategy: Opening Range Breakout  
  mid_live.log / mid_paper.log                # Strategy: VWAP Mean Reversion  
  close_live.log / close_paper.log            # Strategy: End-of-Day Fade/Momentum  

  trade_history_live.csv / trade_history_paper.csv  
  trade_history_live.json / trade_history_paper.json  

  unresolved_orders_live.log / unresolved_orders_paper.log  
  daily_summary_live.json / daily_summary_paper.json  

All logs are staged into:
- `output/logs/`          → strategy, error, and unresolved order logs
- `output/trades/`        → trade history per session
- `output/summaries/`     → final session summaries (PnL, stats)

Rotated and timestamped logs are archived into `/backups/` via `auto_backup.py`.

Required Fields in trade_history_*.json (if LOG_FORMAT=json)
------------------------------
- timestamp          → ISO 8601 UTC  
- strategy_name      → open, mid, or close  
- ticker             → stock or ETF symbol  
- side               → long or short  
- size               → shares/contracts  
- entry_price        → float  
- exit_price         → float  
- PnL                → profit or loss  
- broker             → e.g., alpaca, ibkr  
- mode               → paper or live  
- error_code         → present only if rejected, partial, or failed  

Log File Notes
------------------------------
- Logs are never re-imported into the ledger; they are a parallel audit trail.  
- `unresolved_orders_*.log` captures broker-level failures, delays, or partial fills.  
- `daily_summary_*.json` includes:
  - trade counts  
  - win/loss ratio  
  - PnL totals  
  - execution speed  
  - most/least profitable symbols  
  - triggered strategies

Ledger Routing
------------------------------
All ledger output is routed by:

- `TEST_MODE`                  → routes to live or paper ledger
- `FORCE_PAPER_EXPORT=true`   → overrides to paper ledger (even for live trades)
- `ACCOUNTING_EXPORT_MODE=auto` → enables export after trades

Ledger Output Files:
- `TEST_MODE=true`  
  → `output/ledgers/tbot_Paper_Ledger.manager`  
- `TEST_MODE=false`  
  → `output/ledgers/tbot_Live_Ledger.manager`  

Export Flow:
1. `reporting_bot.py` collects trade data  
2. `accounting_api.py` routes to correct backend (currently: Manager.io)  
3. `manager_exporter.py` generates entries  
4. `accounting_config.py` manages export format, path, and mode  
5. `auto_backup.py` archives ledger file after session

Use Cases
------------------------------
- Auditing and compliance snapshots  
- Session summaries for internal dashboards  
- Matching live vs. test-mode performance  
- Confirming strategy execution integrity


==============================
Ledger Architecture
==============================

The following ledger structure applies to all Manager-compatible exports written by `manager_exporter.py`. It supports full double-entry audit trails and syncs with your corporate chart of accounts.

=============================================
tbot_Live_Ledger.manager – Real Trades Ledger
=============================================

Assets
├── Bank Accounts
│   ├── Float Injection – From RIGD Group
│   └── Float Returned – To RIGD Group
├── Broker Accounts (Live)
│   ├── Alpaca – Cash
│   ├── Alpaca – Equities
│   ├── IBKR – Cash
│   └── IBKR – Equities

Income
├── Realized Gains – Alpaca
├── Realized Gains – IBKR

Expenses
├── Broker Fees – Alpaca
├── Broker Fees – IBKR
├── Slippage / Execution Losses
├── API Timeout Penalties
├── Bot Infrastructure Costs

Equity
├── Capital Float Ledger
├── Daily Float Allocation History
├── Opening Balance

Metadata / Logging
├── Trade UUID
├── Broker Confirm #
├── Strategy Tag
├── Source Method Tag
├── EOD Synced Flag
├── Reconciliation Passed Flag

System Integrity
├── Failures & Rejected Orders
├── Manual Overrides
├── Ledger Lock State (true/false)
├── Ledger Status: ACTIVE / DECOMMISSIONED
├── Final Entry Timestamp
├── Debug/Strategy Tags

Exports
├── Daily P&L → Summary Report
├── JSON/CSV for Audit Archive
├── SQLite Ledger Dump
├── Broker Confirm Archive (PDFs)
└── EOD Position Snapshot

=============================================
tbot_Paper_Ledger.manager – Simulated Trades Ledger
=============================================

Assets
├── Simulated Cash – Alpaca
├── Simulated Cash – IBKR

Income
├── Simulated Gains – Alpaca
├── Simulated Gains – IBKR

Expenses
├── Simulated Broker Fees
├── Simulated Slippage Losses
├── Simulated Platform Access Charges

Equity
├── Simulated Capital Float
├── Reset Marker (Backtest Start Point)
├── Opening Equity for Scenario

Audit / Logging
├── UUID Tags for Simulated Trades
├── Strategy Variant Tags
├── API Failures (Simulated)
├── Trade Log Snapshots
├── Manual Test Notes
├── Ledger Lock State
├── Ledger Status
├── Final Entry Timestamp
└── Comparison to Live Ledger (optional)

Exports
├── P&L Export (CSV)
├── SQLite Dump
├── Match Table vs. Live Ledger
├── Execution Integrity Report
└── Sim Snapshot Archive (Broker API Emulation)

Export Rules
------------------------------
- `FORCE_PAPER_EXPORT=true` overrides all routing to paper ledger  
- No `.csv` or `.json` logs are parsed into the ledger  
- Only active session memory and validated trade data are exported  
- All exports are timestamped and archived on session end  
- Exports will **fail fast** if structure or lock-state errors are detected  







==============================
Secure Environment Variables
==============================

Overview:
TradeBot separates its runtime configuration into two environment files:

.env contains broker credentials, API keys, encryption keys, and SMTP credentials.

.env_bot defines trading logic, timing, strategy settings, and risk controls.

Security Goals:
Never expose .env_bot contents in plaintext on shared systems.

Ensure only validated and decrypted variables are loaded during runtime.

Allow encrypted deployment on remote servers (e.g., DigitalOcean) without exposing raw configuration.

Encryption System:
.env_bot is encrypted using AES-256 via the cryptography module.

The encrypted version is saved as .env_bot.enc.

Decryption Key: The decryption key is defined in the global .env file under:

ENCRYPTION_KEY="your-256-bit-key"

Required Files:

encrypt_env_bot.py: Handles encryption and decryption of the .env_bot file, and writes the encryption key to the .env file.

encrypt_password.py: A CLI tool to encrypt login credentials for the web interface and write the encryption keys to the .env file.

Encryption Workflow:
Create .env_bot:

Start with a plaintext .env_bot file and populate it with all necessary variables.

Encrypt .env_bot:

Run the encrypt_env_bot.py to generate the .env_bot.enc and store the ENCRYPTION_KEY securely inside .env.

Runtime Decryption:

During runtime, env_bot.py will:

Load and decrypt the .env_bot.enc using the key from .env.

Validate all keys, and raise readable errors if any are missing or malformed.

Manual Encryption Example:
To manually encrypt the .env_bot file, use the following command:

python3 encrypt_env_bot.py

Security Notes:
Never include .env_bot or .env_bot.enc in version control or build packages.

Use .scpignore and .gitignore to ensure these files are excluded from commits.

Encrypted files should only be decrypted in-memory or on secure systems.

Ensure that access to .env and `.env_bot.enc is restricted** on production environments.

Best Practices:
Test decryption and validation in a staging environment before deploying to production.

Rotate encryption keys regularly, especially if deployment environments or personnel change.

Log any failed decryptions or missing variables to the unresolved_orders_*.log files for auditing purposes.

Recovery:
If .env_bot.enc becomes corrupted or if the decryption key is lost:

Retrieve the latest .env_bot backup from the /backups/ folder.

Re-encrypt using the encrypt_env_bot.py script.



==============================
Centralized Error Management
==============================
------------------------------------------------------------
Overview:
------------------------------------------------------------
TradeBot uses a centralized error handling system to monitor and manage failures during runtime across all modules. The error_handler.py module ensures that critical issues are logged, reported, and escalated appropriately — preventing silent failures or inconsistent states.


------------------------------------------------------------
TradeBot-001 Full Emergency Event Matrix
------------------------------------------------------------


Event
Detection Module
Scope
System Response
Reboot Needed?
Broker PnL Loss > DAILY_LOSS_LIMIT
kill_switch.py
Broker only
Halt trading at that broker; log shutdown flag
No
Broker API Down (e.g., Tradier offline)
watchdog_bot.py
Broker only
Suspend trading at that broker until recovery
No
Global Market Data Feed Down
watchdog_bot.py
All brokers
Full bot shutdown (stop_bot.py triggered)
Yes
.env_bot Decryption Failure
security_bot.py
All brokers
Block launch; log failure immediately
Yes
Runtime Logic Error (e.g., invalid risk calculation)
error_handler.py
Depends on severity
Escalate to kill_switch if critical
Yes if escalated
Defense Mode Activation
risk_bot.py (trigger) + .env_bot (flag)
All brokers
Compress session risk and limit trades dynamically
No
Trade Validation Failure (e.g., oversize order)
risk_bot.py
Broker only
Block trade silently, log error; no crash
No
Manual Emergency Shutdown Request
control_stop.txt (CLI or web)
Specified broker or all
Safe shutdown initiated immediately
Yes
System File Integrity Failure (missing .env_bot, bad paths)
build_check.py
All brokers
Abort launch with critical error log
Yes

------------------------------------------------------------

Module: tbot_bot/error_handler.py

Capabilities:
Captures and categorizes exceptions from:

Strategy modules (e.g. logic errors, data type mismatches)

Broker interface modules (broker_api.py, broker_ibkr.py, etc.)

Utility and infrastructure modules (reporting_bot.py, risk_bot.py, etc.)

Error Classification:
NetworkError: API connectivity issues, timeouts, DNS failures

BrokerError: Order rejection, margin issues, invalid asset classes

LogicError: Runtime logic issues or invalid config values

ConfigError: Missing keys or improperly formatted values in .env_bot

Logging Behavior:
Log Destination:
All errors are written in a structured format to:

unresolved_orders_live.log or unresolved_orders_paper.log (based on TEST_MODE)

Format: JSON or CSV depending on LOG_FORMAT

Logged Fields:

timestamp

strategy_name

broker

error_type

error_code (optional)

raw_exception (full stack trace, truncated to prevent log overflow)

Retry & Fallback:
Implements exponential backoff retry logic for transient failures (e.g., temporary API downtime)

If retry fails after API_RETRY_LIMIT, error is escalated and logged to ensure system doesn't silently continue

Notification System:
For critical errors or unresolved rejections, triggers alerts via notifier_bot.py

Alerts include:

Timestamp

Error summary

Strategy context

Broker info

Alert channels are defined via SMTP settings in .env

Kill Switch Integration:
On detection of unrecoverable error conditions, the error handler:

Invokes kill_switch.py to halt further trades

Ensures a clean shutdown, logs the shutdown reason to logs_bot.py

Optional Integration:
Can be linked to status_web.py and logs_web.py to show error status via the dashboard

Failsafe behavior should never rely on frontend modules — operates fully headless

Usage Notes:
Must be imported and initialized in main_bot.py and reused across all critical modules

When possible, all exceptions should be wrapped and passed to error_handler.handle() with appropriate classification tags

Ensures maximum transparency and auditability of all failed or skipped trades


Overview:
To ensure robustness and validate strategy logic before deployment, TradeBot includes a complete historical backtesting engine. This framework simulates trades using historical data and provides actionable performance metrics, helping to optimize and refine strategies before live trading.

Module:

backtest_engine.py

Features:
Simulates historical trades using the same strategy logic found in:

strategy_open.py

strategy_mid.py

strategy_close.py

Loads minute-level OHLCV (Open, High, Low, Close, Volume) data via load_historical_data.py

Bypasses live broker APIs: Trades are simulated internally, ensuring no live trades are executed during backtesting

Compatible with both CSV and JSON output formats

Results are stored in a subfolder such as backtest_results/

Reuses all logic and environment variables from .env_bot, ensuring consistency between backtesting and live/trading environments

Performance Metrics (via performance_metrics.py):
Win Rate (%): Percentage of profitable trades

Maximum Drawdown: Largest peak-to-trough decline in equity during backtest

Average Trade Duration: Time between trade entry and exit

Average PnL per trade: Average profit or loss per trade

Sharpe Ratio: Measures risk-adjusted return

Charts & Reports:
Visualize equity curve, drawdown, and entry/exit points using plot_results.py

Command-Line Interface:
To run the backtest engine, execute the following command from the root of the tbot_bot/ directory:

python backtest/backtest_engine.py --strategy=open --start=2023-01-01 --end=2023-12-31 --data_source=./historical_data/open_ohlcv.csv
--strategy: Specifies the strategy to backtest (e.g., open, mid, close)

--start: Start date for the backtest

--end: End date for the backtest

--data_source: Path to the CSV file containing the historical data

Runtime Configuration:
All parameters (e.g., allocation, thresholds, filters) are pulled from .env_bot

TEST_MODE logic is automatically assumed (no real trades are executed during the backtest)

Filters (e.g., volume, price) may be toggled manually for analysis

Supported Strategies:
open, mid, close — these strategies must be listed in STRATEGY_SEQUENCE in .env_bot

Each strategy must support a .simulate() method or equivalent backtest logic

Ledger Output:
Trade logs generated during backtests will be written to:

trade_history_backtest.csv

trade_history_backtest.json

daily_summary_backtest.json

These files do not modify live or paper ledgers

Ledger export is not used during backtesting

Logging Format:
All simulated trade logs follow the same structure as live/paper runs:

timestamp

strategy_name

ticker, side, size

entry_price, exit_price, PnL

mode=backtest

Notes:
The backtest engine is sandboxed and stateless, ensuring no interference with live systems

Required step: Backtesting must be completed before any new strategy can be deployed to live trading

Does not depend on tbot_api/ or tbot_web/ — fully independent from web interface or broker APIs





==============================
Testing and Validation Suite
==============================

Overview:
A robust testing framework ensures that all TradeBot logic executes as expected across strategies, environments, and runtime modes. The following tools, test files, and logic gates are implemented to support validation prior to any live deployment.

Testing Directory Structure:
Located in: tbot_bot/tests/

Files:
test_main_bot.py – Verifies lifecycle loop, strategy routing, and logger integrity.

test_env_bot.py – Confirms full variable coverage, validation errors, and defaults in .env_bot.

test_backtest_engine.py – Runs simulated trades on sample historical data and verifies consistency with execution rules.

integration_test_runner.py – Launches end-to-end simulation of a trading session (TEST_MODE only).

Framework:
All tests use pytest and must be runnable via CLI or CI/CD pipeline.

Tests are modular and can be run individually or in batches.

Output formats are compatible with --junitxml and CI test reporters.

Example Test Command:
To run all tests in the testing directory:


pytest tbot_bot/tests/
Integration Test Workflow:
Loads a simulated .env_bot test config.

Launches main_bot.py using TEST_MODE=true.

Injects historical price data using mocks or patched inputs.

Runs start_bot.py in dry-run mode.

Verifies the following:

Strategy execution order (based on STRATEGY_SEQUENCE).

Log generation to the correct _paper files.

Manager.io export logic via manager_exporter.py.

Proper handling of signals, triggers, and errors.

Asserts trade integrity and structure of all logs and exports.

CI Compatibility:
Compatible with GitHub Actions, GitLab CI, or local test runners.

All test scripts and outputs are headless (no GUI, web UI, or API calls required).

Custom .env_bot.test config files may be loaded during CI runs with overrides.

Requirements:
Python 3.11+

pytest, pydantic, and all packages listed in requirements.txt

Test-Mode Enforcement:
integration_test_runner.py MUST only run with TEST_MODE=true.

All trade outputs are written to *_paper logs only.

Test failures are captured and printed to stdout/stderr immediately.

Version Compliance:
test_env_bot.py must validate that .env_bot["VERSION_TAG"] matches VERSION.md.

Build is considered invalid if the version tags are mismatched.

Recommended Additions (Optional):
test_logging_format.py: Validates that the log format matches the JSON structure schema.

test_strategy_selfcheck.py: Confirms that .self_check() returns True across all strategies.



==============================
Real-Time Monitoring Dashboard
==============================

Overview:
The web interface provided by tbot_web/ includes a live dashboard designed to monitor bot operations, active positions, and key runtime metrics. This dashboard operates independently of trading logic and is updated via background tasks and lightweight API polling.

Purpose:
Provides remote visibility into trading activity and system health.

Allows real-time monitoring without compromising headless operation.

Offers read-only observability and does not affect core strategy execution.

Metrics to Display:
Current Active Strategy: Displays which strategy is currently active (strategy_open.py, strategy_mid.py, strategy_close.py).

Scheduled and Actual UTC Start Times: Shows scheduled and actual UTC start times from .env_bot.

Trade Metrics: Number of trades signaled, entered, and exited.

Real-Time P&L: Per position and cumulative profit and loss.

Active Positions: Displays active positions including:

Ticker

Size

Entry price

Current price

Unrealized profit or loss (PnL)

Broker Connectivity and API Status: Monitors broker connection status via watchdog_bot.py.

System State: The current state of the bot, e.g., idle, analyzing, trading, or shutdown.

API Retry Count or Recent Error Summary: Tracks retries or errors.

Test Mode Indicator: Displays whether the bot is running in test mode (true/false).

Frontend Components:
status.html: Displays live strategy state and performance metrics.

logs.html: Streams major log events, alerts, and errors.

main.html: A container layout for the dashboard navigation.

index.html: Login portal (encrypted via auth.py).

Backend Modules:
status_web.py: Streams live data from status_bot.py to the frontend.

logs_web.py: Exposes recent log snapshots.

start_stop_web.py: Optional lifecycle control from the web UI.

main_web.py: FastAPI router for the web interface.

login_web.py: Handles user authentication.

Implementation Details:
Data is updated via either WebSockets or async polling using FastAPI.

The web layer relies on .env credentials for login and encrypted session management.

Supports read-only mode for secure deployments where no trading control is exposed to the web interface.

Security:
Login Rate Limiting: Login attempts are rate-limited via SlowAPI.

Failed Login Logging: Failed login attempts are written to logs/web/auth_failures.log.

Successful Login Logging: Successful access is logged to logs/web/access.log.

Important Notes:
The dashboard is optional and not required for bot functionality.

All bot logic must remain functional even if the tbot_web interface is disabled or unreachable.

The dashboard can be monitored from desktop, tablet, or mobile devices, even in low-bandwidth environments.



==============================
Final Build Checklist
==============================

This checklist ensures that all components of TradeBot are production-ready, internally consistent, and compliant with safety, logging, and accounting requirements. Every item must pass validation prior to live deployment.

Configuration:
.env is present, with populated:

ENCRYPTION_KEY

SMTP credentials

Local IP and PORT for Flask

Login credentials and environment toggles

.env_bot is either decrypted or automatically loaded from .env_bot.enc

All strategy, risk, and logging variables are valid and non-empty

VERSION_TAG inside .env_bot matches root VERSION.md

Environment Validation:
env_bot.py performs full schema validation with required key checks

Fails fast on missing, malformed, or out-of-range values

.env_bot.template-test is up to date with full variable list and inline comments

Strategy Logic:
main.py loads STRATEGY_SEQUENCE and routes to the correct strategy file

Each strategy (strategy_open.py, strategy_mid.py, strategy_close.py) implements self_check() and passes

Execution rules (volume filter, slippage filter, spread limits) are respected in live mode

Logging System:
Log files route to either _live or _paper folders depending on:

TEST_MODE

FORCE_PAPER_EXPORT

All log entries include timestamp, ticker, side, size, prices, strategy, broker, and mode

Logging path is consistent with:

output/logs/ (active session)

backups/ (archived after session end)

LOG_FORMAT applies globally across all output logs (CSV or JSON)

Accounting Ledger Export (Manager.io-Compatible):
Trade data is collected by reporting_bot.py

Export dispatches through accounting_api.py to manager_exporter.py

Output file:

tbot_live_ledger.manager (live)

tbot_paper_ledger.manager (paper)

Structure defined by ledger_schema.py and validated before write

Ledger export respects:

TEST_MODE

FORCE_PAPER_EXPORT

ACCOUNTING_EXPORT_MODE=auto

Backups of exported ledgers stored in backups/

Broker Connectivity & Routing:
broker_api.py correctly dispatches to:

Alpaca (broker_alpaca.py)

IBKR (broker_ibkr.py)

Others (Webull, tradier, Robinhood) are inactive

ALPACA_MODE and IBKR_MODE control paper/live routing

watchdog_bot.py runs broker connectivity health checks before and during trading

Safety & Shutdown Systems:
kill_switch.py halts execution if DAILY_LOSS_LIMIT is breached

risk_bot.py prevents trade entry that violates:

Allocation limits

Position size rules

Ticker blacklist

error_handler.py logs uncaught exceptions and optionally triggers alert

stop_bot.py exits all positions and ends session cleanly

Notifications:
notifier_bot.py sends real-time email alerts if:

NOTIFY_ON_FILL=true

NOTIFY_ON_EXIT=true

SMTP is configured in .env and validated

Alerts are disabled in test mode unless explicitly allowed

Testing & Quality Assurance:
Dry-run complete with:

TEST_MODE=true

FORCE_PAPER_EXPORT=true

All _paper files were generated and reviewed

pytest passes all unit tests in tests/

integration_test_runner.py successfully simulates full lifecycle in test mode

Web Control & Interface:
Flask interface (tbot_web/) is running at expected IP/PORT

Login authentication and AES encryption tested with:

encrypt_password.py

ENCRYPTED_PASSWORD + PASSWORD

Web controls (Start/Stop buttons) correctly write to:

control/control_start.txt

control/control_stop.txt

All /settings, /logs, /status routes function correctly and are protected

Deployment Readiness:
All file paths are relative, portable, and Linux/macOS compatible

Web server and bot logic run in separate processes:

Flask is independent of bot lifecycle

CLI triggers include:

start_bot.py for direct launch

service_bot.py for daemon mode

All sensitive files ignored by .scpignore_* rules

Version Control & Deliverables:
Final build printed in Code Blocks (not printed in canvas, or distributed as ZIP)

VERSION.md documents all changes per version tag

No test artifacts, temp logs, or passwords committed to repo

backups/ and output/ contents verified for accuracy and isolation




==================================================================
RIGD GROUP LLC — TradeBot-001 Runtime Flow (Final Full Version)
==================================================================
Phase 0: Pre-Session (Preparation)
diff
Copy
Edit
[ MANUAL ACTION ]
    ↓
- Configure .env_bot (.env if needed)
- Decrypt env_bot.enc (security_bot.py)
- Start Web UI and/or control_start.txt (CLI or browser)
    ↓
Phase 1: System Boot Validation
sql
Copy
Edit
BOOT SEQUENCE INITIATED
    ↓
security_bot.py → Decrypts and loads .env_bot
    ↓
env_bot.py → Validates all required environment variables
    ↓
self_check() validation for modules:
    - risk_bot.py
    - kill_switch.py
    - watchdog_bot.py
    - error_handler.py
    - strategy_router.py
    ↓
IF any self_check fails → Abort system launch and log reason
ELSE → Proceed to session initialization
Phase 2: Session Initialization

SESSION START
    ↓
float_bot.py → Load current broker float allocations
    ↓
Load dynamic settings:
    - MAX_TRADES
    - TOTAL_ALLOCATION
    - WEIGHTS
    - Defense Mode overrides if DEFENSE_MODE_ACTIVE=true
    ↓
status_bot.py → Update session status JSON for web UI
    ↓
BEGIN STRATEGY CYCLE
Phase 3: Strategy Cycle (Open → Mid → Close)
For Each Strategy Phase (OPEN, MID, CLOSE):

[ At Scheduled UTC Start Time ]
    ↓
strategy_router.py → Loads correct strategy module
    ↓
Strategy self_check():
    - Confirm strategy module integrity
    - Confirm broker availability
    - Confirm float sufficient
    ↓
Start Symbol Screening (finnhub_screener.py)
    ↓
For each candidate symbol:
    ↓
    → Calculate risk sizing (TOTAL_ALLOCATION split by WEIGHTS)
    → Validate MAX_RISK_PER_TRADE
    → Validate MAX_CONCURRENT_TRADES_PER_BROKER
    ↓
    IF validation passes:
        → Submit order to broker (broker_api.py → broker_alpaca.py, broker_ibkr.py, broker_tradier.py)
        → Log entry in trade_logger.py
    ELSE:
        → Block trade, log rejection in unresolved_orders_*.log
    ↓
Monitor open trades:
    - Apply trailing stops, VWAP exits, VIX gates
    - watchdog_bot monitors broker API health
    - kill_switch.py monitors per-broker PnL
    ↓
Session phase ends after analysis/breakout/monitoring windows expire
Phase 4: Risk and Disaster Monitoring (Continuous)

During Session:
    ↓
- risk_bot.py continuously enforces per-broker trade caps and risk sizing
- kill_switch.py watches per-broker DAILY_LOSS_LIMIT
- watchdog_bot.py monitors API health (per broker)
- error_handler.py captures and classifies runtime errors

IF breach detected:
    ↓
    - kill_switch breach → Broker-specific trading halt
    - API failure → Suspend broker temporarily
    - Global market data API failure → Full system halt
    - Critical logic error → Full system halt
    ↓
Log all faults, tag trades if Defense Mode active
Phase 5: Session Termination

All Strategy Windows Closed
    ↓
stop_bot.py safely closes any still-open trades
    ↓
Final Export Phase:
    - Trade Logs (trade_history_live.csv/json)
    - Strategy Logs (open_live.log, mid_live.log, close_live.log)
    - Daily Summary (daily_summary_live.json)
    - Manager.io Ledger (tbot_live_ledger.manager)
    ↓
auto_backup.py compresses logs and ledgers into /backups/
    ↓
status_bot.py writes final session status ("CLOSED")
    ↓
Session Complete
Phase 6: Manual Review and Rebalancing (Post-Session)

- Review backups, trade history, summary logs
- Update RGL → Broker floats manually if needed
- Rebalance Mercury reserve floats if over/under deviation threshold
- If Defense Mode triggers occurred, adjust DEFENSE_MODE_ACTIVE flag
- Prepare for next session manually (or via web portal interface)
===============================================
End of TradeBot-001 Full Runtime Flow
===============================================
Key Design Confirmations:
Per-broker trading isolation during session (float, risk, shutdowns independent).

Global shutdowns only for catastrophic failures (market data down, core API unresponsive, logic errors).

Defense Mode dynamically adjusts session risk and max trades per broker without external intervention.

Audit Trail enforced at every stage: logs, summaries, ledger entries, event flags.

Web Dashboard synchronization (via status_bot.py) to reflect real-time system state.





















































