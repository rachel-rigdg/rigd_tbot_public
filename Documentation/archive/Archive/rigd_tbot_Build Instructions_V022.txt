

Please read and internalize all content in this thread. Acknowledge that you fully understand the Objective, System Instructions, and complete architecture of the system before proceeding. This session is part of an active build process and requires strict adherence to the documented structure and rules.


==============================
Objective (UPDATED)
==============================

TradeBot automatically identifies securities in a bi-directional manner and places trades using:

- Long equity positions when bullish criteria are met.
- Inverse ETFs or long puts when bearish signals are triggered.

Supported brokers must allow:
- Long equity trading
- Long puts or inverse ETFs (based on `SHORT_TYPE_*` per strategy in `.env_bot`)

TradeBot operates in real-time using intraday strategies and must support:
- Fully automated execution with dynamic risk-weighted position sizing
- Headless operation without dependency on the web interface or API server
- Runtime risk enforcement based strictly on `.env_bot` controls:
  - `DAILY_LOSS_LIMIT`, `MAX_RISK_PER_TRADE`, `TOTAL_ALLOCATION`, `MAX_OPEN_POSITIONS`, etc.
- Immutable, audit-grade reporting to the accounting system’s OFX-compliant SQLite ledgers
- Full independence of all modules (`tbot_bot/`, `tbot_web/`) — the dashboard is optional

The bot is initialized by the accounting system, which:
- Injects a validated ledger and bot-specific Chart of Accounts (COA)
- Encrypts runtime configurations into `.env_bot.enc` (decrypted using `env.key`)
- Assigns broker, float cap, risk weights, and strategy overrides

All float movement and inter-entity transfers are externalized — TradeBot does **not** control float.  
Accounting handles float injections, transfers, and reserve enforcement.

Execution logic is governed using:
- `ALPACA_ENABLED`, `IBKR_ENABLED`, etc.
- `STRAT_OPEN_ENABLED`, `STRAT_MID_ENABLED`, `STRAT_CLOSE_ENABLED`

Ledger routing:
- All trades post directly to the accounting system’s OFX-compliant, entity-scoped SQLite ledgers:
  - `{ENTITY_CODE}_{JURISDICTION_CODE}_{account_name}_{BROKER_CODE}_{BOT_ID}_BOT_ledger.db`
- Ledger file paths are injected by the accounting system; the bot never hardcodes or selects its own ledger path
- Float tracking, PnL, and revenue transfer logging occur exclusively through accounting-managed ingestion
- TEST_MODE logic is deprecated; testing is handled via dedicated modules under `tbot_bot/test/`

==============================
System Instructions 
==============================

These instructions apply to all TradeBot build and debugging sessions. This section excludes directives already enforced by the global 8-step procedure.

1. All environment-specific values must be sourced from `.env`, `.env_enc`, `.env_bot`, or `.env_bot.enc`.
   - No hardcoded API keys, thresholds, credentials, toggles, file paths, or mode flags.
   - `DISABLED ≠ OMITTED` — all conditional logic must explicitly evaluate suppressed states.

2. Inline comments are mandatory in all generated code.
   - All logic branches, `.env_bot` references, and condition paths must be explained clearly.

3. All file paths must be relative and platform-agnostic.
   - Code must run unmodified across macOS, Linux, and production servers (e.g., DigitalOcean).

4. Ledger routing:
   - All trade activity must write to the accounting system’s OFX-compliant, entity-scoped SQLite ledger.
   - Ledger filenames must follow:
     `{ENTITY_CODE}_{JURISDICTION_CODE}_{account_name}_{BROKER_CODE}_{BOT_ID}_BOT_ledger.db`
   - Ledger path is injected by the accounting system — the bot must never determine it independently.
   - All ledger writes are preceded by a backup.
   - Test modules under `tbot_bot/test/` may simulate trade placement but **must never** alter or bypass production ledger logic.

5. No re-ingestion of `.csv` or `.json` logs is permitted.
   - These are external audit artifacts only — not transactional inputs.

6. Every strategy module must implement a `.self_check()` method.
   - `main.py` must halt execution if any `.self_check()` fails.
   - Failures must log: strategy, reason, and error context with UTC timestamp.

7. `env_bot.py` must validate all required keys from `.env_bot.enc`.
   - Decryption must use `storage/keys/env.key`.
   - Missing or malformed keys must raise a fatal, human-readable startup error.

8. Logs and ledger outputs must include:
   - `timestamp`, `strategy_name`, `ticker`, `side`, `size`
   - `entry_price`, `exit_price`, `PnL`
   - `broker`, `error_code` (if applicable)
   - All logs must follow the global `LOG_FORMAT` (CSV or JSON) from `.env_bot`.

9. `VERSION.md` is mandatory.
   - Must include version tag, structural changes, logic differences, and behavior deltas.

10. All modules must remain fully executable on their own.
    - Core logic (`tbot_bot/`) must never import from Flask or `tbot_web/`.
    - The web UI is optional and must not affect trading logic or risk behavior.

11. Strategy routing and broker enablement must be toggled exclusively via `.env_bot`:
    - `ALPACA_ENABLED`, `IBKR_ENABLED`
    - `STRAT_OPEN_ENABLED`, `STRAT_MID_ENABLED`, `STRAT_CLOSE_ENABLED`

12. Improvisation is forbidden.
    - Clarify ambiguities before code generation or modification.
    - Strictly enforce deterministic, auditable logic paths.

# ==============================
# .env – Top-Level Environment Configuration
# ==============================
# This file is parsed by tbot_bot/, tbot_web/, and related utility scripts.
# It references secure decryption keys only — no raw credentials are stored here.

# -----------------------------
# Core Environment Settings
# -----------------------------
ENVIRONMENT="production"             # production or development mode
LOCAL="true"                         # If running in local dev environment
CONTROL_DIR="control"
ENV_BOT_PATH=".env_bot"

# -----------------------------
# Server IP Binding (Optional)
# -----------------------------
LOCAL_IP="192.168.1.67"              # Optional: bind to a specific local IP
LOCAL_PORT="6900"                    # Port for local web access
REMOTE_IP="164.92.120.154"           # Optional: external IP
REMOTE_PORT="6900"                   # Port for external access or reverse proxy

# -----------------------------
# Encrypted Credential Keys
# -----------------------------
ENV_KEY_PATH="storage/keys/env.key"                  # Decrypts general bot config (.env_bot.enc)
LOGIN_KEY_PATH="storage/keys/login.key"              # Decrypts hashed passwords, session tokens
BROKER_KEY_PATH="storage/keys/broker.key"            # Decrypts broker_credentials.json.enc
SMTP_KEY_PATH="storage/keys/smtp.key"                # Decrypts smtp_credentials.json.enc
SCREENER_API_KEY_PATH="storage/keys/screener_api.key"  # Decrypts screener_api.json.enc
ACCT_API_KEY_PATH="storage/keys/acct_api.key"        # Decrypts acct_api_credentials.json.enc

# -----------------------------
# Encrypted Secrets (Resolved at Runtime)
# -----------------------------
BROKER_CREDENTIALS_PATH="storage/secrets/broker_credentials.json.enc"
SMTP_CREDENTIALS_PATH="storage/secrets/smtp_credentials.json.enc"
SCREENER_API_PATH="storage/secrets/screener_api.json.enc"
ACCT_API_CREDENTIALS_PATH="storage/secrets/acct_api_credentials.json.enc"


# -----------------------------
# Session / Login Controls
# -----------------------------
SESSION_TIMEOUT="3000"               # Default: 3000 seconds (50 minutes)
LOGIN_ATTEMPT_LIMIT=10               # Max failed login attempts before lockout
LOGIN_LOCKOUT_MINUTES=15             # Lockout duration in minutes
SESSION_TIMEOUT_MINUTES=120          # Session expiration duration (minutes)

# -----------------------------
# Accounting Bot Key Reference (Deprecated)
# -----------------------------
# ENV_BOT_KEY is deprecated — replaced by ENV_KEY_PATH above
# ENV_BOT_KEY="..."




================================================================================
# .env_bot – Trading Bot Configuration File
================================================================================
# .env_bot – TradeBot Configuration v1.0.0+
# All strategy logic, broker routing, and runtime behavior are driven by this file.
# Time values are specified in UTC. Comments indicate usage and system impact.

# -----------------------------------------
# General & Debugging
# -----------------------------------------

# Version tag (must match VERSION.md)
VERSION_TAG=v1.0.0

# debug or release – sets internal behavior and logging verbosity
BUILD_MODE=release

# Master kill switch to block all trading activity
DISABLE_ALL_TRADES=false

# Logging level: quiet, info, or verbose
DEBUG_LOG_LEVEL=verbose

# Enable writing log files to /logs and /backups
ENABLE_LOGGING=true

# json (structured) or csv (flat) log output format
LOG_FORMAT=json

# -----------------------------------------
# Trade Execution & Risk Controls
# -----------------------------------------

# If true, bot will wait for manual confirmation before sending trades
TRADE_CONFIRMATION_REQUIRED=false

# Number of times to retry failed broker API calls      
API_RETRY_LIMIT=3

# how many seconds before timeout 
API_TIMEOUT=30

# Allow fractional shares (broker must support)
FRACTIONAL=true

# Total capital allocated per strategy session (e.g., 2% of account)
TOTAL_ALLOCATION=0.02

# Max number of trades allowed per strategy window
MAX_TRADES=4

# Trade weight percentages based on number of triggered trades
WEIGHTS=0.4,0.2,0.2,0.2

# Absolute loss limit (e.g., 5% of capital); triggers shutdown
DAILY_LOSS_LIMIT=0.05

# Maximum allocation per trade based on account value (2.5%)
MAX_RISK_PER_TRADE=0.025

# Cap on total simultaneous positions across all strategies
MAX_OPEN_POSITIONS=5                   

# -----------------------------------------
# Price & Volume Filters
# -----------------------------------------

# Minimum price allowed per trade
MIN_PRICE=5

# Maximum price allowed per trade
MAX_PRICE=100

# Minimum volume filter 
MIN_VOLUME_THRESHOLD=1000000       

    

# -----------------------------------------
# Strategy Routing & Broker Mode
# -----------------------------------------

# Enable Alpaca broker integration
ALPACA_ENABLED=true

# Enable IBKR (Interactive Brokers) integration
IBKR_ENABLED=false


# Strategy run order; values: open, mid, close
STRATEGY_SEQUENCE=open,mid,close

# Optional: override normal order and run only one strategy
STRATEGY_OVERRIDE=

# -----------------------------------------
# Automated Rebalance Triggers
# -----------------------------------------

# Master toggle for automated rebalancing
REBALANCE_ENABLED=true     

# Trigger threshold (fractional, e.g., 0.10 = 10% deviation)              
REBALANCE_THRESHOLD=0.10     

# Check interval in seconds (default: 3600s = 1 hour)            
REBALANCE_CHECK_INTERVAL=3600           






# -----------------------------------------
# Failover Broker Routing
# -----------------------------------------

# Master toggle for failover routing
FAILOVER_ENABLED=true  
                  
# Tag applied to rerouted trades in logs/ledgers
FAILOVER_LOG_TAG=FAILOVER_ACTIVE         

# -----------------------------------------
# Real-Time Alerting / Incident Management
# -----------------------------------------

# Enable Slack alerts
SLACK_ALERT_ENABLED=true   
# Slack Incoming Webhook URL              
SLACK_WEBHOOK_URL=    
                   
# Enable PagerDuty incident triggers
PAGERDUTY_ALERT_ENABLED=true             

# PagerDuty API key
PAGERDUTY_API_KEY=                       

# Enable Twilio SMS alerts
TWILIO_ALERT_ENABLED=true   

# Twilio Account SID             
TWILIO_ACCOUNT_SID=  

# Twilio Auth Token                    
TWILIO_AUTH_TOKEN=   

# Twilio sender number (E.164 format)                    
TWILIO_FROM_NUMBER=  

# Recipient number for SMS alerts (E.164 format)                    
TWILIO_TO_NUMBER=                        




# -----------------------------------------
# Global Time & Polling
# -----------------------------------------

# Days allowed for trading (UTC-based control logic)
TRADING_DAYS=mon,tue,wed,thu,fri

# Interval between polling cycles for runtime monitoring
SLEEP_TIME=1s

# -----------------------------------------
# OPEN Strategy Configuration
# -----------------------------------------


# Maximum gap allowed from open to current price (used in screener)
MAX_GAP_PCT_OPEN=0.1

# Minimum and maximum market cap allowed for OPEN strategy candidates
MIN_MARKET_CAP_OPEN=2000000000
MAX_MARKET_CAP_OPEN=10000000000

# Enable or disable OPEN strategy
STRAT_OPEN_ENABLED=true

# UTC start time (market open = 9:30 AM EST)
START_TIME_OPEN=14:30

# Minutes to track high/low range before breakout
OPEN_ANALYSIS_TIME=20

# Minutes to for breakout to happen
OPEN_BREAKOUT_TIME=10

# Minutes to monitor active positions
OPEN_MONITORING_TIME=30

# Breakout threshold above high/low range (e.g., 2%)
STRAT_OPEN_BUFFER=0.02

# Shorting method: InverseETF, disabled, ShortSell, LongPut,
SHORT_TYPE_OPEN= InverseETF               

# -----------------------------------------
# MID Strategy Configuration (VWAP Reversion)
# -----------------------------------------

# Maximum gap allowed from open to current price (used in screener)
MAX_GAP_PCT_MID=0.1

# Minimum and maximum market cap allowed for MID strategy candidates
MIN_MARKET_CAP_MID=2000000000
MAX_MARKET_CAP_MID=10000000000


# Enable or disable MID strategy
STRAT_MID_ENABLED=true

# UTC start time (10:30 AM EST)
START_TIME_MID=15:30

# Minutes before trade signal is evaluated
MID_ANALYSIS_TIME=10

# Minutes to for breakout to happen
MID_BREAKOUT_TIME=10

# Maximum hold time after entry
MID_MONITORING_TIME=45

# VWAP deviation required to enter trade
STRAT_MID_VWAP_THRESHOLD=0.02

# Shorting method: InverseETF, ShortSell, LongPut,  or disabled
SHORT_TYPE_MID= InverseETF              

# -----------------------------------------
# CLOSE Strategy Configuration (EOD Momentum/Fade)
# -----------------------------------------

# Maximum gap allowed from open to current price (used in screener)
MAX_GAP_PCT_CLOSE=0.1

# Minimum and maximum market cap allowed for CLOSE strategy candidates
MIN_MARKET_CAP_CLOSE=2000000000
MAX_MARKET_CAP_CLOSE=10000000000


# Enable or disable CLOSE strategy
STRAT_CLOSE_ENABLED=true

# UTC start time (2:30 PM EST)
START_TIME_CLOSE=19:30

# Minutes to detect signal
CLOSE_ANALYSIS_TIME=10

# Minutes to for breakout to happen
CLOSE_BREAKOUT_TIME=10

# Duration to manage position after entry
CLOSE_MONITORING_TIME=30

# Min VIX level required to allow entry
STRAT_CLOSE_VIX_THRESHOLD=15

# Shorting method: InverseETF, ShortSell, LongPut, or disabled
SHORT_TYPE_CLOSE= InverseETF               

# -----------------------------------------
# Notifications
# -----------------------------------------

# Send email alert on trade entry
NOTIFY_ON_FILL=true

# Send email alert on trade exit
NOTIFY_ON_EXIT=true                    

# -----------------------------------------
# Reporting & Ledger Export
# -----------------------------------------

# auto = export after each trade, off = no export
LEDGER_EXPORT_MODE=auto


# -----------------------------------------
# Defense Mode (Disaster Risk Reduction)
# -----------------------------------------

# Set true if Disaster Protocol triggers; resets to false on recovery
DEFENSE_MODE_ACTIVE=false

# Percentage of normal MAX_CONCURRENT_TRADES allowed (rounded down)
DEFENSE_MODE_TRADE_LIMIT_PCT=66

# Maximum session allocation allowed during Defense Mode (e.g., 1%)
DEFENSE_MODE_TOTAL_ALLOCATION=0.01

# -----------------------------------------
# ENHANCEMENT MODULE TOGGLES 
# -----------------------------------------

# --- Rebalance Notification ---
ENABLE_REBALANCE_NOTIFIER=true
REBALANCE_TRIGGER_PCT=10                         # Notify accounting if float deviates ±10% from target

# --- Role-Based Web Access ---
RBAC_ENABLED=true                                # Enable multi-user roles in web dashboard
DEFAULT_USER_ROLE=viewer                         # Default role for new users

# --- Strategy Optimizer ---
ENABLE_STRATEGY_OPTIMIZER=true
OPTIMIZER_BACKTEST_LOOKBACK_DAYS=30              # Historical days for parameter tuning
OPTIMIZER_ALGORITHM=grid_search                  # Options: grid_search, bayesian, genetic
OPTIMIZER_OUTPUT_DIR=backtest_results/strategy_tuning/

# --- Real-Time Alerts ---
NOTIFY_ON_FILL=true
NOTIFY_ON_EXIT=true
NOTIFY_ON_FAILURE=true
CRITICAL_ALERT_CHANNEL=pagerduty                 # Options: email, slack, sms, pagerduty
ROUTINE_ALERT_CHANNEL=email                      # Options: email, slack

# --- Backtest Slippage Modeling ---
ENABLE_SLIPPAGE_MODEL=true
SLIPPAGE_SIMULATION_TYPE=randomized              # Options: none, rule_based, randomized
SLIPPAGE_MEAN_PCT=0.15                           # Average slippage %
SLIPPAGE_STDDEV_PCT=0.10                         # Standard deviation
SIMULATED_LATENCY_MS=500                         # Artificial delay (in milliseconds) per order

# --- Defense Mode Enhancements (if applicable) ---
DEFENSE_MODE_ACTIVE=false
DEFENSE_MODE_TOTAL_ALLOCATION=0.01
DEFENSE_MODE_TRADE_LIMIT_PCT=50







================================================================================
Overall Directory Structure Diagram (Accounting-System Integrated)
================================================================================

├── TradeBot-001/
│
│   # Core Metadata & Environment Config
│   ├── VERSION.md                       # Version change log for human or GPT reference
│   ├── CHANGELOG.md                     # Technical commit-style change history (optional)
│   ├── README.md                        # Project overview, architecture, and usage instructions
│   ├── requirements.txt                 # Python package dependencies
│
│   ├── .env                             # Global config (Flask port, encryption keys, login)
│   ├── .env_bot                         # Decrypted bot settings (overwritten each run if using encrypted version)
│   ├── .env_bot.template-test           # Example/test-mode config for cloning bots
│   ├── .scpignore_env                   # Excludes only env/config
│   ├── .scpignore_dev                   # Excludes test scripts, logs, debug files
│   ├── .scpignore_enc                   # Used when deploying encrypted-only configs
│   ├── .scpignore_prod_archive          # Used when deploying archive packages (no .env, no accounting ledgers, etc.)
│   │
│   ├── tools/				# Encryption / Auth Tools
│   │   ├── encrypt_password.py          # AES-encrypts login password and updates .env
│   │   ├── encrypt_env_bot.py           # Encrypts .env_bot and saves it as env_bot.enc
│   │   └── sync_project.sh              # CLI interface for dev→live→prod folder syncs
│   │
│   ├── backups/                         # Runtime Output / Audit Artifacts - Archived logs and reports (daily snapshots)
│   │   ├── logs_*.zip                   # Zipped logs (all modes)
│   │   └── summary_*.json               # JSON performance reports
│   │
│   ├── logs/                            # Active logging folder (rotated or zipped by auto_backup)
│   │   ├── bot/
│   │   │   └── sessions/                # Logs per strategy and session
│   │   └── web/			 # Web authentication and access logs — supports multi-user login, audit trails
│   │       ├── access.log               # IP/timestamp of each login request
│   │       └── auth_failures.log        # Failed login attempts, lockout triggers
│   │
│   ├── docs/				# Internal Documentation
│   │   ├── architecture.md              # System architecture and module breakdown
│   │   ├── API_reference.md             # CLI & internal API details (optional)
│   │   └── security_notes.md            # Data handling, encryption key roles, etc.
│   │
│   └── scripts/			# Automation Scripts
│       ├── sync_to_accounting.py        # Pushes trade data to accounting system ledger ingestion module
│       ├── audit_log_parser.py          # CLI utility to review logs and summarize behavior
│       └── upload_backups_to_cloud.sh   # Syncs backups/ to external vault or S3

├── tbot_bot/                             # Core engine for execution, strategy logic, reporting, and control
│   ├── __init__.py
│   │   
│   ├── accounting/				# Accounting Integration
│   │   ├── account_transaction.py           # Generic transaction entry builder for accounting system ingestion
│   │   ├── accounting_api.py                # Routes trade output to accounting system ingestion pipeline
│   │   ├── accounting_config.py             # Controls ledger integration settings
│   │   ├── ledger_schema.py                 # Defines account hierarchy/types for ledger compliance (OFX-aligned)
│   │   └── tradebot_ledger_schema.sql	     # Reference schema — mirrors accounting system tables
│   │
│   
│   ├── backtest/			# Backtesting & Research
│   │   ├── backtest_engine.py           # Core simulator to replay past trades
│   │   ├── load_historical_data.py      # Load from CSV, OHLCV, or tick sources
│   │   ├── performance_metrics.py       # Computes performance metrics (Sharpe, win %, drawdown)
│   │   └── plot_results.py              # Graphs equity curves, trades, and heatmaps
│   │
│   ├── broker/
│   │   ├── broker_api.py           # Unified interface: routes calls to selected broker adapter based on .env_bot
│   │   └── brokers/                # Broker-specific adapters, all conforming to the same interface contract
│   │       ├── __init__.py         # Enables package import and optional dynamic broker loading
│   │       ├── alpaca.py           # Alpaca implementation: REST/WebSocket order placement, account queries
│   │       ├── ibkr.py             # IBKR implementation: TWS/Gateway client with async fallback and reconnect
│   │       ├── tradier.py          # Tradier implementation: REST-only order flow with manual position sync
│   │       └── robinhood.py        # Robinhood implementation: unofficial API support (not for production)
│   │
│   ├── config/				# Configuration & Security
│   │   ├── env_bot.py                    # Validates and parses .env_bot
│   │   ├── error_handler.py             # Centralized exception manager and logging
│   │   ├── security_bot.py              # Encrypts/decrypts .env_bot to .env_bot.enc
│   │   └── settings_bot.py              # Programmatic editor for .env_bot values
│   │
│   ├── control/			# Control Signals (Web/CLI)
│   │   ├── control_start.txt            # Start flag file to trigger bot launch
│   │   └── control_stop.txt             # Stop flag file to trigger safe shutdown
│   │
│   ├── /core/
│   │   ├── databases/
│   │   │   ├── LEDGER_STATUS.db                  	# Tracks system-wide ledger states (e.g., locked, open)
│   │   │   ├── PASSWORD_RESET_TOKENS.db           # Stores one-time password reset tokens and expiry timestamps
│   │   │   ├── SYSTEM.db                         	# Core system constants and bot-wide settings (independent of accounting system)
│   │   │   ├── SYSTEM_LOGS.db                    	# Centralized system event and audit logs
│   │   │   ├── SYSTEM_USERS.db  			# Sole source of truth for all login/authentication; replaces static user_identity
│   │   │   └── USER_ACTIVITY_MONITORING.db        # Maintains master list of user activity (IP, session, browser)
│   │   │
│   │   ├── schemas/
│   │   │   ├── ledger_status_schema.sql           # SQL schema for ledger status tracking table
│   │   │   ├── password_reset_schema.sql          # SQL schema for password reset token storage
│   │   │   ├── system_logs_schema.sql             # SQL schema for system logs table
│   │   │   ├── system_schema.sql                  # SQL schema for core system configuration
│   │   │   ├── system_users_schema.sql            # SQL schema for system users table
│   │   │   └── user_activity_monitoring_schema.sql # SQL schema for user activity monitoring (audit trail, access logs)
│   │   │
│   │   └── scripts/
│   │       ├── init_ledger_status.py              # Initializes ledger status database
│   │       ├── init_password_reset_tokens.py      # Initializes password reset token database
│   │       ├── init_system_logs.py                # Initializes system logs database
│   │       ├── init_system_users.py               # Initializes system users database
│   │       ├── init_system.py                     # Initializes core system configuration database
│   │       ├── init_user_activity_monitoring.py   # Initializes user activity monitoring database
│   │       └── verify_all_core_databases.py       # Connects to each core database, lists tables, and prints them to confirm initialization
│   │ 
│   │
│   ├── enhancements/			# Enhancements (Optional Guards & Filters)
│   │   ├── adx_filter.py                # Blocks trades during trending ADX
│   │   ├── bollinger_confluence.py      # Confirms entries with Bollinger alignment
│   │   ├── build_check.py               # Validates pre-launch config and file integrity
│   │   ├── imbalance_scanner_ibkr.py    # IBKR imbalance feed for close strategy gating
│   │   ├── ticker_blocklist.py          # Blocks duplicate ticker usage in one session
│   │   └── vix_gatekeeper.py            # VIX-based gating logic
│   │
│   ├── output/					 # Output Artifacts
│   │   ├── logs/                           # Unified strategy logs
│   │   │   ├── open.log
│   │   │   ├── mid.log
│   │   │   ├── close.log
│   │   │   ├── unresolved_orders.log
│   │   │   └── error_tracebacks.log
│   │   │   
│   │   ├── ledgers/  
│   │   │   ├── {ENTITY_CODE}_{JURISDICTION_CODE}_{account_name}_{BROKER_CODE}_{BOT_ID}_BOT_COA.db       			# COA for bot ledger (per broker)
│   │   │   ├── {ENTITY_CODE}_{JURISDICTION_CODE}_{account_name}_{BROKER_CODE}_{BOT_ID}_BOT_ledger.db    			# OFX-compliant ledger for live trading data per broker
│   │   │   └── {ENTITY_CODE}_{JURISDICTION_CODE}_{account_name}_{BROKER_CODE}_{BOT_ID}_BOT_FLOAT_ledger.db                 # Dedicated float ledger: tracks injections, limits, drain points per bot
│   │   │
│   │   ├── summaries/
│   │   │   └── daily_summary.json          # JSON performance summary for session
│   │   │
│   │   └── trades/
│   │       ├── trade_history.csv           # All trade data for session (raw)
│   │       └── trade_history.json          # Structured trade records for ingestion
│   │
│   ├── reporting/			# Reporting & Logging
│   │   ├── auto_backup.py               # Compresses and archives /output after session
│   │   ├── daily_summary.py            # Builds trade summary stats and outcomes
│   │   ├── log_rotation.py             # Cleans output folder after N days
│   │   ├── report_router.py            # Routes finalized trade output to loggers and accounting
│   │   ├── session_report.py           # Session wrap-up summary writer
│   │   ├── status_logger.py            # Syncs bot state to UI (optional)
│   │   └── trade_logger.py             # Records trade data to output/trades
│   │
│   ├── runtime/			# Session Lifecycle
│   │   ├── __init__.py
│   │   ├── main.py                      # Master controller (boot → trade → shutdown)
│   │   ├── start_bot.py                 # CLI entry point
│   │   ├── status_bot.py                # Tracks session state and health
│   │   ├── stop_bot.py                  # Graceful session shutdown
│   │   ├── tbot_runner_supervisor.py   # Oversees full lifecycle and watchdogs
│   │   └── watchdog_bot.py              # Broker connection monitor
│   │
│   ├── screeners/			# Screener & Symbol Selection
│   │   └── finnhub_screener.py          # Symbol scanner via Finnhub API
│   │
│   ├── storage/
│   │   ├── backups/                             # Daily ledger backups (timestamped snapshots)
│   │   │   └── YYYY-MM-DD/
│   │   ├── exports/                             # Daily export snapshots
│   │   │   └── YYYY-MM-DD/
│   │   ├── keys/                                # Encryption keys (excluded from deployments for security)
│   │   │   ├── .keep                            # Placeholder to retain keys folder in version control
│   │   │   ├── acct_api.key                     # Used to call secure endpoints in accounting system
│   │   │   ├── broker.key                       # Fernet key for encrypting/decrypting broker credentials (Alpaca, IBKR, etc.)
│   │   │   ├── env.key                          # Decrypts general bot config
│   │   │   ├── login.key                        # bcrypt/Fernet keys for passwords, reset tokens, and non-password use cases
│   │   │   ├── screener_api.key                 # Fernet key for decrypting Finnhub or other screener API keys
│   │   │   └── smtp.key                         # Fernet key for decrypting SMTP login and host data
│   │   │
│   │   ├── secrets/                             # Encrypted configuration files for credentials and tokens
│   │   │   ├── acct_api_credentials.json.enc     # contains Token or credentials to call accounting system endpoints
│   │   │   ├── broker_credentials.json.enc       # Contains ALPACA + IBKR credentials (API keys, usernames, passwords, URLs)
│   │   │   ├── smtp_credentials.json.enc         # contains SMTP_USER, PASS, HOST, PORT
│   │   │   └── screener_api.json.enc             # contains FINNHUB_API_KEY or other screener access tokens
│   │   │
│   │   └── migration_archives/                              
│   │
│   ├── strategy/			# Strategy Logic
│   │   ├── strategy_close.py            # End-of-day logic (momentum/fade)
│   │   ├── strategy_meta.py             # Thresholds and constants
│   │   ├── strategy_mid.py              # VWAP-based logic
│   │   ├── strategy_open.py             # Opening range breakout
│   │   └── strategy_router.py           # Directs execution based on time/config
│   │
│   ├── support/			 # Support
│   │   ├── .env_bot.enc                 # Encrypted runtime config
│   │   ├── decrypt_secrets.py             # Loads and decrypts .json.enc files using corresponding Fernet keys
│   │   ├── utils_bot.py                 # Shared helpers
│   │   └── service_bot.py               # Optional daemon listener (e.g. systemd)
│   │
│   ├── test/					# Test Suite
│   │   ├── integration_test_runner.py         # Simulates a full bot session from init to shutdown in TEST_MODE
│   │   ├── test_backtest_engine.py            # Validates backtest results against known metrics and equity curves
│   │   ├── test_env_bot.py                    # Verifies .env_bot structure, required fields, and parsing logic
│   │   ├── test_logging_format.py             # Ensures all log entries follow required format and completeness
│   │   ├── test_main_bot.py                   # Tests session lifecycle logic and file triggers (start/stop)
│   │   ├── test_strategy_selfcheck.py         # Asserts that all strategy modules pass .self_check() requirements
│   │   ├── test_screener_random.py            # Runs screener logic with randomized symbols to confirm filtering and eligibility logic
│   │   ├── test_broker_trade_stub.py          # Sends randomized micro-trades to broker in TEST_MODE to validate order flow, response, and logging
│   │   └── test_strategy_tuner.py             # Executes strategy modules in isolation with test tickers to validate signal logic, threshold configs, and entry/exit paths
│   │
│   └── trading/			# Trade Execution
│       ├── float_bot.py                 # Allocates float from accounting config
│       ├── kill_switch.py               # Triggers shutdown on loss violation
│       ├── logs_bot.py                  # Runtime logging of trade ops
│       ├── notifier_bot.py              # Email/Slack alerts
│       ├── orders_bot.py                # Order submission logic
│       ├── reporting_bot.py             # Pushes trades to accounting system
│       └── risk_bot.py                  # Risk enforcement engine
│   
└── tbot_web/                             # Web dashboard for monitoring, logs, and control
    ├── assets/                           # Static frontend resources
    │   ├── fnt/                          # Embedded fonts used in the interface
    │   └── css/
    │       ├── main.css                  # Core layout and UI styling rules
    │       └── theme.css                 # Optional theme layer (e.g. light/dark modes)
    ├── favicon.ico / favicon.gif         # Site icon for browser tab
    ├── py/                               # Flask backend for web UI and bot interaction
    │   ├── __init__.py                   # Registers Flask blueprints for all routes
    │   ├── auth_web.py                   # AES decryption for login password validation
    │   ├── login_web.py                  # Login/logout route handling with rate limit enforcement
    │   ├── logs_web.py                   # Displays latest bot log output to the web UI
    │   ├── main_web.py                   # Web router and load shell for dashboard interface
    │   ├── portal_web.py                 # Flask app factory for app + static + template setup
    │   ├── run_web.py                    # Webserver launcher for local or remote access
    │   ├── settings_web.py               # Updates .env_bot config via web interface (no trading logic)
    │   ├── start_stop_web.py             # Writes control_start.txt / control_stop.txt to signal bot lifecycle
    │   └── status_web.py                 # Displays bot state from status.json (read-only)
    ├── robots.txt                        # Blocks bots and search engine indexing (security)
    └── templates/                        # HTML UI templates rendered with Jinja2
        ├── index.html                    # Login screen rendered via Jinja2
        ├── main.html                     # Dashboard shell with embedded strategy/log/status panels
        ├── logs.html                     # Real-time log display (read-only)
        ├── settings.html                 # Web form for updating bot config (.env_bot)
        └── status.html                   # Bot health and strategy state view from status.json



================================================================================
Deployment Notes (Updated)
================================================================================

- All file paths must be **relative and platform-agnostic**, ensuring compatibility across macOS, Linux, and cloud servers (e.g., DigitalOcean).
- The `tbot_bot/` module must operate **fully independently**, even if `tbot_web/` (Flask UI) is disabled or unavailable.
- All logs, ledger exports, and backup behavior must remain active regardless of whether the web interface is enabled.
- On first deployment, enable **only one broker** (`ALPACA_ENABLED=true` or `IBKR_ENABLED=true`, etc.).
- At startup, all enabled brokers must validate their API credentials from `.env`. Missing, malformed, or unauthorized keys must trigger a hard stop.
- Strategy activation is controlled independently using:
  - `STRAT_OPEN_ENABLED`
  - `STRAT_MID_ENABLED`
  - `STRAT_CLOSE_ENABLED`
- Before placing trades, the bot must validate:
  - Market spread: abort if spread > 1.5% of `entry_price`
  - Volume threshold: abort if average daily volume < `MIN_VOLUME_THRESHOLD`
  - Risk: ensure `MAX_RISK_PER_TRADE` and `DAILY_LOSS_LIMIT` are not violated
- Auto-shutdown must occur if:
  - The broker API is offline (`watchdog_bot.py`)
  - A critical error is caught by `error_handler.py`
  - Cumulative losses exceed `DAILY_LOSS_LIMIT` (triggered via `kill_switch.py`)
- All ledger writes must go directly to the accounting system’s entity-specific SQLite file:
  - Format: `entities/{ENTITY}_{JURIS}_{account}_{BROKER}_{BOT_ID}_BOT_ledger.db`
- All ledger writes are preceded by a timestamped backup using the accounting system’s `backup_ledgers.py` script, stored under `entities/{ENTITY}_{JURIS}/backups/`.
- Ledger exports are generated only by the accounting system’s `/export/generate_ofx.py` module.
- Session logs are saved under `/output/logs/`, such as:
  - `/output/logs/open.log`
  - `/output/logs/mid.log`
  - `/output/logs/close.log`
  - `/output/logs/unresolved_orders.log`
- Logs and summaries may be zipped and archived post-session using the `auto_backup.py` script.
- All backups may optionally be synced to external storage (e.g., S3, Dropbox, FTP) via:
  - `scripts/upload_backups_to_cloud.sh`
- Ensure that the backup process does not interfere with live ledger writes and that all archives are timestamped to prevent conflict.
- Strategy timing and trade session control is managed via `.env_bot` using:
  - `START_TIME_OPEN`, `START_TIME_MID`, `START_TIME_CLOSE`
  - `[STRAT]_ANALYSIS_TIME` and `[STRAT]_MONITORING_TIME` per strategy
- All runs must respect `TRADING_DAYS` to prevent execution on weekends or holidays.


================================================================================
Current Platforms (Updated for Single Broker + Accounting System)
================================================================================

Development Environment:
- Local testing and version control are performed on macOS 15.2 with Python 3.11+
- All code must be compatible with macOS and Linux (no platform-specific imports or absolute paths)
- Recommended IDE: Visual Studio Code with Black or Ruff for formatting and linting
- Python scripts are executed via terminal or cron — not from GUI IDEs
- Local logs and test exports are saved to `logs/bot/sessions/` and `backups/`

Production Deployment:
- Hosted on a DigitalOcean droplet running Ubuntu 22.04 LTS
- Code is deployed via secure SCP/SFTP or git pull into production branch
- Execution is initiated using:
  - `start_bot.py` (manual or cron trigger)
  - `service_bot.py` (optional systemd daemon listener)
- All runtime logs and summaries are saved to:
  - `output/logs/*.log` — strategy logs and unresolved trades
  - `output/summaries/` — daily performance summaries
  - `output/trades/` — structured CSV/JSON trade records

Broker Integrations:
- Only one broker may be enabled at a time per bot instance
- Broker selection and credentials are managed by the accounting system and injected into `.env_bot`
- Supported brokers (modularized under `tbot_bot/broker/brokers/`):
  - Alpaca (default for equities)
  - Interactive Brokers (preferred for ETFs and long puts)
  - Tradier and Webull (test only, not validated for production)
- All brokers must pass startup `.self_check()` in their adapter to proceed

Market Data Services:
- Finnhub API is used for all symbol screening (`screeners/finnhub_screener.py`)
- Pre-market, intraday, and after-hours scans are supported
- Screeners apply volume, float, price, and gap filters based on `.env_bot` settings

Accounting Integration:
- The accounting system handles all ledger writes, audit trails, and exports
- All trades are routed through `accounting_api.py` and recorded to:
  - `{ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_ledger.db`
- Ledger structure is defined in `ledger_schema.py`, aligned to OFX 1.x/2.x
- Exports are performed using the accounting system’s `generate_ofx.py` script
- TradeBot does not write .csv exports directly for ledger use — all ingestion is internalized

Web Interface:
- `tbot_web/`: Flask-based dashboard for live monitoring, status, and manual control
- Supports:
  - Encrypted login (AES key in `.env`)
  - Config editing via UI form
  - Log viewing and bot status display via `status.json`
  - Start/Stop triggers via `control_start.txt` and `control_stop.txt`

Alerting & Notifications:
- Email alerts are optional and configured in `.env`:
  - `NOTIFY_ON_FILL=true` → trade entry alerts
  - `NOTIFY_ON_EXIT=true` → position exit alerts
- SMTP is provided by DreamHost or another third-party, credentials managed in `.env`

Security:
- `.env_bot` is encrypted into `.env_bot.enc` using `tools/encrypt_env_bot.py`
- AES key is stored in `.env` as `ENV_BOT_KEY`
- Encrypted files are excluded from version control via `.scpignore_*` rules

Backup Synchronization:
- All logs and ledger backups are encrypted and archived using `auto_backup.py`
- Files are stored under `backups/` and can be uploaded via `upload_backups_to_cloud.sh`
- Secondary replication is recommended for high-availability use (e.g., FTP, S3, ProtonVault)

Deployment Verification:
- All production setups must pass a dry-run integration test before first live trade
- Confirm the following:
  - Broker API startup success
  - Trade log writing
  - Ledger entry generation
  - Strategy timing and exit triggers
  - Notification dispatch (if enabled)

Redundancy & Recovery:
- All backups must be timestamped and encrypted
- Daily logs, ledgers, and summaries should be mirrored to a secondary vault at end-of-session
- Periodic integrity checks on `backups/` ensure restore capability under failure or audit


================================================================================
Time Zone Standards
================================================================================

Overview:
To ensure consistency, accuracy, and interoperability across development, testing, and production environments, all time-related variables in TradeBot are defined and logged in UTC (Coordinated Universal Time).

Usage:
- All strategy start times (`START_TIME_OPEN`, `START_TIME_MID`, `START_TIME_CLOSE`) are set in UTC
- Log timestamps, strategy triggers, ledger entries, and alerts must all use UTC
- All ledger entries written into `entities/TB_ledger.db` must record `DTPOSTED` and all OFX-required timestamps in UTC
- Internal time comparisons in `strategy_router.py` and `status_bot.py` must convert local system time to UTC before logic execution

Reasoning:
- UTC avoids ambiguity across time zones, daylight saving time shifts, or server environments (macOS, Linux, cloud)
- Ensures OFX export compliance and accurate cross-entity reconciliation across ledgers
- Allows reliable scheduling when hosting in geographically distributed environments (e.g., DigitalOcean, AWS)
- Compatible with broker API timestamps and log analysis pipelines

Example Mapping:
- 14:30 UTC → 9:30 AM EST (Market Open)
- 15:30 UTC → 10:30 AM EST (Midday Strategy)
- 19:30 UTC → 2:30 PM EST (Close Strategy)

Implementation Tip:
If debugging locally in EST or PST, always convert timestamps before interpreting logs or database entries.

Best Practice:
Add a helper function in `utils_bot.py`:
```python
def utc_now():
    return datetime.utcnow().replace(tzinfo=timezone.utc)


================================================================================
RIGD Trading Bot – Infrastructure and Deployment Overhaul Instructions (UPDATED)
================================================================================

OBJECTIVE:
Continue deployment of the RIGD Trading Bot system on the newly provisioned DigitalOcean droplet using:
- Shared CPU (Premium AMD) plan
- Ubuntu 22.04 LTS
- Full systemd-managed architecture
- Hardened, secure deployment best practices

--------------------------------------------------------------------------------
PHASE 1: DROPLET PROVISIONING (COMPLETE)
--------------------------------------------------------------------------------

Provisioned Droplet Settings:
- Region: nyc3
- Plan: Shared CPU – Premium AMD (2 vCPU, 4 GB RAM, 80 GB NVMe SSD)
- OS: Ubuntu 22.04 LTS
- Tags:
    - rigd
    - tb
    - nyc3
    - systemd
    - primary
- SSH Key: `id_ed25519` (renamed from `rigd_tbot_key` for default SSH use)
- Status: SSH access, DNS configuration, and firewall are active

Do NOT enable backups. All backup logic is handled by systemd timers and nightly sync.

--------------------------------------------------------------------------------
PHASE 2: SERVER HARDENING AND BASELINE SETUP (COMPLETE)
--------------------------------------------------------------------------------

Hardened configuration:
- Created non-root user: `tbot`
- Disabled root SSH login and password authentication
- Installed fail2ban, UFW firewall, and automatic security updates
- Timezone set to UTC
- Python 3.10+, pip, venv, sqlite3, rsync, curl, and git installed

Working directory:
- Changed to: `~/rigdtb/tbot` (not `/opt/tbot`)
- Virtualenv installed in `~/rigdtb/venv`
- All bot source code will reside in `~/rigdtb/tbot/`

--------------------------------------------------------------------------------
PHASE 3: SYSTEMD UNIT DEPLOYMENT (IN PROGRESS)
--------------------------------------------------------------------------------

Create and deploy the following `systemd` units (under `/etc/systemd/system/`):

- `tbot.target` (parent target unit)
- `tbot-open.service` (9:30–9:50 UTC strategy)
- `tbot-mid.service` (12:00–12:30 UTC strategy)
- `tbot-close.service` (15:45–16:00 UTC strategy)
- `tbot-monitor.service` (trailing stop loop, ~30 min)
- `tbot-backup.service` + `tbot-backup.timer` (daily backup to Iceland server)
- `tbot-sync.service` + optional `tbot-sync.timer` (log/ledger push)

Requirements:
- All services run as `tbot` user
- Use `Restart=on-failure`
- Define `WorkingDirectory=/home/tbot/rigdtb/tbot`
- Use `ExecStart` to launch the correct strategy script
- Log to journald
- Optionally load environment from `/etc/tbot.env`

All `.timer` units:
- Must use `OnCalendar=...`
- Must set `Persistent=true`

--------------------------------------------------------------------------------
PHASE 4: LOGGING, BACKUPS, AND INTEGRATION (NEXT)
--------------------------------------------------------------------------------

- Create: `~/rigdtb/scripts/backup_bot_to_iceland.sh`
    - Include logfiles, SQLite ledger, config snapshots
    - Compress, rsync to Iceland backup server
    - Auto-clean local backups > 7 days old

- (Optional) Mirror `.tbot.db` and logs to `/mnt/shared` or future DR target

- Confirm all operations via `journalctl` and `systemctl status`

--------------------------------------------------------------------------------
PHASE 5: VALIDATION AND LIVE-CHECK
--------------------------------------------------------------------------------

- Run `systemctl list-timers` to confirm timers active
- Check `systemctl status tbot.target` for full stack status
- Simulate trade and trailing-stop trigger
- Confirm remote backup delivery post-close
- Kill and auto-restart a `tbot-monitor.service` to test resilience

--------------------------------------------------------------------------------
CRITICAL RULES
--------------------------------------------------------------------------------

- NO bot services run outside `systemd`
- NO `cron` allowed — purge if present
- NO root SSH logins permitted
- NO TEST_MODE divergence unless explicitly flagged



=============================================================================================================================================
RIGD GROUP LLC — Unified Capital Risk Controls and Dynamic Broker Float Allocation 
=============================================================================================================================================
Overview:
RIGD Group LLC (RGL) must dynamically allocate trading float, enforce strict risk controls, and ensure per-session risk discipline across sequentially executed strategies (OPEN, MID, CLOSE).

The system must dynamically adapt as capital grows, broker-specific API requirements evolve, or risk parameters are changed via `.env_bot`.

All constants and thresholds must be sourced from `.env_bot` environment variables — no hardcoded limits permitted.

Core Trading Risk Controls:
Risk per Strategy Session (TOTAL_ALLOCATION):
Each strategy session (OPEN, MID, CLOSE) must risk no more than the value of `TOTAL_ALLOCATION` from `.env_bot`, expressed as a fraction of the executing broker’s available float (as recorded by the accounting system).

Formula:
`session_risk_cap = broker_current_float * TOTAL_ALLOCATION`

The session allocation is divided among active trades using the `WEIGHTS` array defined in `.env_bot`.

Important Notes:
- `TOTAL_ALLOCATION` applies to the entire session, not to individual trades.
- Each trade receives a fractional share of the session allocation based on `WEIGHTS`.

Example Allocation (Per Broker, Per Session):

Number of Signals    Weight Split (From WEIGHTS)    Risk Allocation  
1 signal             100%                           100% of session allocation  
2 signals            60% / 40%                      60%, 40% of session allocation  
3 signals            40% / 30% / 30%                40%, 30%, 30% of session allocation  
4 signals            40% / 20% / 20% / 20%          40%, 20%, 20%, 20% of session allocation  

(Actual weight values sourced from the `WEIGHTS` setting.)

Example (Assuming Defaults):
- Broker float = $2,500  
- `TOTAL_ALLOCATION = 0.02`  
- 2% session cap = $50  
- Split according to current `WEIGHTS`

Maximum Concurrent Open Positions (`MAX_OPEN_POSITIONS` and `MAX_TRADES`):
- No more than `MAX_TRADES` trades may be opened during any single strategy session per broker.
- Total open positions across all strategies must not exceed `MAX_OPEN_POSITIONS`, as defined in `.env_bot`.

Trade Allocation Weights (`WEIGHTS`):
- Defined in `.env_bot`.
- Determines how `TOTAL_ALLOCATION` is divided among active trades during a session.
- Must have as many entries as the maximum number of possible trades (`MAX_TRADES`).

Daily Loss Limit (`DAILY_LOSS_LIMIT`):
Each broker independently tracks cumulative realized PnL relative to its own float.

Formula:
`broker_daily_loss_limit_usd = broker_current_float * DAILY_LOSS_LIMIT`

If a broker’s realized losses breach this limit:
- Only that broker’s trading is halted for the remainder of the day.
- Other brokers continue trading unless they individually breach their own `DAILY_LOSS_LIMIT`.

Ledger and Accounting Integration:
- All broker float, trade activity, and PnL changes must post directly to the accounting system’s entity-specific ledgers.
- The accounting system owns all float logic: bot reads only `broker_current_float`.
- Float injections and returns (e.g., Mercury ACH transfers) must:
  - Pass through the accounting system’s ingestion pipeline and cross-entity sync handler
  - Generate immutable double-entry records in both source and destination ledgers
  - Include OFX-compliant fields: `TRNTYPE`, `DTPOSTED`, `FITID`, and ACH reference number
  - Be validated and reconciled post-transfer to ensure ledger and Mercury account consistency
- Automated Mercury balance pulls (if supported) should verify that internal float records match actual account balances

Rebalancing and Transfer Protocol:
- Rebalancing logic is managed by the accounting system and executed outside the bot
- The bot will automatically use the most recent float on session start — no rebalancing logic exists in the bot
- Manual or scheduled rebalancing is supported at the accounting level if float deviates more than 10% from target

Scaling and Compounding:
- Broker floats, session risk caps, and trade sizing automatically scale based on RGL’s total capital and accounting float values
- No manual recalibration is permitted unless explicitly authorized and reflected via updated `.env_bot` values

Enforcement Modules:

Module             Responsibility  
`risk_bot.py`      Enforces session risk caps (`TOTAL_ALLOCATION`), `WEIGHTS`-based trade allocation, `MAX_TRADES`, `MAX_OPEN_POSITIONS`, and monitors per-broker PnL  
`kill_switch.py`   Halts trading at individual brokers when `DAILY_LOSS_LIMIT` thresholds are breached  
`watchdog_bot.py`  Monitors API and server infrastructure stability, disabling broker trading on infrastructure failure  

All controls apply equally in both test and live environments.  
Manual overrides are strictly prohibited unless explicitly authorized and properly reflected in `.env_bot`.


=============================================================================================================================================
TradeBot Strategy Logic Spec v1.1 (Updated for Accounting System Integration)
=============================================================================================================================================

Overview:
TradeBot executes intraday breakout and reversion strategies using a unified logic pipeline. All entries are directional and follow structured risk, time, and allocation parameters.

Supported Instruments:
- Long equity (common stocks or ETFs)
- Inverse ETFs (e.g., SH, SQQQ)
- Long puts (IBKR only)

Trade Direction Rules:
- Long trades = supported on all brokers
- Bearish trades = only executed if `SHORT_TYPE_*` is not `disabled`
- Puts = only used if broker = IBKR and `SHORT_TYPE_*` = LongPut
- Inverse ETFs = fallback for non-options brokers when `SHORT_TYPE_*` = InverseETF

Supported Brokers:
- Alpaca: long equity, inverse ETFs
- IBKR: long equity, inverse ETFs, long puts
- Tradier: long equity, inverse ETFs
- Webull: read-only (screening only)
- Robinhood: reserved for future support

Execution Framework:
- Strategy execution is controlled via `STRATEGY_SEQUENCE` in `.env_bot`
- Each strategy module is loaded independently by `strategy_router.py`
- Runtime logic respects UTC windows and `.env_bot` timing variables
- When `TEST_MODE=true`, strategy windows are compressed and symbol scan duration is capped at 1 minute

Ledger and Accounting Integration:
- All trade activities, allocations, and PnL updates must be written directly into:
    - `entities/TBL_ledger.db` 

- All ledger entries follow the OFX-compliant schema with:
    - `TRNTYPE`, `DTPOSTED`, `FITID`, broker, strategy, ticker, side, size, entry price, exit price, PnL, and audit references.
- No `.manager` or external accounting files are used; all reporting and reconciliation flow through the accounting system’s ingestion modules.

Active Strategies:

---------------------------------------------------------
Strategy: strategy_open.py – Opening Range Breakout
---------------------------------------------------------
- Time Window:
  - Start: `START_TIME_OPEN` (14:30 UTC = 9:30 AM EST)
  - Analysis phase: `OPEN_ANALYSIS_TIME` minutes
  - Breakout phase: `OPEN_BREAKOUT_TIME` minutes
  - Trade management: `OPEN_MONITORING_TIME` minutes
- Trade Direction: Long by default; short only if `SHORT_TYPE_OPEN` ≠ `disabled`
- Entry Logic:
  - Track high/low during analysis
  - Enter if price > high * (1 + `STRAT_OPEN_BUFFER`) or < low * (1 - `STRAT_OPEN_BUFFER`)
  - Must occur within breakout window
- Exit Logic:
  - 2% trailing stop or monitoring timeout
- Shorting:
  - Controlled via `SHORT_TYPE_OPEN`: InverseETF, LongPut, ShortSell, or disabled
- Logging:
  - Logs: `open.log
  - Ledger: `entities/TB_ledger.db`
  - Trade History: `trade_history_*.csv/json`

-----------------------------------------
Strategy: strategy_mid.py – VWAP Mean Reversion
-----------------------------------------
- Time Window:
  - Start: `START_TIME_MID` (15:30 UTC = 10:30 AM EST)
  - Analysis phase: `MID_ANALYSIS_TIME` minutes
  - Breakout phase: `MID_BREAKOUT_TIME` minutes
  - Trade management: `MID_MONITORING_TIME` minutes
- Trade Direction: Long or Bearish
- Entry Logic:
  - Enter on deviation from VWAP ±`STRAT_MID_VWAP_THRESHOLD`
  - Confirm via ADX and Bollinger filters
  - Entry must be within breakout window
- Exit Logic:
  - VWAP touch, 1.5% stop loss, or timeout
- Shorting:
  - Controlled via `SHORT_TYPE_MID`: InverseETF, LongPut, ShortSell, or disabled
- Enhancements:
  - `adx_filter.py`, `bollinger_confluence.py`
- Logging:
  - Logs: `mid.log` 
  - Ledger: `entities/TB_ledger.db` 
  - Trade History: `trade_history_*.csv/json`
-----------------------------------------
Strategy: strategy_close.py – End-of-Day Momentum / Fade
-----------------------------------------
- Time Window:
  - Start: `START_TIME_CLOSE` (19:30 UTC = 2:30 PM EST)
  - Analysis phase: `CLOSE_ANALYSIS_TIME` minutes
  - Breakout phase: `CLOSE_BREAKOUT_TIME` minutes
  - Trade management: `CLOSE_MONITORING_TIME` minutes
- Trade Direction: Long or Bearish
- Entry Logic:
  - Enter on momentum continuation or spike reversal
  - Requires VIX > `STRAT_CLOSE_VIX_THRESHOLD`
  - Must occur within breakout window
- Exit Logic:
  - 2% stop loss or hard exit at session end
- Shorting:
  - Controlled via `SHORT_TYPE_CLOSE`: InverseETF, LongPut, ShortSell, or disabled
- Enhancements:
  - `vix_gatekeeper.py`, `imbalance_scanner_ibkr.py`, `ticker_blocklist.py`
- Logging:
  - Logs: `close.log` 
  - Ledger: `entities/TB_ledger.db` 
  - Trade History: `trade_history_*.csv/json`

-----------------------------------------
Strategy Failover Logic
-----------------------------------------
- Any `.self_check()` failure skips the strategy
- If `STRATEGY_OVERRIDE` is set (e.g., `mid`), only that strategy runs
- All execution respects global constraints:
  - `DISABLE_ALL_TRADES`
  - `DAILY_LOSS_LIMIT`
  - `MAX_OPEN_POSITIONS`
  - `TOTAL_ALLOCATION` and `WEIGHTS`
  - Broker status, float, and account restrictions



=============================================================================================================================================
Enhancement Module Activation
=============================================================================================================================================

Overview:
TradeBot includes modular enhancements that can refine signal quality, block trades under poor conditions, or perform startup diagnostics. These are located in `/tbot_bot/enhancements/` and operate as plug-ins—each designed to activate automatically based on strategy context or `.env_bot` configuration.

All enhancements are:
- Independently testable
- Compatible with both TEST_MODE and live mode
- Invoked automatically from `strategy_router.py` or within individual strategy files

Behavior & Integration:
- Each enhancement returns a simple boolean (`True` = allow trade, `False` = block trade)
- If any enhancement fails (e.g., due to missing data), the strategy logs a warning and proceeds with core logic—unless a fatal error is raised
- **Enhancement outcomes are always logged to strategy logs (e.g., `*.log`) and daily summaries, but are never written into the accounting system ledgers to preserve audit clarity and avoid bloat**

Enhancement Modules
------------------------------

1. adx_filter.py – Trend Strength Filter
----------------------------------------
Purpose:
- Blocks mean reversion trades when ADX > 25 (indicating a strong trend)

Applies to:
- strategy_mid.py

Trigger:
- Always-on (future toggle: `ADX_FILTER_ENABLED=true` in `.env_bot`)

Notes:
- Skips VWAP entries during trending markets

2. bollinger_confluence.py – Volatility Confirmation
-----------------------------------------------------
Purpose:
- Requires price to touch or exceed ±2 standard deviations on Bollinger Bands

Applies to:
- strategy_mid.py

Trigger:
- Inline call in strategy_mid.py; may be toggleable in future builds

Notes:
- Reduces false positives in flat or low-volatility conditions

3. vix_gatekeeper.py – Volatility Threshold Lockout
----------------------------------------------------
Purpose:
- Prevents trades if VIX is below configured minimum

Applies to:
- strategy_close.py

Trigger:
- Compares real-time VIX against `STRAT_CLOSE_VIX_THRESHOLD` in `.env_bot`

Notes:
- Helps avoid EOD trades during complacent market conditions

4. imbalance_scanner_ibkr.py – Order Book Pressure Monitor
-----------------------------------------------------------
Purpose:
- Reads Interactive Brokers imbalance data between 20:30–21:00 UTC

Applies to:
- strategy_close.py

Trigger:
- Active only when `BROKER=ibkr`

Notes:
- Blocks late-day trades if strong opposing imbalance is detected (IBKR market data subscription required)

5. ticker_blocklist.py – One Trade Per Ticker Per Day
------------------------------------------------------
Purpose:
- Prevents repeat trades on the same ticker during a single session

Applies to:
- All strategies

Trigger:
- Always-on (no toggle)

Notes:
- Tracks traded symbols in memory or temp file

6. build_check.py – Pre-Launch System Verifier
----------------------------------------------
Purpose:
- Verifies all required files, paths, and variables before runtime

Applies to:
- Called once at startup by `main_bot.py` or via CLI

Checks:
- Presence of `.env`, `.env_bot`, `.env_bot.enc` files
- Writable paths and initialized log files
- Placeholder outputs for first run

Fail Behavior:
- Halts the bot if any check fails

Best Practices:
---------------
- Keep all enhancements decoupled from strategy core logic
- Add toggles in `.env_bot` only if dynamic enable/disable behavior is needed
- Use enhancements to prevent poor trades, not as signal generators
- **Ensure only executed trades are recorded in ledgers; block/skip events are logged only to operational logs and summaries**



=============================================================================================================================================
Unified Safety, Disaster, and Risk Control Protocols (Final Single Broker Version)
=============================================================================================================================================
Overview:
TradeBot includes multiple layered systems to ensure fault-tolerant behavior, risk discipline, and disaster recovery capability.

Two operational layers:

Safety Systems: Immediate fault detection, error handling, and enforced shutdowns for catastrophic failures (global or broker-specific).

Disaster Risk Reduction Protocol: Gradual automatic risk compression triggered by degrading performance, broker-specific losses, or volatility.

All critical thresholds, caps, and behavioral switches are controlled via `.env_bot`, with no hardcoded limits allowed.

------------------------------------------------------
1. Disaster Risk Reduction Protocol (.env_bot Driven)
------------------------------------------------------

Trigger Conditions:
Defense Mode activates automatically if any of the following conditions are met:

| Condition                             | Threshold                                  |
|--------------------------------------|--------------------------------------------|
| Rolling 1-month win rate <           | 50%                                        |
| Float drawdown exceeds               | 15% of starting float                      |
| Mercury reserve drawdown exceeds     | 10%                                        |
| Kill Switch triggered more than      | 2 times in 20 trading days                 |

Immediate Risk Reductions (Sourced from `.env_bot`):

| Element                  | New Behavior                                                      | `.env_bot` Variable                        |
|--------------------------|-------------------------------------------------------------------|--------------------------------------------|
| Defense Mode Activation  | Set `DEFENSE_MODE_ACTIVE=true`                                   | `DEFENSE_MODE_ACTIVE`                      |
| Session Risk Cap         | Override `TOTAL_ALLOCATION` with `DEFENSE_MODE_TOTAL_ALLOCATION` | `DEFENSE_MODE_TOTAL_ALLOCATION`            |
| Max Concurrent Trades    | Scale `MAX_TRADES` by `DEFENSE_MODE_TRADE_LIMIT_PCT`             | `DEFENSE_MODE_TRADE_LIMIT_PCT`             |
| Trade Weight Adjustment  | Dynamic reweighting of `WEIGHTS` based on signal count           | Derived at runtime                         |
| Strategy Aggressiveness  | Higher filter thresholds and disables marginal setups            | Operational (not configurable yet)         |

Behavioral Changes Under Defense Mode:
- Total allocation per strategy is capped at `DEFENSE_MODE_TOTAL_ALLOCATION × current_float`.
- Max trades are reduced:  
  `adjusted_trades = MAX_TRADES × DEFENSE_MODE_TRADE_LIMIT_PCT / 100` (rounded down).
- Float does **not** increase even if temporary profits occur.
- Trade filters become stricter (VWAP, Bollinger, ADX, etc).

Exit Criteria:
Defense Mode deactivates only when either:
- 60 consecutive trades with win rate > 55%, or
- 30 consecutive sessions with win rate > 55%.

All metrics must be logged and auditable.

Rebalancing and Float Restrictions During Defense Mode:

| Category                 | Enforcement Behavior                                                      |
|--------------------------|----------------------------------------------------------------------------|
| Rebalancing Frequency    | Increased to minimum 2× weekly (e.g., Monday + Thursday)                  |
| Reserve Restrictions     | No float injections from Mercury allowed without manual override approval |

Tagging and Logging:
- All trades during Defense Mode must be tagged `DEFENSE_MODE_ACTIVE`.
- Maintain a `disaster_mode.log` file capturing:
  - Activation/deactivation timestamps
  - Trigger condition met
  - Adjusted values (`TOTAL_ALLOCATION`, `MAX_TRADES`)
  - Final resolution metrics

Optional Enforcement Utility (Python):

```python
# risk_bot/defense_mode_utils.py

def calculate_defense_mode_max_trades(normal_max_trades: int, defense_trade_limit_pct: int) -> int:
    if normal_max_trades <= 1:
        return 1
    adjusted_trades = int(normal_max_trades * (defense_trade_limit_pct / 100))
    return max(1, adjusted_trades)

from os import getenv

DEFENSE_MODE_ACTIVE = getenv("DEFENSE_MODE_ACTIVE", "false").lower() == "true"
DEFENSE_MODE_TRADE_LIMIT_PCT = int(getenv("DEFENSE_MODE_TRADE_LIMIT_PCT", 66))
MAX_TRADES = int(getenv("MAX_TRADES", 4))

if DEFENSE_MODE_ACTIVE:
    current_max_trades = calculate_defense_mode_max_trades(MAX_TRADES, DEFENSE_MODE_TRADE_LIMIT_PCT)
else:
    current_max_trades = MAX_TRADES

assert active_trades <= current_max_trades


------------------------------------------------------
2. Core Safety Systems
------------------------------------------------------

2.1. kill_switch.py  
Primary Functionality:  
Automatically halts all trading if realized PnL breaches `DAILY_LOSS_LIMIT`.

Behavior:  
- Shuts down all trading immediately upon breach.  
- Attempts graceful closure of open positions.  
- Logs shutdown reason and threshold violation to persistent shutdown flag.

2.2. watchdog_bot.py  
Primary Functionality:  
Monitors API health and market data feeds in real time.

Behavior:  
- If broker API becomes unresponsive:  
  - Cancel pending orders.  
  - Suspend new trade generation.  
- If system-wide failure (e.g., market data outage):  
  - Trigger full shutdown.  

2.3. risk_bot.py  
Primary Functionality:  
Enforces real-time trading risk constraints using values from `.env_bot`.

Behavior:  
- Enforces:  
  - `MAX_RISK_PER_TRADE` relative to current available float  
  - `TOTAL_ALLOCATION` for the current session  
  - `MAX_TRADES`, `MAX_OPEN_POSITIONS`  
  - Adjusted limits during Defense Mode  
- Blocks trades when violations occur.  
- All validation occurs pre-execution.

2.4. error_handler.py  
Primary Functionality:  
Captures and classifies exceptions during runtime.

Behavior:  
- Categorizes as:  
  - `NetworkError`, `BrokerError`, `LogicError`, `ConfigError`  
- Logs errors with timestamp, strategy, class  
- May trigger shutdown based on severity level  

2.5. security_bot.py  
Primary Functionality:  
Verifies encrypted configuration loading at startup.

Behavior:  
- Requires valid `ENCRYPTION_KEY`  
- Prevents launch if `.env_bot.enc` decryption fails  
- Forbids any plaintext usage in production

------------------------------------------------------
3. Emergency Shutdown Behavior
------------------------------------------------------

Event                            Scope            Action  
------------------------------  ----------------  ------------------------------  
`DAILY_LOSS_LIMIT` breach       Global            Immediate trading shutdown  
Broker API failure              Global            Trading halted until recovery  
Market data failure             Global            Full system shutdown  
Critical system exception       Global            Full system shutdown  
Manual override                 As specified      Controlled shutdown or reset  

- All shutdowns generate final audit logs.  
- All actions are logged and classified in session and error logs.  

------------------------------------------------------
4. Self-Check System
------------------------------------------------------

All core modules (`kill_switch.py`, `watchdog_bot.py`, `risk_bot.py`, `error_handler.py`, `security_bot.py`) must pass `.self_check()` before startup.

Validation must confirm:
- `.env_bot` keys and structure are valid  
- Defense Mode variables (if enabled) are complete  
- Broker connectivity and float retrieval succeed  
- All risk thresholds are parsed and present  

Any failed check prevents launch and logs the exact cause with timestamp.


=============================================================================================================================================
INTEGRATION MODULE – TBOT + ACCOUNTING SYSTEM ALIGNMENT
=============================================================================================================================================

Purpose:
This section mandates integration alignment between the tbot execution system and the forensic-grade accounting system currently under modular build.

Scope:
These rules apply to:
- All tbot trading actions (test or live mode)
- All float injections, float returns, broker cash movements
- All profit/loss logging, reconciliation, and reporting

----------------------------------------------------------------------
KEY INTEGRATION RULES
----------------------------------------------------------------------

1. LEDGER ISOLATION PER ENTITY + BOT
   - All tbot activities must write to the correct ledger for its assigned bot instance:
     - `{ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_ledger.db`
   - No other ledgers (e.g., RGL, RHL, or shared simulation files) may be written by the bot.
   - Float movements between bots or entities must use cross-entity sync and ingestion within the accounting system.

2. MULTI-CURRENCY READINESS
   - All ledger entries must carry an explicit currency code (`currency_code`), even if currently single-currency.
   - The accounting schema supports multi-currency by default; tbot must pass accurate currency codes with each ledger entry.

3. INGESTION PIPELINE COMPLIANCE
   - All broker fills and executed trades must be routed through the accounting system’s ingestion modules.
   - No direct write to final ledger tables is permitted outside of approved ingestion paths.

4. DOUBLE-ENTRY ENFORCEMENT
   - Every tbot-generated ledger entry must obey double-entry constraints (sum of debits = sum of credits).
   - Trade execution, PnL, float movement, and fee posting must balance using system-defined accounts.

5. AUDIT LOGGING
   - All ledger-triggering actions by the bot must create a corresponding audit log in the `logs` table.
   - Any manual correction or backfill must be flagged, source-tracked, and reviewed.

6. OFX EXPORT READINESS
   - Ledger entries must be OFX-aligned and compatible with `generate_ofx.py`:
     - `TRNTYPE`, `DTPOSTED`, `FITID`, broker code, strategy, symbol, size, PnL

7. SYSTEM INDEPENDENCE
   - Tbot must never bypass the accounting system’s validation or export layers.
   - Even in test mode, all simulated trades must flow through ingestion logic and appear in correct ledgers.

----------------------------------------------------------------------
MANDATORY DEPENDENCY MODULES (FROM ACCOUNTING BUILD)
----------------------------------------------------------------------
For tbot-to-ledger integration to function properly, the following accounting modules must be in place:

- Phase 0: Core Framework (`/config.py`, `/utils/db_connection.py`, `/entities/init_db.py`)
- Phase 1: Ingestion Pipeline (`/ingestion/*`, `/processing/normalize.py`, `/logs/logger.py`)
- Phase 4: OFX Export Generator (`/export/generate_ofx.py`)

----------------------------------------------------------------------
RISKS IF IGNORED
----------------------------------------------------------------------
- Ledger corruption and unbalanced entries
- Cross-entity capital contamination
- Regulatory compliance failure (OFX, IRS, SEC)
- Compromised audit integrity
- OFX export failure or tax filing errors
- Inability to distinguish test vs. real trading activity

=============================================================================================================================================
Logging & Reporting Format (Final – Aligned with Single-Broker Architecture)
=============================================================================================================================================

Overview:
Each bot instance writes structured session outputs to support audit trails, dashboards, compliance reports, and downstream ingestion. Log outputs and ledgers are scoped **exclusively to the assigned broker, entity, and bot ID**, with no runtime mode switching.

All filenames and outputs are governed by `.env_bot` and `accounting_config.py`.

Output Scope:
- Logs, trade history, summaries, and unresolved order events
- All files include the bot ID, strategy name, and timestamp when applicable
- Files are separated by type: strategy logs, trade logs, daily summaries

--------------------------------------------------------------------------------
Primary Output Directories
--------------------------------------------------------------------------------

- `output/logs/`          → strategy execution logs, error traces, broker-level issues  
- `output/trades/`        → per-session trade history logs (`csv` or `json`)  
- `output/summaries/`     → final summaries of strategy performance and PnL  
- `backups/`              → auto-archived versions of logs and ledgers (rotated)

--------------------------------------------------------------------------------
Filename Structure
--------------------------------------------------------------------------------

| Type                  | Example Filename Format                                     | Notes                                       |
|-----------------------|-------------------------------------------------------------|---------------------------------------------|
| Strategy Logs         | `open.log`, `mid.log`, `close.log`                          | One per strategy, scoped to bot session     |
| Trade History         | `trade_history.csv`, `trade_history.json`                  | Includes all executed trades                |
| Unresolved Orders     | `unresolved_orders.log`                                     | Captures rejects, partial fills, etc.       |
| Daily Summary         | `daily_summary.json`                                        | One per session, includes PnL, stats        |

All filenames are stored relative to the executing bot’s `output/` subdirectories.

--------------------------------------------------------------------------------
Log Format Configuration
--------------------------------------------------------------------------------

Set via `.env_bot`:

- `LOG_FORMAT=csv` → human-readable output  
- `LOG_FORMAT=json` → structured output for parsing, dashboards, ingestion

Only one format is written per session based on this variable.

--------------------------------------------------------------------------------
Required Fields – `trade_history.json`
--------------------------------------------------------------------------------

Each entry must include:

- `timestamp`          → ISO 8601 UTC timestamp  
- `strategy_name`      → open, mid, or close  
- `ticker`             → equity or ETF symbol  
- `side`               → long or short  
- `size`               → share or contract count  
- `entry_price`        → float  
- `exit_price`         → float  
- `PnL`                → float (realized only)  
- `broker`             → string from `.env_bot`  
- `error_code`         → if applicable (e.g., rejection, partial)

--------------------------------------------------------------------------------
Ledger Routing – Single-Broker Enforcement
--------------------------------------------------------------------------------

All trades are routed to the correct ledger using:

- Bot-assigned entity code  
- Jurisdiction code  
- Broker code  
- Bot ID  
- Ledger name suffix: `_TB_ledger.db`




**Ledger path format:*
output/ledgers/{ENTITY_CODE}{JURISDICTION_CODE}/ledgers/bot/{ENTITY_CODE}{JURISDICTION_CODE}{BROKER_CODE}_{BOT_ID}_TB_ledger.db

Example:

output/ledgers/TEST_USA_ALPACA_01_TB.db 

This is enforced by the accounting system. The bot **never selects its own ledger path**.

--------------------------------------------------------------------------------
Export + Archive Flow
--------------------------------------------------------------------------------

1. `reporting_bot.py` collects trade logs post-session  
2. `accounting_api.py` submits all entries to ingestion pipeline  
3. `accounting_config.py` resolves final ledger and export destinations  
4. `generate_ofx.py` emits OFX 1.x/2.x output  
5. `auto_backup.py` archives all logs and ledgers (timestamped)

--------------------------------------------------------------------------------
Key Principles
--------------------------------------------------------------------------------

- Logs are **parallel audit artifacts** — never re-imported into ledgers  
- No separation of live vs paper trades — bot operates on one ledger only  
- Accounting system handles test/live classification **externally** via assigned ledgers  
- All outputs must be fully deterministic, timestamped, and account-mapped

--------------------------------------------------------------------------------
Use Cases
--------------------------------------------------------------------------------

- Daily PnL reports  
- Internal audit and compliance verification  
- Real-time dashboard ingestion  
- Historical trade analysis  
- Export to regulatory or tax systems via OFX



=============================================================================================================================================
Ledger Chart of Accounts (Final – Single-Broker TBot Architecture)
=============================================================================================================================================

This chart of accounts defines the structure for all TBot-generated SQLite ledgers, which are OFX-compliant and maintained under the accounting system’s `entities/{ENTITY_CODE}_{JURISDICTION_CODE}/ledgers/bot/` directory.

Each bot instance writes only to its assigned ledger file:
`output/ledgers/{ENTITY_CODE}_{JURISDICTION_CODE}_{BROKER_CODE}_{BOT_ID}_BOT_ledger.db`

------------------------------------------------------------------------------------------
TBot Execution Ledger – Chart of Accounts (BOT-Only Scope) pre-determined prefix
------------------------------------------------------------------------------------------

1000 Bank and Cash Accounts [Cash & Cash Equivalents]  
├── 1010 Float Injection – From Parent  
├── 1020 Float Returned – To Parent  
├── 1030 Broker Cash Balance  

1100 Assets [Broker Holdings]  
├── 1110 Brokerage Account – Equities  
├── 1120 Brokerage Account – Options (if used)  

2000 Liabilities [Operating Activities]  
├── 2010 Broker Payables (Accrued Fees)  
├── 2020 Market Data Payables  

3000 Equity [Capital Structure]  
├── 3010 Capital Float Ledger  
├── 3020 Float Allocation History  
├── 3030 Opening Balance  
├── 3040 Accumulated Profit  

4000 Income [Realized PnL]  
├── 4010 Realized Gains – Equities  
├── 4020 Realized Gains – Options  
├── 4030 Qualified Dividends  
├── 4040 Short-Term Gains  
├── 4050 Long-Term Gains  

5000 Expenses [Execution Overhead]  
├── 5010 Broker Fees  
├── 5020 Slippage / Execution Loss  
├── 5030 API / Market Data Penalties  
├── 5040 Bot Infrastructure  

9100 Exports [Session Export Control]  
├── 9110 Daily PnL Export – OFX  
├── 9120 Trade Log Export (CSV/JSON)  
├── 9130 Ledger Backup Archive  
├── 9140 Confirm Archive (PDFs)  
├── 9150 End-of-Day Snapshot  

9200 Execution Meta [Trade Attribution + Logging]  
├── 9210 Trade UUID  
├── 9220 Confirm #  
├── 9230 Strategy Tag  
├── 9240 Source Tag  
├── 9250 Sync Confirmation Flag  
├── 9260 Reconciliation Success Flag  

9300 System Integrity [Ledger Health Flags]  
├── 9310 Rejects and Order Failures  
├── 9320 Manual Adjustments  
├── 9330 Ledger Lock Flag  
├── 9340 Ledger Status (ACTIVE / DECOMMISSIONED)  
├── 9350 Final Timestamp Written  
├── 9360 Debug / Signal Annotations  

------------------------------------------------------------------------------------------
Export Constraints and System Enforcement
------------------------------------------------------------------------------------------

- All `.csv` or `.json` logs are **external audit artifacts** and never parsed into the ledger  
- Only validated, reconciled trade data is written to the ledger after each strategy session  
- Each ledger must pass integrity validation before export  
- If ledger fails schema or double-entry validation, export process will abort  
- Export system relies on:
  - `/config.py`  
  - `/utils/db_connection.py`  
  - `/entities/init_db.py`  
  - `/ingestion/` modules  
  - `/processing/normalize.py`  
  - `/logs/logger.py`  
  - `/export/generate_ofx.py`  

All ledger structures must comply with OFX alignment to ensure downstream export, tax prep, and inter-system reconciliation.





=============================================================================================================================================
Secure Environment Variables
=============================================================================================================================================

Overview:

TradeBot separates its runtime configuration into two environment files:

.env contains broker credentials, API keys, encryption keys, and SMTP credentials.

.env_bot defines trading logic, timing, strategy settings, and risk controls.

Security Goals:
Never expose .env_bot contents in plaintext on shared systems.

Ensure only validated and decrypted variables are loaded during runtime.

Allow encrypted deployment on remote servers (e.g., DigitalOcean) without exposing raw configuration.

Encryption System:
.env_bot is encrypted using AES-256 via the cryptography module.

The encrypted version is saved as .env_bot.enc.

Decryption Key: The decryption key is defined in the global .env file under:

ENCRYPTION_KEY="your-256-bit-key"

Required Files:

encrypt_env_bot.py: Handles encryption and decryption of the .env_bot file, and writes the encryption key to the .env file.

encrypt_password.py: A CLI tool to encrypt login credentials for the web interface and write the encryption keys to the .env file.

Encryption Workflow:
Create .env_bot:

Start with a plaintext .env_bot file and populate it with all necessary variables.

Encrypt .env_bot:

Run the encrypt_env_bot.py to generate the .env_bot.enc and store the ENCRYPTION_KEY securely inside .env.

Runtime Decryption:

During runtime, env_bot.py will:

Load and decrypt the .env_bot.enc using the key from .env.

Validate all keys, and raise readable errors if any are missing or malformed.

Manual Encryption Example:
To manually encrypt the .env_bot file, use the following command:

python3 encrypt_env_bot.py

Security Notes:
Never include .env_bot or .env_bot.enc in version control or build packages.

Use .scpignore and .gitignore to ensure these files are excluded from commits.

Encrypted files should only be decrypted in-memory or on secure systems.

Ensure that access to .env and `.env_bot.enc is restricted** on production environments.

Best Practices:
Test decryption and validation in a staging environment before deploying to production.

Rotate encryption keys regularly, especially if deployment environments or personnel change.

Log any failed decryptions or missing variables to the unresolved_orders_*.log files for auditing purposes.

Recovery:
If .env_bot.enc becomes corrupted or if the decryption key is lost:

Retrieve the latest .env_bot backup from the /backups/ folder.

Re-encrypt using the encrypt_env_bot.py script.



=============================================================================================================================================
Centralized Error Management
=============================================================================================================================================
------------------------------------------------------------
Overview:
------------------------------------------------------------
TradeBot uses a centralized error handling system to monitor and manage failures during runtime across all modules. The error_handler.py module ensures that critical issues are logged, reported, and escalated appropriately — preventing silent failures or inconsistent states.


------------------------------------------------------------
TradeBot-001 Full Emergency Event Matrix
------------------------------------------------------------


Event
Detection Module
Scope
System Response
Reboot Needed?
Broker PnL Loss > DAILY_LOSS_LIMIT
kill_switch.py
Broker only
Halt trading at that broker; log shutdown flag
No
Broker API Down (e.g., Tradier offline)
watchdog_bot.py
Broker only
Suspend trading at that broker until recovery
No
Global Market Data Feed Down
watchdog_bot.py
All brokers
Full bot shutdown (stop_bot.py triggered)
Yes
.env_bot Decryption Failure
security_bot.py
All brokers
Block launch; log failure immediately
Yes
Runtime Logic Error (e.g., invalid risk calculation)
error_handler.py
Depends on severity
Escalate to kill_switch if critical
Yes if escalated
Defense Mode Activation
risk_bot.py (trigger) + .env_bot (flag)
All brokers
Compress session risk and limit trades dynamically
No
Trade Validation Failure (e.g., oversize order)
risk_bot.py
Broker only
Block trade silently, log error; no crash
No
Manual Emergency Shutdown Request
control_stop.txt (CLI or web)
Specified broker or all
Safe shutdown initiated immediately
Yes
System File Integrity Failure (missing .env_bot, bad paths)
build_check.py
All brokers
Abort launch with critical error log
Yes

------------------------------------------------------------

Module: tbot_bot/error_handler.py

Capabilities:
Captures and categorizes exceptions from:

Strategy modules (e.g. logic errors, data type mismatches)

Broker interface modules (broker_api.py, broker_ibkr.py, etc.)

Utility and infrastructure modules (reporting_bot.py, risk_bot.py, etc.)

Error Classification:
NetworkError: API connectivity issues, timeouts, DNS failures

BrokerError: Order rejection, margin issues, invalid asset classes

LogicError: Runtime logic issues or invalid config values

ConfigError: Missing keys or improperly formatted values in .env_bot

Logging Behavior:
Log Destination:
All errors are written in a structured format to:

unresolved_orders.log

Format: JSON or CSV depending on LOG_FORMAT

Logged Fields:

timestamp

strategy_name

broker

error_type

error_code (optional)

raw_exception (full stack trace, truncated to prevent log overflow)

Retry & Fallback:
Implements exponential backoff retry logic for transient failures (e.g., temporary API downtime)

If retry fails after API_RETRY_LIMIT, error is escalated and logged to ensure system doesn't silently continue

Notification System:
For critical errors or unresolved rejections, triggers alerts via notifier_bot.py

Alerts include:

Timestamp

Error summary

Strategy context

Broker info

Alert channels are defined via SMTP settings in .env

Kill Switch Integration:
On detection of unrecoverable error conditions, the error handler:

Invokes kill_switch.py to halt further trades

Ensures a clean shutdown, logs the shutdown reason to logs_bot.py

Optional Integration:
Can be linked to status_web.py and logs_web.py to show error status via the dashboard

Failsafe behavior should never rely on frontend modules — operates fully headless

Usage Notes:
Must be imported and initialized in main_bot.py and reused across all critical modules

When possible, all exceptions should be wrapped and passed to error_handler.handle() with appropriate classification tags

Ensures maximum transparency and auditability of all failed or skipped trades


Overview:
To ensure robustness and validate strategy logic before deployment, TradeBot includes a complete historical backtesting engine. This framework simulates trades using historical data and provides actionable performance metrics, helping to optimize and refine strategies before live trading.

Module:

backtest_engine.py

Features:
Simulates historical trades using the same strategy logic found in:

strategy_open.py

strategy_mid.py

strategy_close.py

Loads minute-level OHLCV (Open, High, Low, Close, Volume) data via load_historical_data.py

Bypasses live broker APIs: Trades are simulated internally, ensuring no live trades are executed during backtesting

Compatible with both CSV and JSON output formats

Results are stored in a subfolder such as backtest_results/

Reuses all logic and environment variables from .env_bot, ensuring consistency between backtesting and live/trading environments

Performance Metrics (via performance_metrics.py):
Win Rate (%): Percentage of profitable trades

Maximum Drawdown: Largest peak-to-trough decline in equity during backtest

Average Trade Duration: Time between trade entry and exit

Average PnL per trade: Average profit or loss per trade

Sharpe Ratio: Measures risk-adjusted return

Charts & Reports:
Visualize equity curve, drawdown, and entry/exit points using plot_results.py

Command-Line Interface:
To run the backtest engine, execute the following command from the root of the tbot_bot/ directory:

python backtest/backtest_engine.py --strategy=open --start=2023-01-01 --end=2023-12-31 --data_source=./historical_data/open_ohlcv.csv
--strategy: Specifies the strategy to backtest (e.g., open, mid, close)

--start: Start date for the backtest

--end: End date for the backtest

--data_source: Path to the CSV file containing the historical data

Runtime Configuration:
All parameters (e.g., allocation, thresholds, filters) are pulled from .env_bot

TEST_MODE logic is automatically assumed (no real trades are executed during the backtest)

Filters (e.g., volume, price) may be toggled manually for analysis

Supported Strategies:
open, mid, close — these strategies must be listed in STRATEGY_SEQUENCE in .env_bot

Each strategy must support a .simulate() method or equivalent backtest logic

Ledger Output:
Trade logs generated during backtests will be written to:

trade_history_backtest.csv

trade_history_backtest.json

daily_summary_backtest.json

These files do not modify ledgers

Ledger export is not used during backtesting

All backtest outputs are strictly isolated from the production accounting system. No OFX entries, no SQLite ledger writes, and no accounting integration are performed during backtest runs.

Logging Format:
All simulated trade logs follow the same structure as live runs:

timestamp

strategy_name

ticker, side, size

entry_price, exit_price, PnL

mode=backtest

Notes:
The backtest engine is sandboxed and stateless, ensuring no interference with live systems

Required step: Backtesting must be completed before any new strategy can be deployed to live trading

Does not depend on tbot_api/ or tbot_web/ — fully independent from web interface or broker APIs



=============================================================================================================================================
Testing and Validation Suite
=============================================================================================================================================

Overview:
A robust testing framework ensures that all TradeBot logic executes as expected across strategies, environments, and runtime modes. The following tools, test files, and logic gates are implemented to support validation prior to any live deployment.

Testing Directory Structure:
Located in: `tbot_bot/tests/`

Files:
- `test_main_bot.py` – Verifies lifecycle loop, strategy routing, and logger integrity.
- `test_env_bot.py` – Confirms full variable coverage, validation errors, and defaults in `.env_bot`.
- `test_backtest_engine.py` – Runs simulated trades on sample historical data and verifies consistency with execution rules.
- `test_strategy_selfcheck.py` – Confirms that `.self_check()` returns True across all strategies.
- `test_logging_format.py` – Validates that the log format matches the JSON structure schema.
- `test_broker_trade_stub.py` – Sends randomized micro-trades to broker in TEST_MODE to validate order flow, response, and logging.
- `test_screener_random.py` – Runs screener logic with randomized symbols to confirm filtering and eligibility logic.
- `test_strategy_tuner.py` – Executes strategy modules in isolation with test tickers to validate signal logic, threshold configs, and entry/exit paths.
- `integration_test_runner.py` – Launches end-to-end simulation of a trading session (`TEST_MODE` only).

Planned:
- `test_broker.py` – **Manual test to place one live trade and close it immediately (used for broker readiness validation).** Not yet implemented.

Framework:
- All tests use `pytest` and must be runnable via CLI or CI/CD pipeline.
- Tests are modular and can be run individually or in batches.
- Output formats are compatible with `--junitxml` and CI test reporters.

Example Test Command:
```bash
pytest tbot_bot/tests/


Integration Test Workflow:
- Loads a simulated `.env_bot.test` config.
- Launches `main_bot.py` using `TEST_MODE=true`.
- Injects historical price data using mocks or patched inputs.
- Runs `start_bot.py` in dry-run mode.
- Verifies the following:
  - Strategy execution order (based on `STRATEGY_SEQUENCE`)
  - Log generation to the correct files
  - Proper handling of signals, triggers, and errors
  - Trade integrity and structure of all logs and exports

CI Compatibility:
- Compatible with GitHub Actions, GitLab CI, or local test runners.
- All test scripts and outputs are headless (no GUI, web UI, or API calls required).
- Custom `.env_bot.test` config files may be loaded during CI runs with overrides.

Requirements:
- Python 3.11+
- `pytest`, `pydantic`, and all packages listed in `requirements.txt`

Test-Mode Enforcement:
- `integration_test_runner.py` MUST only run with `TEST_MODE=true`.
- All trade outputs are written to logs.
- Test failures are captured and printed to `stdout`/`stderr` immediately.

Version Compliance:
- `test_env_bot.py` must validate that `.env_bot["VERSION_TAG"]` matches `VERSION.md`.
- Build is considered invalid if the version tags are mismatched.



=============================================================================================================================================
Real-Time Monitoring Dashboard
=============================================================================================================================================

Overview:
The web interface provided by tbot_web/ includes a live dashboard designed to monitor bot operations, active positions, and key runtime metrics. This dashboard operates independently of trading logic and is updated via background tasks and lightweight API polling.

Purpose:
Provides remote visibility into trading activity and system health.

Allows real-time monitoring without compromising headless operation.

Offers read-only observability and does not affect core strategy execution.

Metrics to Display:
Current Active Strategy: Displays which strategy is currently active (strategy_open.py, strategy_mid.py, strategy_close.py).

Scheduled and Actual UTC Start Times: Shows scheduled and actual UTC start times from .env_bot.

Trade Metrics: Number of trades signaled, entered, and exited.

Real-Time P&L: Per position and cumulative profit and loss.

Active Positions: Displays all open trades with:
- Ticker
- Side (long/short)
- Size
- Entry price
- Current price
- Unrealized PnL
- Strategy


Broker Connectivity and API Status: Monitors broker connection status via watchdog_bot.py.

System State: The current state of the bot, e.g., idle, analyzing, trading, or shutdown.

API Retry Count or Recent Error Summary: Tracks retries or errors.

Test Mode Indicator: Displays whether the bot is running in test mode (true/false).

Frontend Components:

status.html: Displays live strategy state and performance metrics - Bot status and strategy state are streamed from output/status.json

logs.html: Streams major log events, alerts, and errors.

main.html: A container layout for the dashboard navigation.

index.html: Login portal to auth_web.py: AES decryption for login password validation.

Backend Modules:
status_web.py: Streams live data from status_bot.py to the frontend.

logs_web.py: Exposes recent log snapshots.

start_stop_web.py: Optional lifecycle control from the web UI.

main_web.py: Flask router and load shell for dashboard interface.

login_web.py: Handles user authentication.

Implementation Details:

Data is updated via lightweight polling using Flask routes and JSON endpoints.

The web layer relies on .env credentials for login and encrypted session management.

Supports read-only mode for secure deployments where no trading control is exposed to the web interface.

Security:
Login Rate Limiting: Login attempts are rate-limited via SlowAPI.

Failed Login Logging: Failed login attempts are written to logs/web/auth_failures.log.

Successful Login Logging: Successful access is logged to logs/web/access.log.

Important Notes:
The dashboard is optional and not required for bot functionality.

All bot logic must remain functional even if the tbot_web interface is disabled or unreachable.

The dashboard can be monitored from desktop, tablet, or mobile devices, even in low-bandwidth environments.


=============================================================================================================================================
RIGD GROUP LLC — TradeBot-001 Runtime Flow (Final Full Version)
=============================================================================================================================================

Phase 0: Pre-Session (Preparation)

[ MANUAL ACTION ]
    ↓
- Configure .env_bot (.env if needed)
- Decrypt env_bot.enc using security_bot.py
- Ensure .env includes ENCRYPTION_KEY
- Launch control_start.txt or Web UI portal
    ↓

Phase 1: System Boot Validation

BOOT SEQUENCE INITIATED
    ↓
security_bot.py → Decrypts and loads .env_bot using ENCRYPTION_KEY
    ↓
env_bot.py → Validates all required environment variables
    ↓
self_check() validation for:
    - risk_bot.py
    - kill_switch.py
    - watchdog_bot.py
    - error_handler.py
    - strategy_router.py
    ↓
IF any self_check fails → Abort launch and log to output/logs/error_tracebacks.log
ELSE → Proceed to session initialization
    ↓

Phase 2: Session Initialization

SESSION START
    ↓
float_bot.py → Pull broker float values from accounting system
    ↓
Load runtime parameters from .env_bot:
    - MAX_TRADES, MAX_OPEN_POSITIONS
    - TOTAL_ALLOCATION, WEIGHTS
    - Defense Mode overrides if DEFENSE_MODE_ACTIVE=true
    ↓
status_bot.py → Write initial status to output/status.json
    ↓
BEGIN STRATEGY CYCLE
Phase 3: Strategy Cycle (Open → Mid → Close)

[ At each STRATEGY_UTC_START_TIME ]
    ↓
strategy_router.py → Loads and runs active strategy
    ↓
Strategy-level self_check():
    - Validates timing, broker access, float presence
    ↓
finnhub_screener.py → Load symbol candidates
    ↓
For each eligible symbol:
    - Calculate risk allocation using WEIGHTS
    - Validate risk caps (MAX_RISK_PER_TRADE, MAX_TRADES)
    ↓
If validation passes:
    → broker_api.py → send order via broker adapter (e.g., alpaca.py, ibkr.py)
    → trade_logger.py → log trade to output/trades/
Else:
    → Log to output/logs/unresolved_orders.log
    ↓
Monitor:
    - Trailing stops, VWAP exits, VIX filters
    - API health via watchdog_bot.py
    - PnL via kill_switch.py
    ↓
Strategy phase ends after monitoring window

Phase 4: Risk and Fault Monitoring (Continuous)

During execution:
    ↓
- risk_bot.py enforces ALL caps and Defense Mode overrides
- kill_switch.py watches per-broker DAILY_LOSS_LIMIT
- watchdog_bot.py tracks API connectivity
- error_handler.py logs stack traces to error_tracebacks.log
    ↓
If triggered:
    - kill_switch.py → halt broker trading
    - watchdog_bot.py → suspend broker or halt system
    - All trades tagged if DEFENSE_MODE_ACTIVE=true
    - All events logged to disaster_mode.log and unresolved_orders.log

Phase 5: Session Termination

END OF STRATEGY WINDOWS
    ↓
stop_bot.py closes any remaining positions
    ↓
reporting_bot.py writes:
    - trade_history.csv/json
    - open.log, mid.log, close.log
    - daily_summary.json
    - disaster_mode.log if applicable
    ↓
accounting_api.py → Ingests trades into assigned ledger:
    → entities/{ENTITY}_{JURIS}/ledgers/bot/{ENTITY}{JURIS}{BROKER}_{BOT_ID}_BOT_ledger.db
    ↓
auto_backup.py → Archives logs and ledgers to backups/
    ↓
status_bot.py → Marks session status as "CLOSED"
    ↓
SESSION COMPLETE

Phase 6: Manual Review and Rebalancing (Post-Session)

- Review logs, trade history, daily summary
- Reconcile float via accounting system
- Run generate_ofx.py if export needed
- If DEFENSE_MODE was triggered, adjust .env_bot flag and document recovery plan

=============================================================================================================================================
Key Design Confirmations
=============================================================================================================================================

Key Design Confirmations:
- All trades execute through a single assigned broker per bot instance, with float, risk, and PnL enforced via the accounting system.
- System-wide shutdowns occur only for critical failures (global market data outage, broker API unresponsive, core logic errors).
- Defense Mode activates automatically on drawdown or win-rate triggers and enforces:
  - Reduced TOTAL_ALLOCATION
  - Scaled-down MAX_TRADES
  - Stricter filters (VWAP, ADX, Bollinger)
- Full audit trail is maintained across:
  - Structured logs (`output/logs/`)
  - Trade history (`output/trades/`)
  - Daily summary (`output/summaries/`)
  - Ledger ingestion and OFX exports (`entities/{ENTITY}_{JURIS}/ledgers/bot/`)
- The Web Dashboard (`status.html`, `status_web.py`) reflects real-time strategy state, float usage, broker health, and session metrics.


=============================================================================================================================================
TradeBot Master Build Enhancements
=============================================================================================================================================

This addendum outlines advanced features and architectural upgrades to be implemented **after** the core single-server build is debugged, stabilized, and validated.

---

### 1. Automated Rebalance Triggers (Bot-Initiated, Accounting-Executed)

- Define threshold-based triggers in `.env_bot`:
  - Example: If broker float deviates >10% from target, issue a rebalance request.
- Implement `rebalance_notifier.py`:
  - Reads current vs. target float allocations (via accounting system API).
  - Notifies the accounting system via authenticated POST (acct_api_credentials.json.enc).
  - All transfer logic (ACH, ledger sync) is executed by the accounting system, not the bot.
- Tag and log each trigger:
  - `rebalance_request.log` (timestamp, broker, float delta, status).
  - Must generate OFX-ready audit entries upon accounting system fulfillment.
- Coordination with:
  - `risk_bot.py` (to pause risky trades when imbalance detected).
  - `kill_switch.py` (to halt trading if float breach is extreme).

---

### 2. Multi-User Access Roles (Web + Runtime Enforcement)

- Expand `tbot_web/` to include Role-Based Access Control (RBAC):
  - Roles: `admin`, `operator`, `auditor`, `viewer`.
- Implement RBAC-backed login system:
  - Bcrypt-encrypted credentials stored in `SYSTEM_USERS.db`.
  - Role-checked endpoints for viewing, starting, or stopping strategies.
- Logs:
  - All login and route access attempts recorded in `logs/web/access.log` and `auth_failures.log`.

---

### 3. Strategy Optimization & Parameter Tuning

- Create `strategy_optimizer.py`:
  - Periodically runs full backtests across past N days.
  - Uses grid search, genetic algorithms, or Bayesian optimization to tune:
    - Entry buffers
    - Exit stops
    - VWAP thresholds
- Results stored under:
  - `backtest_results/strategy_tuning/`
- Flags configs for human approval:
  - Version-controlled as `env_bot.versioned/`
  - No auto-activation allowed without manual promotion.

---

### 4. Real-Time Alerting & Incident Escalation

- Extend `notifier_bot.py` with:
  - Slack, PagerDuty, or SMS alerting modules.
- `.env_bot` defines alert channels and severity levels:
  - `CRITICAL_ALERT_CHANNEL=PagerDuty`
  - `NOTIFY_ON_FILL=true`, `NOTIFY_ON_EXIT=true`, `NOTIFY_ON_FAILURE=true`
- Alerts must include:
  - UTC timestamp
  - Strategy
  - Ticker and PnL (if applicable)
  - Root error or trigger

---

### 5. Slippage & Latency Simulation for Backtesting

- Extend `backtest_engine.py` to support:
  - Configurable simulated latency (e.g., 500ms delay).
  - Slippage model:
    - Rule-based: ± X% from theoretical price.
    - Randomized: sampled from historical distribution.
- Configurable via `.env_bot.test`.
- Generates comparison summary:
  - `backtest_slippage_comparison.json`

---

### Implementation Notes

- All enhancements must:
  - Include `.self_check()` validation.
  - Be modular and toggled independently via `.env_bot`.
  - Maintain isolated logs (e.g., `optimizer.log`, `rebalance_request.log`, `notifier_alerts.log`).
- None of these enhancements may interfere with live operation if disabled.
- Priority goes to features improving:
  - Safety and resilience
  - Scalability and auditability
  - Runtime integrity across single and multi-broker futures
=============================================================================================================================================
Final Build Checklist (Single-Broker Mode, No TEST_MODE References, No Paper Mode references)
=============================================================================================================================================

This checklist ensures that all components of TradeBot are production-ready, internally consistent, and compliant with safety, logging, and accounting requirements. Every item must pass validation prior to deployment.

------------------------------------------------------------------------------------------------------------------------
Configuration:
------------------------------------------------------------------------------------------------------------------------
- `.env` is present with populated:
  - `ENCRYPTION_KEY`
  - SMTP credentials
  - Local IP and PORT for Flask
  - Login credentials and runtime toggles

- `.env_bot` is either decrypted at runtime or loaded from `.env_bot.enc`
  - All strategy, risk, and logging variables are present and valid
  - `VERSION_TAG` inside `.env_bot` matches root `VERSION.md`

------------------------------------------------------------------------------------------------------------------------
Environment Validation:
------------------------------------------------------------------------------------------------------------------------
- `env_bot.py` performs full schema validation
  - Fails fast on missing, malformed, or out-of-range keys
- `.env_bot.template-test` is complete and up to date with inline comments

------------------------------------------------------------------------------------------------------------------------
Strategy Logic:
------------------------------------------------------------------------------------------------------------------------
- `main.py` loads `STRATEGY_SEQUENCE` and dispatches to the correct strategy module
- Each strategy module (`strategy_open.py`, `strategy_mid.py`, `strategy_close.py`) implements and passes `.self_check()`
- Execution logic respects all filters and constraints:
  - Volume filters, slippage limits, spread checks, ticker blocklist

------------------------------------------------------------------------------------------------------------------------
Logging System:
------------------------------------------------------------------------------------------------------------------------
- All logs routed by `accounting_config.py` based on bot assignment
- All log entries include:
  - timestamp, ticker, side, size, prices, strategy, broker, float source, trade result
- Logs written to:
  - `output/logs/`          → strategy, error, and unresolved order logs
  - `output/trades/`        → trade history per session
  - `output/summaries/`     → final session summaries
- Rotated logs are archived into `/backups/` by `auto_backup.py`
- `LOG_FORMAT` (`csv` or `json`) is enforced globally via `.env_bot`

------------------------------------------------------------------------------------------------------------------------
Ledger Export & Accounting Integration:
------------------------------------------------------------------------------------------------------------------------
- `reporting_bot.py` collects trade data
- `accounting_api.py` routes all exports through ingestion pipeline
- Output ledger file path is:
  `entities/{ENTITY_CODE}_{JURISDICTION_CODE}/ledgers/bot/{ENTITY}{JURIS}{BROKER}_{BOT_ID}_BOT_ledger.db`
- Ledger schema defined by `ledger_schema.py`, validated before write
- `generate_ofx.py` produces OFX-aligned exports
- All ledger writes are:
  - Double-entry
  - Currency-tagged
  - OFX-compliant
- Ledger exports are backed up to `/backups/`

------------------------------------------------------------------------------------------------------------------------
Broker Routing & Connectivity:
------------------------------------------------------------------------------------------------------------------------
- `broker_api.py` dispatches to exactly one broker assigned to this bot
- `watchdog_bot.py` continuously monitors broker connectivity and order responsiveness

------------------------------------------------------------------------------------------------------------------------
Risk & Shutdown Enforcement:
------------------------------------------------------------------------------------------------------------------------
- `kill_switch.py` halts trading on breach of `DAILY_LOSS_LIMIT`
- `risk_bot.py` enforces:
  - Allocation caps
  - Trade sizing limits
  - Max concurrent positions
  - Strategy-specific constraints
- `error_handler.py` logs and classifies uncaught exceptions
- `stop_bot.py` closes all open trades and ends session cleanly
- Shutdown reasons and audit flags are written to log and status

------------------------------------------------------------------------------------------------------------------------
Notifications:
------------------------------------------------------------------------------------------------------------------------
- `notifier_bot.py` sends trade fill and exit alerts if enabled
  - SMTP settings sourced from `.env`
  - Alert frequency and severity configured via `.env_bot`
- Alerts respect suppression logic for non-critical conditions

------------------------------------------------------------------------------------------------------------------------
Testing & QA:
------------------------------------------------------------------------------------------------------------------------
- Dry-run cycle completed using accounting-assigned ledgers
- `pytest` passes all unit tests in `tbot_bot/tests/`
- `integration_test_runner.py` simulates end-to-end strategy lifecycle
- `test_broker.py` executes a minimal live trade and exit (manual trigger only)
- No test references to deprecated `TEST_MODE` or `PAPER_MODE` remain
- All backtest output is sandboxed and isolated from production exports

------------------------------------------------------------------------------------------------------------------------
Web Interface:
------------------------------------------------------------------------------------------------------------------------
- Flask app (`tbot_web/`) runs on designated IP/PORT
- Login authentication and encryption confirmed using:
  - `encrypt_password.py`
  - `ENCRYPTED_PASSWORD` from `.env`
- Start/Stop controls write to:
  - `control/control_start.txt`
  - `control/control_stop.txt`
- Dashboard routes:
  - `/status`, `/logs`, `/settings` return correct session values
  - Access controls and session visibility enforced per RBAC design

------------------------------------------------------------------------------------------------------------------------
Deployment:
------------------------------------------------------------------------------------------------------------------------
- All file paths are relative and cross-platform (Linux/macOS)
- Flask server and bot logic run as independent processes:
  - `start_bot.py` launches main execution loop
  - `service_bot.py` used for daemon/service mode
- All sensitive paths are excluded via `.scpignore_*`
- Version tag in `.env_bot` matches `VERSION.md`
- Final logs, ledgers, and exports backed up and archived cleanly
- No test files, temp logs, or placeholder credentials exist in repo

------------------------------------------------------------------------------------------------------------------------
Post-Session Rebalancing Triggers:
------------------------------------------------------------------------------------------------------------------------
- If float deviation exceeds threshold (`REBALANCE_THRESHOLD`), bot notifies accounting system
- `rebalance_bot.py` (future module) emits rebalance signal only — **actual transfers** are handled by accounting system
- All rebalance alerts are logged and timestamped




































